

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>2. Repräsentation &#8212; Online-Skript Datenbanksysteme II</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '02/repraesentation';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3. Indizes" href="../03/indizes.html" />
    <link rel="prev" title="1. Speicherung" href="../01/speicherung.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/DBIS_Kurzlogo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/DBIS_Kurzlogo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Datenbanksysteme II
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../01/speicherung.html">1. Speicherung</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">2. Repräsentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03/indizes.html">3. Indizes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04/anfrageausfuehrung.html">4. Anfrageausführung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05/optimierung.html">5. Optimierung</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/LUH-DBS/GDBS_Script" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/LUH-DBS/GDBS_Script/issues/new?title=Issue%20on%20page%20%2F02/repraesentation.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/02/repraesentation.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Repräsentation</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#aufbau">2.1. Aufbau</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#felder-etc">2.2. Felder etc.</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#datentypen">2.3. Datentypen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#datum-bit-boolean">2.3.1. Datum / Bit / Boolean</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#datensatze">2.4. Datensätze</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#datensatze-fester-lange">2.4.1. Datensätze fester Länge</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#versatz-zur-effizienz">2.4.2. Versatz zur Effizienz</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#speicherung-der-metadaten">2.5. Speicherung der Metadaten</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#aufteilung-in-blocke">2.5.1. Aufteilung in Blöcke</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#adressierung">2.6. Adressierung</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adressraum-des-servers">2.6.1. Adressraum des Servers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#logische-adressen">2.6.2. Logische Adressen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hybride-adressierung">2.6.3. Hybride Adressierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#columnar-storage">2.6.4. Columnar Storage</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#variable-langen">2.7. Variable Längen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finden-von-feldern-variabler-lange">2.7.1. Finden von Feldern variabler Länge</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#datensatze-variabler-lange">2.7.2. Datensätze variabler Länge</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anwendungsfalls-sparsedatabeispiel-linkedopen-data">2.7.3. Anwendungsfalls SparseDataBeispiel: LinkedOpen Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#microsoft-sql-server-sparse-columns">2.7.4. Microsoft SQL Server: SPARSE columns</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zu-grosze-datensatze">2.7.5. Zu große Datensätze</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#datensatzanderungen">2.8. Datensatzänderungen</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="reprasentation">
<h1><span class="section-number">2. </span>Repräsentation<a class="headerlink" href="#reprasentation" title="Permalink to this heading">#</a></h1>
<p>Bis hierhin haben wir nur auf einer sehr abstrakten Ebene besprochen, was für Daten wo liegen und wie diese Datenblöcke gelesen werden können. Womit wir uns noch nicht befasst haben, ist wo bestimmte Tupel und Blöcke liegen. Nach unserer intuitiven Vorstellung hoffen wir, dass alle Tupel einer Relation hintereinander im Speicher zu finden sind, das ist aber oftmals nicht der Fall. Nun muss ein Weg gefunden werden diese Tupel und Blöcke zu lesen, ohne bei jeder Anfrage die gesamte Festplatte lesen zu müssen.</p>
<p><strong>Architektur</strong></p>
<a class="reference internal image-reference" href="../_images/5-Schichten-Architektur1.png"><img alt="5-Schichten-Architektur" src="../_images/5-Schichten-Architektur1.png" style="width: 500px;" /></a>
<p>In diesem Kapitel befinden wir uns in der Systempufferschnittstelle. Hier geht es hauptsächlich um Seiten-/ und Blockverwaltung, Puffermanagment, sowie Cashing. Für uns ist die relevante Fragestellung, ob unsere gesuchten Tupel im Hauptspeicher sind oder nicht.</p>
<section id="aufbau">
<h2><span class="section-number">2.1. </span>Aufbau<a class="headerlink" href="#aufbau" title="Permalink to this heading">#</a></h2>
<p>Es gibt folgende Dateneinheiten:</p>
<ul class="simple">
<li><p><strong>Attributwerte</strong> sind Bytelisten oder auch “Felder” fester oder variabler Länge</p></li>
<li><p><strong>Tupel</strong> sind Feldlisten fester oder variabler Länge, auch genannt „Datensätze“</p></li>
<li><p><strong>Physische Blöcke</strong> speichern Datensatzmengen/-listen</p></li>
<li><p><strong>Relationen</strong> sind Mengen von Blöcken und bilden eine „Datei“, dazu gehören auch Indexstrukturen, wenn z.B ein <code class="docutils literal notranslate"><span class="pre">PRIMARY</span> <span class="pre">KEY</span></code> vorhanden ist</p></li>
</ul>
</section>
<section id="felder-etc">
<h2><span class="section-number">2.2. </span>Felder etc.<a class="headerlink" href="#felder-etc" title="Permalink to this heading">#</a></h2>
<p>Die kleinste Dateneinheit sind Attributwerte, diese werden durch „Felder“ (fields) repräsentiert. Die Fragestellungen die in diesem Themenabschnitt thematisiert werden sind:</p>
<ul class="simple">
<li><p>Wie werden Datentypen als Felder repräsentiert?</p></li>
<li><p>Wie werden Tupel als Datensätze repräsentiert?</p></li>
<li><p>Wie werden Mengen von Datensätzen oder Tupeln in Blöcken repräsentiert?</p></li>
<li><p>Wie werden Relationen als Mengen von Blöcken repräsentiert?</p></li>
<li><p>Was passiert bei variablen Feld- oder Tupellängen?</p></li>
<li><p>Was passiert wenn ich einen Block nicht einheitlich in Tupel einteilen kann?</p></li>
<li><p>Was passiert wenn sich die Größe eines Datensatzes ändert, insbesondere vergrößert?</p></li>
</ul>
<a class="reference internal image-reference" href="../_images/Datenelemente-meme.png"><img alt="Datenelemente-meme" src="../_images/Datenelemente-meme.png" style="width: 500px;" /></a>
</section>
<section id="datentypen">
<h2><span class="section-number">2.3. </span>Datentypen<a class="headerlink" href="#datentypen" title="Permalink to this heading">#</a></h2>
<p>Alle Daten werden letzendlich als Bitsequenzen dargestellt bzw. werden alle Daten irgendwann als Bytesequenzen dargestellt. Aus GDBS sollten die folgenden Datentypen bekannt sein:</p>
<ul class="simple">
<li><p><strong>Integer</strong> belegen im Speicher 2 oder 4 Byte</p></li>
<li><p><strong>Float</strong> belegen im Speicher 4 oder 8 Byte</p></li>
<li><p><strong>Strings fester Länge(CHAR(n))</strong>  sind Felder die feste n Bytes zur Verfügung haben. Die fehlenden Byte-Werte werden mit Nullwerten (<span class="math notranslate nohighlight">\(\perp\)</span>) ge-padded. Beispiel:‚Katze‘ in CHAR(8) wäre also K a t z e <span class="math notranslate nohighlight">\(\perp\)</span><span class="math notranslate nohighlight">\(\perp\)</span><span class="math notranslate nohighlight">\(\perp\)</span></p></li>
<li><p><strong>Strings variabler Länge(VARCHAR(n))</strong> werden mit n+1 Byte reserviert. Die Länge kann maximal 255 Byte sein, daher gibt es oft VARCHAR(255). Hier gibt es einmal die Variante, dass das erste Byte die Länge speichert, die weiteren die Attributwerte speichern und die fehlenden Bytes ignoriert werden. Beispiel: 5 K a t z e. Eine andere Variante ist, dass die ersten Bytes die Attributwerte speichern und hintendran ein null-Wert gespeichert wird. Beispiel: K a t z e <span class="math notranslate nohighlight">\(\perp\)</span>.</p></li>
</ul>
<a class="reference internal image-reference" href="../_images/Strings-meme.png"><img alt="Strings-meme" src="../_images/Strings-meme.png" style="width: 500px;" /></a>
<section id="datum-bit-boolean">
<h3><span class="section-number">2.3.1. </span>Datum / Bit / Boolean<a class="headerlink" href="#datum-bit-boolean" title="Permalink to this heading">#</a></h3>
<p><strong>DATE, TIME</strong> werden i.d.R. als String fester Länge repräsentiert. Ein Problem ist jedoch, dass die Zeit mit Bruchteilen von Sekunden gespeichert werden kann (theoretisch beliebig genau). Eine Lösung ist die Speicherung als String fester Länge mit maximaler Genauigkeit. Eine weiter Lösung ist die Speicherung als String variabler Länge.</p>
<p><strong>BIT(n)</strong> ermöglichen das Arbeiten mit sehr detaillierten Bits, das ist praktisch wenn z.B Hashwerte gespeichert werden sollen. Es gelten 8 Bits pro Byte, falls n nicht durch 8 teilbar ist werden die letzten Bits ignoriert. Beispiel: BIT(12): 010111110011 wird zu 01011111, 00110000.</p>
<p><strong>BOOLEAN</strong> setzt sich aus 8 Bits zusammen: Entweder 00000001 und 00000000 oder 11111111 und 00000000.</p>
</section>
</section>
<section id="datensatze">
<h2><span class="section-number">2.4. </span>Datensätze<a class="headerlink" href="#datensatze" title="Permalink to this heading">#</a></h2>
<p>Mithilfe den thematisierten Datentypen, lassen sich nun Datensätze zusammenstellen.</p>
<section id="datensatze-fester-lange">
<h3><span class="section-number">2.4.1. </span>Datensätze fester Länge<a class="headerlink" href="#datensatze-fester-lange" title="Permalink to this heading">#</a></h3>
<p>Jeder Datensatz hat ein Schema bestehend aus Namen und Datentypen der Felder, sowie Offset im Datensatz (Anmerkung: JEDER Datensatz!–Realisiert i.d.R. als Pointer auf das Schema). Betrachten wir das untere Schema für eine Relation Schauspieler, auf relationaler Ebene gibt es vier Attribute, die als Zeichenketten gespeichert werden. Eine sehr einfache Variante um die Größen der Tupel zu berechnen ist immer das Maximum zu wählen.
<br><br>
Wir nehmen an alle haben eine feste Länge: 30 Byte + 256 Byte + 1 Byte + 10 Byte = 297 Byte. Somit ist jeder Datensatz gleich groß. Es ist möglich, dass ein Datensatz nicht komplett belegt ist, dann wird dieser Speicher trotzdem besetzt.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">Schauspieler</span> <span class="p">(</span>
    <span class="n">Name</span> <span class="n">CHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
    <span class="n">Adresse</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
    <span class="n">Geschlecht</span> <span class="n">CHAR</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">Geburtstag</span> <span class="n">DATE</span> <span class="p">);</span>
</pre></div>
</div>
</section>
<section id="versatz-zur-effizienz">
<h3><span class="section-number">2.4.2. </span>Versatz zur Effizienz<a class="headerlink" href="#versatz-zur-effizienz" title="Permalink to this heading">#</a></h3>
<p>In der Realität gibt es je nach System noch zusätzliche Anforderungen, wie z.B das Felder am besten bei Hauptspeicheradressen beginnen, die ein Vielfaches von 4 (bzw. 8) sind. Manchmal ist das sogar Pflicht. Dementsprechend müssen die Felder versetzt werden. Für die Festplatte ist das eigentlich egal, aber der eingelesene Datensatz landet auf einem Speicherplatz mit entsprechender Adresse: Vielfaches von 4 oder Vielfaches von 2n. Entsprechend versetzt sind die anderen Felder auch. Im unteren Beispielbild sehen wir zuerst das Feld ohne Versatz und dann mit einem Versatz von zwei.</p>
<a class="reference internal image-reference" href="../_images/Versatz-zur-Effizienz.png"><img alt="Versatz-zur-Effizienz" src="../_images/Versatz-zur-Effizienz.png" style="width: 500px;" /></a>
</section>
</section>
<section id="speicherung-der-metadaten">
<h2><span class="section-number">2.5. </span>Speicherung der Metadaten<a class="headerlink" href="#speicherung-der-metadaten" title="Permalink to this heading">#</a></h2>
<p>Die Metadaten eines Datensatzes, sind z.B. das Schema bzw. der Pointer auf ein Schema, die Länge des Datensatzes oder der Timestamp der letzten Änderung bzw. des letzten Lesens. Diese werden als Header vor dem Datensatz gespeichert. In dem Bild unten reichen 12 Bytes an Speicher für die Metadaten.</p>
<a class="reference internal image-reference" href="../_images/Speicherung_Metadaten.png"><img alt="Speicherung_Metadaten" src="../_images/Speicherung_Metadaten.png" style="width: 500px;" /></a>
<section id="aufteilung-in-blocke">
<h3><span class="section-number">2.5.1. </span>Aufteilung in Blöcke<a class="headerlink" href="#aufteilung-in-blocke" title="Permalink to this heading">#</a></h3>
<p>Um die Datensätze in Blöcke aufzuteilen kann ein Blockheader benutzt werden, dieser besteht aus:</p>
<ul class="simple">
<li><p>Links auf andere Blocks (z.B. Index)</p></li>
<li><p>Rolle dieses Blocks (im Index)</p></li>
<li><p>Relation der Tupel</p></li>
<li><p>Verzeichnis der offsets der Datensätze</p></li>
<li><p>Block ID (gleich)</p></li>
<li><p>Timestamp der letzten Änderung / des letzten Lesens</p></li>
</ul>
<p>Im einfachsten Fall sind alle Datensätze aus der gleichen Relation und haben alle eine feste Länge.
<br><br>
Beispiel: Ein Datensatz besteht aus 316 Byte und ein Block aus 4096 Byte,wobei 12 Bytes für je einen Header benötigt werden. Durch Division ergeben sich 12 Datensätze und 292 verlorene Bytes.</p>
<p><br><br>
Dies gilt nur für Datensätze mit fester Länge, die nicht über mehrere Blöcke verteilt sind.</p>
<a class="reference internal image-reference" href="../_images/Aufteilung_in_Blöcke.png"><img alt="Aufteilung_in_Blöcke" src="../_images/Aufteilung_in_Blöcke.png" style="width: 500px;" /></a>
</section>
</section>
<section id="adressierung">
<h2><span class="section-number">2.6. </span>Adressierung<a class="headerlink" href="#adressierung" title="Permalink to this heading">#</a></h2>
<p>Die Adressierung findet zuerst im Hauptspeicher statt, hier wird die Adresse zuerst angefragt, welche auf die Adresse auf der Festplatte abgebildet wird. Bei einem Block im Hauptspeicher befindet sich die Block-Adresse im virtuellen Adressraum, diese Adresse zeigt auf das erste Byte des Blocks. Wenn ein konkreter Datensatz gesucht wird gibt es zusätzlich noch eine Datensatz-Adresse, die zeigt auf das erste Byte des Datensatzes.
Der Block auf der Festplatte ist unser Speicherort. Der genaue Speicherort im ganzen System wird bestimmt durch die DBMS–Disk ID, Zylinder# (falls HDD vorhanden), Spur#, Sektor, usw… Unser gefundene Datensatz ist dann der Block und der Offset des ersten Bytes.</p>
<section id="adressraum-des-servers">
<h3><span class="section-number">2.6.1. </span>Adressraum des Servers<a class="headerlink" href="#adressraum-des-servers" title="Permalink to this heading">#</a></h3>
<p>Es gibt zwei Möglichkeiten um den Adressraum für die Spezifizierung des Blocks zu benutzen:</p>
<ul class="simple">
<li><p>Variante 1: Es werden nur <strong>physische Adressen</strong> im Hauptspeicher angegeben, bestehend aus folgenden Informationen:</p>
<ul>
<li><p>Rechner ID</p></li>
<li><p>Disk ID 8-16 Byte</p></li>
<li><p>Zylinder# 8-16 Byte</p></li>
<li><p>Spur# (bei mehr als einer Oberfläche)</p></li>
<li><p>Sektor#</p></li>
<li><p>(Offset innerhalb des Blocks)</p></li>
</ul>
</li>
<li><p>Variante 2: Es werden nur <strong>logische Adressen</strong> im Hauptspeicher angegeben, welche mit einer Mapping Table in eine physische Adresse übersetzt werden. Eine logische Adresse besteht aus einem beliebigen Byte String. Diese Abstraktion ermöglicht es auch auf Adressen zu verweisen, die nicht der physischen Architektur aus Variante 1 entsprechen.</p></li>
</ul>
</section>
<section id="logische-adressen">
<h3><span class="section-number">2.6.2. </span>Logische Adressen<a class="headerlink" href="#logische-adressen" title="Permalink to this heading">#</a></h3>
<p>Durch die Indirektion der logischen Adressen, ist die Umorganisation von Datenänderungen flexibler, da sie nur auf der Mappingtable stattfindet. Eine logische Adresse bleibt zudem gleich, unabhängig davon ob es sich um eine HDD oder SDD handelt. Eine Hybride Adressierung ist auch möglich, indem es eine physische Adresse für einen Block und eine logische Adresse für einen Datensatz in dem Block, z.B. ein Schlüsselwert, gibt.</p>
<a class="reference internal image-reference" href="../_images/Logische-Adressen.png"><img alt="Logische-Adressen" src="../_images/Logische-Adressen.png" style="width: 500px;" /></a>
</section>
<section id="hybride-adressierung">
<h3><span class="section-number">2.6.3. </span>Hybride Adressierung<a class="headerlink" href="#hybride-adressierung" title="Permalink to this heading">#</a></h3>
<p>Die Idee bei der hybriden Adressierung ist, dass wir zunächst durch physische Adressen zu einem Block gelangen. Der Block selbst speichert die Offsettable. Das Problem welches hierbei auftreten kann, ist dass Datensätze entfernt und hinzugefügt werden und es zu Fragmentierung kommt. Um dagegen zu wirken, werden Blöcke bei Datensätzen variabler Länge von hinten aufgefüllt. Da die Anzahl der Datensätze nicht fest ist, kann die Größe des Headers offen gelassen werden. Vorteile der Flexibilität (auch ohne Mapping Table) sind, dass innerhalb eines Blocks umorganisiert werden kann. Und ein Datensatz sogar Blöcke wechseln kann, folglich wird die neue Adresse in der Offsettable gespeichert.</p>
<a class="reference internal image-reference" href="../_images/Hybride-Adressierung.png"><img alt="Hybride-Adressierung" src="../_images/Hybride-Adressierung.png" style="width: 500px;" /></a>
</section>
<section id="columnar-storage">
<h3><span class="section-number">2.6.4. </span>Columnar Storage<a class="headerlink" href="#columnar-storage" title="Permalink to this heading">#</a></h3>
<p>Bei Columnar Storages ist die Idee, dass die Datensätze Spalten speichern statt Tupel, diese überspannen i.d.R mehrere Blöcke. Die Reihenfolge der Attributwerterte erlaubt die Tupelrekonstruktion, alternativ können Tupel-Id’s mitgespeichert werden.
<br><br>
Beispiel: Es sind 2 Datensätze (4,7,9) und (a,b,c) gegeben. In Columnar Storages würden die Attributwerte hintereinander gespeichert werden, also zuerst 4 dann a usw.
<br><br>
Ein Anwendungsfall ist OLAP (Online analyticalprocessing). Hierbei benötigen die meisten Anfragen alle oder viele Werte einer Spalte und die Tupelrekonstruktion ist aufwändig. Was die Komprimierung angeht, ist ein Vorteil die geringeren Disk- und I/O-Kosten. Ein Nachteil ist, dass Columnar Storages nur gut auf großen Datenmengen funktionieren, aber effizienter Tupelzugriff erlaubt nur blockweise Komprimierung. Letztlich ist die Indizierung auch schwieriger.</p>
</section>
</section>
<section id="variable-langen">
<h2><span class="section-number">2.7. </span>Variable Längen<a class="headerlink" href="#variable-langen" title="Permalink to this heading">#</a></h2>
<p>Daten können auch variabler Länge sein. Z.B gibt es Felder variabler Länge, wie VARCHAR(255), wo die Adresse selten vollkommen ausgeschöpft wird. Es kann auch Datensätze variabler Länge geben, wo bei einem sehr großen Schema nur wenige Attribute belegt sind und Datensätzen um Felder ergänzt werden. Ebenso kann es zu riesigen Feldern kommen, verursacht durch z.B GIFs, MPEG–Passen ,die nicht mehr auf einen Block passen.</p>
<section id="finden-von-feldern-variabler-lange">
<h3><span class="section-number">2.7.1. </span>Finden von Feldern variabler Länge<a class="headerlink" href="#finden-von-feldern-variabler-lange" title="Permalink to this heading">#</a></h3>
<p>Datensätze müssen Informationen speichern, damit jedes Feld im Datensatz aufzufinden ist, wie z.B ein Header. Um das Löschen und Hinzufügen von Tupeln zu vereinfachen, ist die Idee Felder fester Länge an den Anfang des Datensatzes abzulegen und folgend alle Tupel variabler Längen. Dadurch müssen die Tupel fester Länge nicht umorganierst werden, wenn Tupel variabler Länge verändert werden. Eine weitere Idee ist, dass der Header die Länge des Datensatzes speichert, somit weiß man wann der aktuelle Datensatz aufhört und ein anderer beginnt. Zusätzlich können Pointer (offsets) zu den Anfängen aller Felder variabler Länge gespeichert werden.
<br><br>
In der Abbildung unten, ist so ein Beispielblock dargestellt. Zuerst kommt der Header, welcher die Länge des Datensatzes speichert, danach ein Pointer der zu dem Attribut Adresse zeigt, welches eine variable Länge hat. Falls Adresse NULL ist, dann wird ein Null-Pointer gespeichert.</p>
<a class="reference internal image-reference" href="../_images/Finden-von-Fehlern.png"><img alt="Finden-von-Fehlern" src="../_images/Finden-von-Fehlern.png" style="width: 500px;" /></a>
</section>
<section id="datensatze-variabler-lange">
<h3><span class="section-number">2.7.2. </span>Datensätze variabler Länge<a class="headerlink" href="#datensatze-variabler-lange" title="Permalink to this heading">#</a></h3>
<p>Es kann sein, dass unbekannt ist welche und wie viele Felder der Datensatz haben wird. Z.B bei der Informationsintegration, wo es noch unbekannt ist welche Felder von Quellen hinzukommen. Die Idee ist sich die Felder zu merken, welche vorhanden sind oder nicht. Das sind sogenannte Taggedfields(getaggte Felder), es werden die Informationen Feldname (Attributname), Feldtyp, Feldlänge und Feldwert gespeichert. Das Speichern dieses Overheads ist ebenfalls nützlich bei dünn besetzten Datensätze, wo es tausende Attribute gibt, aber nur wenige haben Werte.</p>
<a class="reference internal image-reference" href="../_images/Datensätze-variabler-Länge.png"><img alt="Datensätze-variabler-Länge" src="../_images/Datensätze-variabler-Länge.png" style="width: 500px;" /></a>
</section>
<section id="anwendungsfalls-sparsedatabeispiel-linkedopen-data">
<h3><span class="section-number">2.7.3. </span>Anwendungsfalls SparseDataBeispiel: LinkedOpen Data<a class="headerlink" href="#anwendungsfalls-sparsedatabeispiel-linkedopen-data" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Linked-open-data.png"><img alt="Linked-open-data" src="../_images/Linked-open-data.png" style="width: 500px;" /></a>
<p>LinkedOpenData ist ein Phänomen, wo Daten offen und verfügbar dargestellt werden, s.d. Informationen semantisch aussagefähig sind. Insbesondere geht es darum Entitäten aus der realen Welt, Informationen und Webseiten so miteinander zu verlinken, s.d. semantische Informationen herleitbar sind. Es kann dazukommen, dass eine Entität über 2000 Attribute hat, weshalb getaggte Felder hier zum Einsatz kommen.</p>
</section>
<section id="microsoft-sql-server-sparse-columns">
<h3><span class="section-number">2.7.4. </span>Microsoft SQL Server: SPARSE columns<a class="headerlink" href="#microsoft-sql-server-sparse-columns" title="Permalink to this heading">#</a></h3>
<p>Ein Beispiel aus der realen Welt sind SPARSE columns auf Microsoft SQL Servern. Diese können wie im Code-Beispiel unten zu sehen ist, mit dem Keyword <code class="docutils literal notranslate"><span class="pre">SPARSE</span></code> deklariert werden. So wird dem System vermittelt, dass diese Spalten nicht immer gefüllt sind und es werden getaggte Felder für diese Spalten hinzugefügt. Hierfür gibt es eine Tabelle die angibt, bei wie viel Prozent an Null-Werten, sich das Speichern dieses Overheads kostentechnisch lohnen würde, für den jeweiligen Datentyp.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">DocumentStore</span><span class="p">(</span>
    <span class="n">DocIDintPRIMARY</span> <span class="n">KEY</span><span class="p">,</span>
    <span class="n">Title</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="n">NOT</span> <span class="n">NULL</span><span class="p">,</span>
    <span class="n">ProdSpecvarchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="n">SPARSE</span> <span class="n">NULL</span><span class="p">,</span>
    <span class="n">ProdLocsmallintSPARSE</span> <span class="n">NULL</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/SPARSE-columns.png"><img alt="SPARSE-columns" src="../_images/SPARSE-columns.png" style="width: 500px;" /></a>
</section>
<section id="zu-grosze-datensatze">
<h3><span class="section-number">2.7.5. </span>Zu große Datensätze<a class="headerlink" href="#zu-grosze-datensatze" title="Permalink to this heading">#</a></h3>
<p>Es kann Datensatzgrößen geben, die viel Platz verschwenden z.B. 51% eines Blocks ist nur belegt und die restlichen 49% werden verschwendet. Ebenso kann es übergroße Felder mit Mega-oder Gigabytegrößen geben. Beim Speichern solch großer Datensätze entstehen Datensatzfragmente, da ein Datensatz über mehr als einen Datensatz verteilt wird. Hierfür werden zusätzliche Informationen im Header gespeichert:</p>
<ul class="simple">
<li><p>Bit sagt ob Fragment oder nicht</p></li>
<li><p>Bits sagen ob erstes oder letztes Fragment</p></li>
<li><p>Zeiger zum nächsten und/oder vorigen Fragment–Doppelt verkettet Liste</p></li>
</ul>
<p>Beispiel für große Datensätze sind BLOBs = Binary Large Objects und CLOB = Character Large Objects. Diese beinhalten:</p>
<ul class="simple">
<li><p>Bilder/Grafiken: JPEG, GIF</p></li>
<li><p>Audio: mp3, …</p></li>
<li><p>Filme: MPEG, …
<br><br></p></li>
</ul>
<p>Wenn nun BLOBs oder CLOBs gelesen werden sollen, dann wird nicht mehr der ganze Datensatz aufeinmal gelesen, stattdessen wird ein Datenfragment gefunden und gelesen und je nach der Anfrage werden die restlichen Datenfragment folgend auch ermittelt und gelesen. Ein spannendes Thema ist die Navigation innerhalb des BLOBs (z.B. Sprung zur 45ten Minute bei einem Film auf einem Streamingdienst), da dies spezielle Indexstrukturen fordert.</p>
</section>
</section>
<section id="datensatzanderungen">
<h2><span class="section-number">2.8. </span>Datensatzänderungen<a class="headerlink" href="#datensatzanderungen" title="Permalink to this heading">#</a></h2>
<p><strong>Einfügen mit Platz</strong>
<br><br>
Wenn wir einen neuen Datensatz in unseren Speicher einfügen wollen und keine Ordnung verlangt wird, dann suchen wir nach einem freien Platz auf einem Block (oder suchen einen freien Block) und fügen diesen Datensatz dort ein. Falls eine Ordnung (z.B. nach Primärschlüssel) verlangt ist, wird nach dem entsprechenden Block gesucht. Falls dort Platz frei ist, werden die Datensätze auf dem Block bewegt, so dass der neue Datensatz an der entsprechenden Stelle eingefügt werden kann.</p>
<a class="reference internal image-reference" href="../_images/Einfügen-mit-Platz.png"><img alt="Einfügen-mit-Platz" src="../_images/Einfügen-mit-Platz.png" style="width: 500px;" /></a>
<p><strong>Einfügen ohne Platz</strong>
<br><br>
Wenn in dem eigentlichen Block kein Platz mehr ist, um einen weiteren Datensatz einzufügen gibt es zwei Varianten:</p>
<ul class="simple">
<li><p>Variante 1: Es wird ein Block in der Nähe gesucht, meist ist das der vorherige oder nächste Block. Dann wird der erste oder letze Datensatz zu dem jeweils neuen Block bewegt und eine Weiterleitungsadresse wird im alten Block hinterlegt(„Nachsendeauftrag“). Gegebenenfalls müssen die Datensätze in beiden Blöcken noch hin und her bewegt werden. Zuletzt wir der neue Datensatz an der richtigen Stelle im neu gesuchten Block eingefügt.
<br><br></p></li>
<li><p>Variante 2:  Es wird ein designierter Overflow Block erzeugt, dessen Adresse im Header des ursprünglichen Blocks gespeichert wird. Der neue Datensatz wird dann in den neu erzeugten Overflow Block eingefügt. Ein Overflow Block kann selbst wiederum einen Overflow Block haben.</p></li>
</ul>
<p><strong>Löschen</strong></p>
<p>Der zu löschende Datensatz wird gelöscht. Danach werden die Datensätze im Block verschoben, um den enstandenen freien Platz zu konsolidieren. Eine andere Möglichkeit ist, dass im Header eine Liste mit freien Plätzen verwaltet wird oder eine verkette Liste der freien Plätze. Je nach dem ob es zu dem Block noch Overflow Blöcke gibt, müssen diese reorganisiert werden. An der gelöschten Stelle befindet sich häufig ein sogenannter Grabstein(tombstones). Auch nachdem Löschen kann es noch einen Pointer auf den zu löschenden Datensatz geben. Es gibt drei Varianten einen Grabstein zu hinterlassen:</p>
<ul class="simple">
<li><p>Null-Pointer im Header</p></li>
<li><p>Null-Pointer in der Mappingtable</p></li>
<li><p>Grabstein am Anfang der Datensätze</p></li>
</ul>
<br>
Diese Grabsteine müssen (im Allgemeinen) ewig erhalten bleiben, bis die Datenbank re-organisiert wird.<a class="reference internal image-reference" href="../_images/Löschen-meme.png"><img alt="Löschen-meme" src="../_images/Löschen-meme.png" style="width: 500px;" /></a>
<br>
<p><strong>Update</strong></p>
<p>Bei fester Länge gibt es kein Problem beim Aktualisieren eines Datensatzes. Der alte Wert wird entfernt und der neue eingefügt. Bei variabler Länge treten dieselben Probleme auf wie beim Einfügen. Falls der neue Wert zu groß ist wird z.B ein Overflow Block erzeugt usw.</p>
<!-- <img src="pictures/update.png" alt="update" width="500" style="background-color: white;"/> --></section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "LUH-DBS/GDBS_Script",
            ref: "main/",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./02"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="../01/speicherung.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">1. </span>Speicherung</p>
      </div>
    </a>
    <a class="right-next"
       href="../03/indizes.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">3. </span>Indizes</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#aufbau">2.1. Aufbau</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#felder-etc">2.2. Felder etc.</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#datentypen">2.3. Datentypen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#datum-bit-boolean">2.3.1. Datum / Bit / Boolean</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#datensatze">2.4. Datensätze</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#datensatze-fester-lange">2.4.1. Datensätze fester Länge</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#versatz-zur-effizienz">2.4.2. Versatz zur Effizienz</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#speicherung-der-metadaten">2.5. Speicherung der Metadaten</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#aufteilung-in-blocke">2.5.1. Aufteilung in Blöcke</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#adressierung">2.6. Adressierung</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#adressraum-des-servers">2.6.1. Adressraum des Servers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#logische-adressen">2.6.2. Logische Adressen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hybride-adressierung">2.6.3. Hybride Adressierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#columnar-storage">2.6.4. Columnar Storage</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#variable-langen">2.7. Variable Längen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#finden-von-feldern-variabler-lange">2.7.1. Finden von Feldern variabler Länge</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#datensatze-variabler-lange">2.7.2. Datensätze variabler Länge</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anwendungsfalls-sparsedatabeispiel-linkedopen-data">2.7.3. Anwendungsfalls SparseDataBeispiel: LinkedOpen Data</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#microsoft-sql-server-sparse-columns">2.7.4. Microsoft SQL Server: SPARSE columns</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zu-grosze-datensatze">2.7.5. Zu große Datensätze</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#datensatzanderungen">2.8. Datensatzänderungen</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Prof. Dr. Ziawasch Abedjan
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>