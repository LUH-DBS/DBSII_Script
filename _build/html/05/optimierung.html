

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>5. Optimierung &#8212; Online-Skript Datenbanksysteme II</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '05/optimierung';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. Large Scale Data Management" href="../06/large-scale-data-management.html" />
    <link rel="prev" title="4. Anfrageausführung" href="../04/anfrageausfuehrung.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/DBIS_Kurzlogo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/DBIS_Kurzlogo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Datenbanksysteme II
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../01/speicherung.html">1. Speicherung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02/repraesentation.html">2. Repräsentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03/indizes.html">3. Indizes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04/anfrageausfuehrung.html">4. Anfrageausführung</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">5. Optimierung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06/large-scale-data-management.html">6. Large Scale Data Management</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/LUH-DBS/GDBS_Script" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/LUH-DBS/GDBS_Script/issues/new?title=Issue%20on%20page%20%2F05/optimierung.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/05/optimierung.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Optimierung</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wiederholung-anfragebearbeitung">5.1. Wiederholung: Anfragebearbeitung</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grundproblem">5.1.1. Grundproblem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ablauf-der-anfragebearbeitung">5.1.2. Ablauf der Anfragebearbeitung</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">5.2. Ablauf der Anfragebearbeitung</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing">5.2.1. Parsing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algebraische-transformationsregeln">5.3. Algebraische Transformationsregeln</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kommutativitat-und-assoziativitat">5.3.1. Kommutativität und Assoziativität</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#weitere-regeln">5.3.2. Weitere Regeln</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#logische-anfrageplane">5.4. Logische Anfragepläne</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zwei-schritte">5.4.1. Zwei Schritte</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-anfragebearbeitung">5.4.2. Beispiel - Anfragebearbeitung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ubergang-zum-physischen-anfrageplan">5.4.3. Übergang zum Physischen Anfrageplan</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenmodell">5.5. Kostenmodell</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenbasierte-optimierung-wiederholung">5.5.1. Kostenbasierte Optimierung (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problemgrosze-suchraum-wiederholung">5.5.2. Problemgröße (Suchraum) (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenmodell-wiederholung">5.5.3. Kostenmodell (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#statistiken-wiederholung">5.5.4. Statistiken (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kosten-von-operationen">5.5.5. Kosten von Operationen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-projektion">5.5.6. Kostenschätzung - Projektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-selektion">5.5.7. Kostenschätzung - Selektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#selektivitat-schatzen">5.5.8. Selektivität schätzen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-fur-skew-zipf-verteilung">5.5.9. Beispiel für Skew: Zipf-Verteilung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">5.5.10. Kostenschätzung - Selektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-selektion-mit-disjunktion">5.5.11. Kostenschätzung - Selektion mit Disjunktion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join">5.5.12. Kostenschätzung - Join</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join-beispiel">5.5.13. Kostenschätzung - Join Beispiel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join-mehrere-attribute">5.5.14. Kostenschätzung Join - Mehrere Attribute</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-mehrfacher-join">5.5.15. Kostenschätzung - Mehrfacher Join</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-weitere-operationen">5.5.16. Kostenschätzung - Weitere Operationen</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#histogramme">5.6. Histogramme</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">5.6.1. Ablauf der Anfragebearbeitung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schatzung-der-statistiken">5.6.2. Schätzung der Statistiken</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schatzung-der-statistiken-histogramme">5.6.3. Schätzung der Statistiken - Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#verteilungen-korpergewicht">5.6.4. Verteilungen - Körpergewicht</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equi-width-histogramme">5.6.5. Equi-Width Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equi-height-histogramme">5.6.6. Equi-Height-Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#histogramme-zur-schatzung-fur-joins">5.6.7. Histogramme zur Schätzung für Joins</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#erhebung-von-statistiken">5.6.8. Erhebung von Statistiken</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#joinreihenfolge">5.7. Joinreihenfolge</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#enumeration-physischer-anfrageplane">5.7.1. Enumeration Physischer Anfragepläne</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#heuristische-auswahl">5.7.2. Heuristische Auswahl</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#branch-and-bound">5.7.3. Branch and Bound</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hill-climbing">5.7.4. Hill-Climbing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung-selinger-style-optimierung">5.7.5. Dynamische Programmierung &amp; Selinger-style Optimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#richard-bellman">5.7.6. Richard Bellman</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-fur-knapsack-problem">5.7.7. DP für Knapsack Problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-knapsack-mit-dp">5.7.8. Beispiel: Knapsack mit DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-traveling-salesman-problem">5.7.9. DP: Traveling Salesman Problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamic-programming-heldkarp-algorithmus">5.7.10. Dynamic Programming (Held–Karp Algorithmus)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung">5.7.11. Dynamische Programmierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anwendung-fur-left-deep-baume">5.7.12. Anwendung für Left-Deep Bäume</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anfrageplanung">5.7.13. Anfrageplanung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anfragebearbeitung-optimierung">5.7.14. Anfragebearbeitung – Optimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung-optimierung-im-system-r">5.7.15. Dynamische Programmierung: Optimierung im System-R</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bottom-up-anfrageplangenerierung">5.7.16. Bottom-up Anfrageplangenerierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">5.7.17. Dynamische Programmierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-grundidee-fur-anfrageoptimierung">5.7.18. DP – Grundidee für Anfrageoptimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-beispiel">5.7.19. DP – Beispiel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-interesting-orders-interessante-sortierung">5.7.20. DP - interesting orders (Interessante Sortierung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-algorithmus">5.7.21. DP – Algorithmus</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#physische-anfrageplane">5.8. Physische Anfragepläne</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#letzte-schritte">5.8.1. Letzte Schritte</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wahl-der-selektionsmethode">5.8.2. Wahl der Selektionsmethode</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenvergleich-der-selektionsmethoden">5.8.3. Kostenvergleich der Selektionsmethoden</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenvergleich-der-selektionsmethoden-beispiel">5.8.4. Kostenvergleich der Selektionsmethoden – Beispiel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wahl-der-join-methode">5.8.5. Wahl der Join-Methode</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pipelining-vs-blocking">5.8.6. Pipelining vs. Blocking</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="optimierung">
<h1><span class="section-number">5. </span>Optimierung<a class="headerlink" href="#optimierung" title="Permalink to this heading">#</a></h1>
<p>In diesem Kapitel wird die Optimierung auf logischer Ebene betrachtet. Es geht mehr um die Daten selbst als um die Speicherabbildung.</p>
<section id="wiederholung-anfragebearbeitung">
<h2><span class="section-number">5.1. </span>Wiederholung: Anfragebearbeitung<a class="headerlink" href="#wiederholung-anfragebearbeitung" title="Permalink to this heading">#</a></h2>
<p>Zunächst eine kleine Wiederholung zur Anfragebearbeitung in Bezug auf das Grundproblem und den Ablauf.</p>
<section id="grundproblem">
<h3><span class="section-number">5.1.1. </span>Grundproblem<a class="headerlink" href="#grundproblem" title="Permalink to this heading">#</a></h3>
<p>Anfragen in SQL und der Relationalen Algebra sind deklarativ. Solche Anfragen müssen in ausführbare (prozedurale) Form transformiert werden. Also in echte ausführbare Programme. Die Ziele dabei sind ein “QEP” (prozeduraler Query Execution Plan) und Effizienz. Eine Anfrage soll schnell und wenige Ressourcen verbrauchen (CPU, I/O, RAM, Bandbreite).</p>
</section>
<section id="ablauf-der-anfragebearbeitung">
<h3><span class="section-number">5.1.2. </span>Ablauf der Anfragebearbeitung<a class="headerlink" href="#ablauf-der-anfragebearbeitung" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Ablauf-Anfragebearbeitung.png"><img alt="Ablauf-Anfragebearbeitung" src="../_images/Ablauf-Anfragebearbeitung.png" style="width: 250px;" /></a>
<ol class="arabic simple">
<li><p><strong>Parsing</strong></br>
Als erstes wird die Anfrage geparsed und überprüft, ob diese syntaktisch korrekt ist. Danach werden die Elemente semantisch überprüft und ein Parsebaum erstellt.</p></li>
<li><p><strong>Wahl des logischen Anfrageplans</strong></br>
Im zweiten Schritt werden exponentiell viele Bäume mit logischen Operatoren erstellt. Darunter wird der optimale Plan ausgewählt, indem vorher logisch, regelbasiert und kostenbasiert optimiert wird.</p></li>
<li><p><strong>Wahl des physischen Anfrageplans</strong></br>
Anhand des logischen Plans wird ein ausführbares Programm mit physischen Operatoren erstellt. Das Programm enthält Algorithmen und Scan-Operatoren. Der optimale Plan wird physisch optimiert und dann ausgewählt. Zum Schluss wird der ausgewählte Anfrageplan ausgeführt.</p></li>
</ol>
<a class="reference internal image-reference" href="../_images/Meme-Finish-SQL-Query.png"><img alt="Meme-Finish-SQL-Query" src="../_images/Meme-Finish-SQL-Query.png" style="width: 250px;" /></a>
</section>
</section>
<section id="id1">
<h2><span class="section-number">5.2. </span>Ablauf der Anfragebearbeitung<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h2>
<p>Die einzelnen Schritte bei der Anfragebearbeitung werden nun genauer betrachtet.</p>
<section id="parsing">
<h3><span class="section-number">5.2.1. </span>Parsing<a class="headerlink" href="#parsing" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Ablauf-Anfragebearbeitung_2.png"><img alt="Ablauf-Anfragebearbeitung_2" src="../_images/Ablauf-Anfragebearbeitung_2.png" style="width: 500px;" /></a>
<p>Beginnend beim Parsing wird auf <strong>syntaktische Korrektheit</strong> überprüft. Dafür wird eine Grammatik für einen Teil von SQL betrachtet. (SFW steht für SelectFromWhere): </br></p>
<ul class="simple">
<li><p>Anfragen</p>
<ul>
<li><p>&lt;Anfrage&gt; :: = &lt;SFW&gt;</p></li>
<li><p>&lt;Anfrage&gt; :: = ( &lt;SFW&gt; )</p></li>
<li><p>die Mengenoperatoren fehlen</p></li>
</ul>
</li>
<li><p>SFWs</p>
<ul>
<li><p>&lt;SFW&gt; ::= SELECT &lt;SelListe&gt; FROM &lt;FromListe&gt; WHERE &lt;Bedingung&gt;</p></li>
<li><p>die Gruppierung, Sortierung etc. fehlen</p></li>
</ul>
</li>
<li><p>Listen</p>
<ul>
<li><p>&lt;SelListe&gt; ::= &lt;Attribut&gt;, &lt;SelListe&gt;</p></li>
<li><p>&lt;SelListe&gt; ::= &lt;Attribut&gt;</p></li>
<li><p>&lt;FromListe&gt; ::= &lt;Relation&gt;, &lt;FromListe&gt;</p></li>
<li><p>&lt;FromListe&gt; ::= &lt;Relation&gt;</p></li>
</ul>
</li>
<li><p>Bedingungen</p>
<ul>
<li><p>&lt;Bedingung&gt; ::= &lt;Bedingung&gt; AND &lt;Bedingung&gt;</p></li>
<li><p>&lt;Bedingung&gt; ::= &lt;Tupel&gt; IN &lt;Anfrage&gt;</p></li>
<li><p>&lt;Bedingung&gt; ::= &lt;Attribut&gt; = &lt;Attribut&gt;</p></li>
<li><p>&lt;Bedingung&gt; ::= &lt;Attribut&gt; LIKE &lt;Muster&gt;</p></li>
</ul>
</li>
<li><p>&lt;Tupel&gt;, &lt;Attribut&gt;, &lt;Relation&gt; und &lt;Muster&gt; sind nicht durch eine grammatische Regel definiert</p></li>
</ul>
<p>Die vollständige Grammatik kann man zum Beispiel <a class="reference external" href="http://docs.openlinksw.com/virtuoso/GRAMMAR.html">hier</a> finden.
</br></br></p>
<p>Anschließend wird während der Übersetzung die <strong>semantische Korrektheit</strong> überprüft. Beantwortet werden dabei generell Fragen wie:</p>
<ul class="simple">
<li><p>Existieren die Relationen und Sichten der FROM Klausel?</p></li>
<li><p>Existieren die Attribute in den genannten Relationen? Sind sie eindeutig?</p></li>
<li><p>Sind die Typen für die Vergleiche korrekt?</p></li>
<li><p>Ist die Aggregation korrekt?</p></li>
</ul>
</section>
</section>
<section id="algebraische-transformationsregeln">
<h2><span class="section-number">5.3. </span>Algebraische Transformationsregeln<a class="headerlink" href="#algebraische-transformationsregeln" title="Permalink to this heading">#</a></h2>
<a class="reference internal image-reference" href="../_images/Ablauf-Anfragebearbeitung_3.png"><img alt="Ablauf-Anfragebearbeitung_3" src="../_images/Ablauf-Anfragebearbeitung_3.png" style="width: 500px;" /></a>
<p>Das Ziel ist es aus dem Parsebaum einen logischen Anfrageplan zu erstellen. Ohne die Semantik der Anfrage zu ändern, soll sie in eine interne Darstellung verwandelt werden. Um die Anfrage effizienter auszuführen, sollen insbesondere kleine Zwischenergebnisse erzielt werden. </br>
Am Ende sollen es äquivalente Ausdrücke sein. Zwei Ausdrücke der relationalen Algebra heißen äquivalent, falls sie die gleichen Operanden (=Relationen) nutzt und für jede mögliche Instanz der Datenbank stets die gleiche Antwortrelation ausgibt.</p>
<section id="kommutativitat-und-assoziativitat">
<h3><span class="section-number">5.3.1. </span>Kommutativität und Assoziativität<a class="headerlink" href="#kommutativitat-und-assoziativitat" title="Permalink to this heading">#</a></h3>
<p>Die Gesetze gelten jeweils für Mengen und Multimengen. Die verwendeten Ausdrücke können in beide Richtungen verwendet werden.</p>
<ul class="simple">
<li><p>? ist kommutativ und assoziativ</p>
<ul>
<li><p>R ? S = S ? R</p></li>
<li><p>(R ? S) ? T = R ? (S ? T)</p></li>
</ul>
</li>
<li><p>∪ ist kommutativ und assoziativ</p>
<ul>
<li><p>R ∪ S = S ∪ R</p></li>
<li><p>(R ∪ S) ∪ T = R ∪ (S ∪ T)</p></li>
</ul>
</li>
<li><p>∩ ist kommutativ und assoziativ</p>
<ul>
<li><p>R ∩ S = S ∩ R</p></li>
<li><p>(R ∩ S) ∩ T = R ∩ (S ∩ T)</p></li>
</ul>
</li>
<li><p>⨝ ist kommutativ und assoziativ</p>
<ul>
<li><p>R ⨝ S = S ⨝ R</p></li>
<li><p>(R ⨝ S) ⨝ T = R ⨝ (S ⨝ T)</p></li>
</ul>
</li>
</ul>
</section>
<section id="weitere-regeln">
<h3><span class="section-number">5.3.2. </span>Weitere Regeln<a class="headerlink" href="#weitere-regeln" title="Permalink to this heading">#</a></h3>
<p>Für Selektionen und Projektionen gelten die folgenden Regeln:</p>
<ul class="simple">
<li><p>Selektion σ</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(σ_{c1 AND c2}(R) = σ_{c1}(σ_{c2}(R))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(σ_{c1 OR c2}(R) = σ_{c1}(R) ∪ σ_{c2}(R)\)</span></p>
<ul>
<li><p>nicht bei Multimengen</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\( σ_{c1}(σ_{c2}(R)) = σ_{c2}(σ_{c1}(R))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\( σ_{c}(R Φ S) ≡ (σ_{c}(R)) Φ (σ_{c}(S))\)</span></p>
<ul>
<li><p>Φ ∈ {∪, ∩, -, ⨝}</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\( σ_{c}(R Φ S) ≡ (σ_{c}(R)) Φ S\)</span></p>
<ul>
<li><p>Φ ∈ {∪, ∩, -, ⨝}</p></li>
<li><p>Falls sich c nur auf die Attribute in R bezieht.
</br></p></li>
</ul>
</li>
</ul>
</li>
<li><p>Projektion π</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(π_{L}(R ⨝ S) = π_{L}(π_{M}(R) ⨝ π_{N}(S))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(π_{L}(R ⨝_{C} S) = π_{L}(π_{M}(R) ⨝_{C} π_{N}(S))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(π_{L}(R x S) = π_{L}(π_{M}(R) x π_{N}(S))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(π_{L}(σ_{c}(R)) = π_{L}(σ_{c}(π_{M}(R))\)</span></p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="logische-anfrageplane">
<h2><span class="section-number">5.4. </span>Logische Anfragepläne<a class="headerlink" href="#logische-anfrageplane" title="Permalink to this heading">#</a></h2>
<a class="reference internal image-reference" href="../_images/Ablauf-Anfragebearbeitung_4.png"><img alt="Ablauf-Anfragebearbeitung_4" src="../_images/Ablauf-Anfragebearbeitung_4.png" style="width: 500px;" /></a>
<p>Um nun zu einem logischen Anfrageplan zu gelangen, benötigt es zwei Schritte.</p>
<section id="zwei-schritte">
<h3><span class="section-number">5.4.1. </span>Zwei Schritte<a class="headerlink" href="#zwei-schritte" title="Permalink to this heading">#</a></h3>
<p><strong>Schritt 1</strong></br>
In Schritt 1 wird der Parsebaum in einen Ausdruck der relationalen Algebra übersetzt und dann wieder als Baum dargestellt. Unter anderem werden auch Subanfragen aufgelöst. Letzteres wird aber nicht in dieser Vorlesung weiter thematisiert.
</br></p>
<p><strong>Schritt 2</strong></br>
Der Baum wird im zweitem Schritt gemäß der Transformationsregeln umgeformt. Man kann auch “Vor-Optimierungen” mittels Heuristiken durchführen. Dazu zählt unter Anderem:</p>
<ul class="simple">
<li><p>das Pushen von Selektionen,</p></li>
<li><p>das Einbauen und Pushen von Projektionen,</p></li>
<li><p>das Zusammenfügen von Selektion und Kreuzprodukt zu einem Join,</p></li>
<li><p>die Gruppierung von Vereinigungen und Joins,</p></li>
<li><p>und eventuell das Verschieben und Einbauen von Duplikateliminierungen.</p></li>
</ul>
</section>
<section id="beispiel-anfragebearbeitung">
<h3><span class="section-number">5.4.2. </span>Beispiel - Anfragebearbeitung<a class="headerlink" href="#beispiel-anfragebearbeitung" title="Permalink to this heading">#</a></h3>
<p>In diesem Beispiel ist ein Ausdruck der relationalen Algebra in einem Parsebaum dargestellt. Die zugehörige SQL-Anfrage wäre</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">Nachname</span>
<span class="n">FROM</span> <span class="n">mitarbeiter</span> <span class="n">m</span><span class="p">,</span> <span class="n">projekte</span> <span class="n">p</span>
<span class="n">WHERE</span> <span class="n">p</span><span class="o">.</span><span class="n">Budget</span> <span class="o">&lt;</span> <span class="mi">40000</span>
<span class="n">AND</span> <span class="n">m</span><span class="o">.</span><span class="n">p_id</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">p_id</span><span class="p">;</span>
</pre></div>
</div>
<p>Man sollte damit beginnen das Kreuzprodukt mit der Selektion zu einem Join zu kombinieren.</p>
<a class="reference internal image-reference" href="../_images/Anfragebearbeitung-Beispiel-1.png"><img alt="Anfragebearbeitung-Beispiel-1" src="../_images/Anfragebearbeitung-Beispiel-1.png" style="width: 500px;" /></a>
<p>Als nächstes sollte man versuchen die andere Selektion weiter nach unten zu pushen (Push-Down). Ziel ist es mit möglichst wenigen Tupeln in jedem Teilschritt zu arbeiten. Die gegebene Selektion kann direkt vor die Projekt-Relation geschoben werden.</p>
<a class="reference internal image-reference" href="../_images/Anfragebearbeitung-Beispiel-2.png"><img alt="Anfragebearbeitung-Beispiel-2" src="../_images/Anfragebearbeitung-Beispiel-2.png" style="width: 500px;" /></a>
<p>In einem weiterem Schritt können die benötigten Attribute aus den Ausgangsrelationen direkt rausprojiziert werden.</p>
<a class="reference internal image-reference" href="../_images/Anfragebearbeitung-Beispiel-3.png"><img alt="Anfragebearbeitung-Beispiel-3" src="../_images/Anfragebearbeitung-Beispiel-3.png" style="width: 500px;" /></a>
</section>
<section id="ubergang-zum-physischen-anfrageplan">
<h3><span class="section-number">5.4.3. </span>Übergang zum Physischen Anfrageplan<a class="headerlink" href="#ubergang-zum-physischen-anfrageplan" title="Permalink to this heading">#</a></h3>
<p>Hierbei gibt es diverse Freiheitsgrade:</p>
<ol class="arabic simple">
<li><p>Die Reihenfolge und Gruppierung von assoziativen und kommutativen Operatoren können vertauscht werden. Das ist zum Beispiel der Fall bei Joins, Vereinigungen und Schnittmengen.</p></li>
<li><p>Für jeden Operator kann ein Algorithmus gewählt werden. Damit sind die aus dem vorherigen Kapitel kennengelernten Hash-basierten, Sort-basierten oder auch One-Pass Algorithmen gemeint.</p></li>
<li><p>Es können zusätzliche Operatoren (Sort und Projektion), die im logischen Plan selbst nicht auftauchen, hinzugefügt werden.</p></li>
<li><p>Außerdem kann der Modus des Datentransports zwischen den Operatoren gewählt werden. Modi wären eine temporäre Tabelle oder eine Pipeline mit Iterator.</p></li>
</ol>
<p>Dafür braucht man in jedem Fall zunächst eine Kostenabschätzung. Man möchte herausfinden, wann es sinnvoll ist, welche Operationsreihenfolgen zu nutzen und wie viel ein Plan gesamt kostet.</p>
</section>
</section>
<section id="kostenmodell">
<h2><span class="section-number">5.5. </span>Kostenmodell<a class="headerlink" href="#kostenmodell" title="Permalink to this heading">#</a></h2>
<p>Beim Kostenmodell werden die Kardinalitäten abgschätzt. Man möchte wissen wie viele Tupel es gibt und wie viele unterschiedliche Werte in den einzelnen Attributen einer Relation vorhanden sind.</p>
<a class="reference internal image-reference" href="../_images/Ablauf-Anfragebearbeitung_5.png"><img alt="Ablauf-Anfragebearbeitung_5" src="../_images/Ablauf-Anfragebearbeitung_5.png" style="width: 500px;" /></a>
<section id="kostenbasierte-optimierung-wiederholung">
<h3><span class="section-number">5.5.1. </span>Kostenbasierte Optimierung (Wiederholung)<a class="headerlink" href="#kostenbasierte-optimierung-wiederholung" title="Permalink to this heading">#</a></h3>
<p>Konzeptionell werden alle denkbaren Ausführungspläne generiert. Die Kosten für jeden Plan werden anhand eines Kostenmodells bewertet. Dazu werden Statistiken und Histogramme hinzugezogen. Die Parameter werden anhand der Rechnerarchitektur, auf der die Datenbank aufgesetzt ist, kalibriert. Die Optimierung ist abhängig vom verfügbaren Speicher. Dann wird anhand des Aufwands-Kostenmodell geschaut was und wie optimiert werden soll. Entweder Durchsatz maximierend oder nicht Antwortzeit-minimierend. Entsprechend wird der günstigste Plan ausgeführt. Wichtig ist, dass nicht zu lange optimiert wird, da sich sonst der ganze Aufwand nicht lohnen könnte.</p>
<a class="reference internal image-reference" href="../_images/TimeCost-Meme.png"><img alt="TimeCost-Meme" src="../_images/TimeCost-Meme.png" style="width: 350px;" /></a>
</section>
<section id="problemgrosze-suchraum-wiederholung">
<h3><span class="section-number">5.5.2. </span>Problemgröße (Suchraum) (Wiederholung)<a class="headerlink" href="#problemgrosze-suchraum-wiederholung" title="Permalink to this heading">#</a></h3>
<p>Wie zuvor erwähnt, werden konzeptionell alle denkbaren Ausführungspläne generiert. Man berechnet nun die Bushy-Pläne mit n Tabellen. Bushy-Plan bedeutet, dass der Baum immer balanciert ist.</p>
<div class="math notranslate nohighlight">
\[\frac{(2(n-1))!}{(n-1)!}\]</div>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>n</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(2^n\)</span></p></th>
<th class="head"><p>n!</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(\frac{(2(n-1))!}{(n-1)!}\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>2</strong></p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p><strong>5</strong></p></td>
<td><p>32</p></td>
<td><p>120</p></td>
<td><p>1680</p></td>
</tr>
<tr class="row-even"><td><p><strong>10</strong></p></td>
<td><p>1024</p></td>
<td><p>3628800</p></td>
<td><p>1,76 * 10^10</p></td>
</tr>
<tr class="row-odd"><td><p><strong>20</strong></p></td>
<td><p>1048576</p></td>
<td><p>2,4 * 10^18</p></td>
<td><p>4,3 * 10^27</p></td>
</tr>
</tbody>
</table>
</br>
<p>Die Anzahl der Deep-Pläne mit n Tabellen ist n!. Die Plankosten unterscheiden sich um viele Größenordnungen. Das Optimierungsproblem ist NP-hard (NP-Schwer).
</br></p>
<p>Folie: Prof. Alfons Kemper, TU München.</p>
</section>
<section id="kostenmodell-wiederholung">
<h3><span class="section-number">5.5.3. </span>Kostenmodell (Wiederholung)<a class="headerlink" href="#kostenmodell-wiederholung" title="Permalink to this heading">#</a></h3>
<p>Gegeben ist ein algebraischer Ausdruck z.B. ein Anfrageplan. Das Kostenmodell schätzt die Ausführungskosten für diesen Ausdruck. Im Kostenmodell werden Punkte wie die Indexinformationen, die Ballungs-Informationen (Clustering on disk), die DB-Kardinalitäten und die Attributverteilungen berücksichtigt.</p>
<a class="reference internal image-reference" href="../_images/Kostenmodell.png"><img alt="Kostenmodell" src="../_images/Kostenmodell.png" style="width: 500px;" /></a>
</section>
<section id="statistiken-wiederholung">
<h3><span class="section-number">5.5.4. </span>Statistiken (Wiederholung)<a class="headerlink" href="#statistiken-wiederholung" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Statistiken-Histogram-of-arrivals.png"><img alt="Statistiken-Histogram-of-arrivals" src="../_images/Statistiken-Histogram-of-arrivals.png" style="width: 500px;" /></a>
<p>Man kann unterschiedliche Statistiken für das Kostenmodell nutzen. Für die Statistiken kann man verschiedene Werte berücksichtigen. Zu jeder Basisrelation gibt es die Anzahl der tupel und die Größe der einzelnen Tupel.
Zu (jedem) Attribut gibt es den minimalen und maximalen Wert, eine Werteverteilung (Histogramm) und die Anzahl der distinct Werte. Zum System sind die Speichergröße, die Bandbreite, I/O- und CPU-Zeiten angegeben.
</br></p>
<p>Das eigentliche Problem ist das Erstellen und Updaten der Statistiken. Wenn man eine Datenbank hat, die sich sehr schnell immer wieder verändert, müssen die Statistiken dazu auch häufig neu erstellt werden (<code class="docutils literal notranslate"><span class="pre">runstats()</span></code>). Dies kostet weitere Ressourcen. Man sollte sich überlegen wie genau man die Statistiken haben möchte und dementsprechend viel Zeit in das Optimieren investieren. Aus diesem Grund initiiert man meist nur explizit/manuell die Erstellung und das Update der Statistiken.</p>
</section>
<section id="kosten-von-operationen">
<h3><span class="section-number">5.5.5. </span>Kosten von Operationen<a class="headerlink" href="#kosten-von-operationen" title="Permalink to this heading">#</a></h3>
<p>Das wesentliche Kostenmerkmal bei Operationen ist die Anzahl der Tupel im Input. Insbesondere ist die Frage, ob die Relation in den Hauptspeicher passt und man darauf Operationen wie Selektion, Projektion, Sortierung und Join ausführen kann.  </br>
Der Output ist immer der Input des nächsten Operators. Deshalb schätzt ein Kostenmodell unter anderem für jede Operation die Anzahl der Ausgabetupel.
Zum Schätzen wird die „Selektivität“ in Bezug auf Inputgröße herangezogen. Sie gibt an wie viele Eingabetupel ein Operator herausselektiert und wie viele Ausgabetupel dann erwartet werden können. Es wird auch „Selektivitätsfaktor“ (selectivity factor, sf) genannt.</p>
<ul class="simple">
<li><p>#Ausgabetupel = #Eingabetupel x Selektivität</p></li>
</ul>
</section>
<section id="kostenschatzung-projektion">
<h3><span class="section-number">5.5.6. </span>Kostenschätzung - Projektion<a class="headerlink" href="#kostenschatzung-projektion" title="Permalink to this heading">#</a></h3>
<p>Die Größe des Zwischenergebnisses kann bei der Projektion exakt ausgerechnet werden. </br>
</br>
<strong>Beispiele</strong></br>
Gegeben ist eine Relation R(A integer(4), B integer(4), C varchar(100)) mit einem Tupelheader von 12 Byte.</p>
<p><strong>1:</strong></br>
Somit ergeben sich insgesamt 120 Byte pro Tupel. Ein Block besteht aus 1024 Byte mit einem 24 Byte Header. Also sind es 8 Tupel pro Block. </br>
Bei einer Relation R mit 10000 Tupeln: T® = 10000, kommt man bei 8 Tupeln pro Block, auf insgesamt 1250 Blöcke, die benötigt werden: B® = 1250.
</br></p>
<p><strong>2:</strong></br>
<span class="math notranslate nohighlight">\(Q_{1} = \pi_{A+B,C}(R)\)</span></br>
Daraus ergeben sich 116 Byte pro Tupel. Bei 8 Tupeln pro Block hat man wieder 1250 Blöcke pro Tupel: B(<span class="math notranslate nohighlight">\(Q_{1}\)</span>) = 1250.
</br></p>
<p><strong>3:</strong></br>
<span class="math notranslate nohighlight">\(Q_{2} = \pi_{A,B}(R)\)</span> </br>
Man erhält 20 Byte pro Tupel. Insgesamt also 50 Tupel pro block und B(<span class="math notranslate nohighlight">\(Q_{2}\)</span>) = 200.</p>
</section>
<section id="kostenschatzung-selektion">
<h3><span class="section-number">5.5.7. </span>Kostenschätzung - Selektion<a class="headerlink" href="#kostenschatzung-selektion" title="Permalink to this heading">#</a></h3>
<p>Im Gegensatz zur Projektion bleibt zwar die Tupelgröße, aber die Anzahl der Tupel sinkt bei der Selektion. </br>
<span class="math notranslate nohighlight">\(Q=\sigma_{A=c}(R)\)</span> </br>
Die Formel zur Selektion zeigt einen Vergleich zwischen dem Attribut A und der Konstante c. Basierend auf Annahmen kann man die Anzahl der Ausgabetupel berechnen. Die erste Annahme ist, dass die Werte gleich verteilt sind. Die zweite, dass c einer dieser Werte ist. Zur Berechnung nutzt man die Formel <span class="math notranslate nohighlight">\(T(Q) = T(R) / V(R,A)\)</span>. <span class="math notranslate nohighlight">\(V(R,A)\)</span> ist die Anzahl der distinct Werte in Spalte A. D.h. der Selektivitäsfaktor ist <span class="math notranslate nohighlight">\(1 / V(R,A)\)</span>. Bessere Abschätzungen sind mittels Histogrammen möglich.<br />
<br></p>
<p><span class="math notranslate nohighlight">\(Q=\sigma_{A&lt;c}(R)\)</span></br>
Der Vergleich der Selektion A &lt; c macht eine Bereichsabfrage. Es gibt Möglichkeiten dies genau abzuschätzen. Einfachheitshalber nutzen wir hier eine erste Abschätzung: <span class="math notranslate nohighlight">\(T(Q) = T(R) / 2\)</span>. Typischer ist die Formel <span class="math notranslate nohighlight">\(T(Q) = T(R) / 3\)</span>.
<br></p>
<p><span class="math notranslate nohighlight">\(Q=\sigma_{A \neq c}(R)\)</span></br>
Man möchte in der Selektion nicht die Attribute haben, die der Konstante c entsprechen. Eine erste einfache Abschätzung wäre es davon auszugehen, dass man (fast) alles zurückbekommt: <span class="math notranslate nohighlight">\(T(Q) = T(R)\)</span>. Etwas genauer ist stattdessen die Formel <span class="math notranslate nohighlight">\(T(Q) = T(R) * (V(R,A) - 1) / V(R,A)\)</span>. Sie ist sehr ähnlich zu der ersten Formel vom Vergleich (<span class="math notranslate nohighlight">\(Q=\sigma_{A=c}(R)\)</span>). Der Unterschied besteht darin, dass sie nicht alle Tupel zurückgibt, die gleich der Konstante sind, sondern genau das Gegenteil: Alle Tupel, die ungleich der Konstante sind.
</br></p>
<p>Hat man Konjunktionen bei mehreren Selektionsbedingungen, multipliziert man die Selektivitätsfaktoren. Die Annahme dafür ist die Unabhängigkeit der Bedingungen.</p>
</section>
<section id="selektivitat-schatzen">
<h3><span class="section-number">5.5.8. </span>Selektivität schätzen<a class="headerlink" href="#selektivitat-schatzen" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Selektivität-schätzen.png"><img alt="Selektivität-schätzen" src="../_images/Selektivität-schätzen.png" style="width: 500px;" /></a>
<p>Das Bild ist aus dem Werk für das System R von Selinger et al. aus dem Jahre 1979. Man sieht die Möglichkeiten zur Einschätzung der Selektivität. Beim Schätzen wird fast immer eine Gleichverteilung angenommen.</p>
</section>
<section id="beispiel-fur-skew-zipf-verteilung">
<h3><span class="section-number">5.5.9. </span>Beispiel für Skew: Zipf-Verteilung<a class="headerlink" href="#beispiel-fur-skew-zipf-verteilung" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/George-Kingsley-Zipf.png"><img alt="George-Kingsley-Zipf" src="../_images/George-Kingsley-Zipf.png" style="width: 200px;" /></a>
<p>Eine sehr bekannte Verteilung ist die Zipf-Verteilung von George Kingsley Zipf (1902 - 1950). Sie modelliert Worthäufigkeiten in den Texten einer Sprache. Die Wörter werden nach ihren Häufigkeiten sortiert. Die Häufigkeit des häufigsten Wortes sei dabei h. Wenn alles sortiert ist kann man beispielsweise für den i-ten Wert die Häufigkeit berechnen. Der i-te Wert tauch dann genau <span class="math notranslate nohighlight">\(h / i^{1/2}\)</span> mal auf. Der zughörige Graph sieht wie folgt aus:</p>
<a class="reference internal image-reference" href="../_images/Beispiel-Skew-Graph.png"><img alt="Beispiel-Skew-Graph" src="../_images/Beispiel-Skew-Graph.png" style="width: 500px;" /></a>
<p>Wenige Werte kommen sehr häufig vor, die vielen anderen Werte kommen hingegen sehr selten vor. Anhand der Verteilung könnte man nun probieren die Kardinalitätsabschätzung anzupassen. Dennoch sollte es eher gelassen werden. Die durchschnittliche Antwortkardinalität bleibt weiter <span class="math notranslate nohighlight">\(T(R) / V(R,A)\)</span>. Durch die Annahme, dass Konstanten in Selektionsbedingungen gleichverteilt gewählt werden, kann es bei der Zipf-Verteilung der Konstanten zu einer Unterschätzung kommen.</p>
<a class="reference internal image-reference" href="../_images/Zipfs-law.png"><img alt="Zipfs-law" src="../_images/Zipfs-law.png" style="width: 500px;" /></a>
<p>A plot of the rank versus frequency for the first 10 million words in 30 Wikipedias (dumps from October 2015) in a <a class="reference external" href="https://en.wikipedia.org/wiki/Log%E2%80%93log_plot">log-log</a> scale.</p>
<p>Das Beispiel zeigt das Prinzip von Zipf’s law. Außerdem ist es unabhängig von der jeweils gewählten Sprache.</p>
</section>
<section id="id2">
<h3><span class="section-number">5.5.10. </span>Kostenschätzung - Selektion<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h3>
<p><strong>Beispiele</strong></br>
Gegeben ist eine Relation R mit T® = 10000 und V(R,A) = 50.
</br></p>
<p><strong>1:</strong></br>
<span class="math notranslate nohighlight">\(Q = \sigma_{A=10 AND B&lt;20}(R)\)</span></br>
Die Ausgabetupel werden geschätzt mit <span class="math notranslate nohighlight">\(T(Q) = 10000 * 1/50 * 1/3 = 67\)</span>.
</br></p>
<p><strong>2:</strong></br>
<span class="math notranslate nohighlight">\(Q = \sigma_{A=10 AND A&gt;20}(R)\)</span></br>
Im ersten Moment würde man die Ausgabetupel mit <span class="math notranslate nohighlight">\(T(Q) = 10000 * 1/50 * 1/3 = 67\)</span> schätzen. Bei genauerer Betrachtung fällt auf, dass die Bedingung so nicht möglich ist. Das Attribut kann gleichzeitig nicht genau 10 und über 20 sein. Besser ist die Abschätzung T(Q) = 0. Ein Optimierer sollte solche Fälle erkennen.
</br></p>
</section>
<section id="kostenschatzung-selektion-mit-disjunktion">
<h3><span class="section-number">5.5.11. </span>Kostenschätzung - Selektion mit Disjunktion<a class="headerlink" href="#kostenschatzung-selektion-mit-disjunktion" title="Permalink to this heading">#</a></h3>
<p><span class="math notranslate nohighlight">\(Q = \sigma_{C1 OR C2}(R2)\)</span></br></p>
<p><strong>Idee 1</strong></br>
Bilde die Summe der Ergebniskardinalitäten mit der Annahme, dass kein Tupel beide Bedingungen erfüllt. Dennoch kann es dazu führen, dass das Ergebnis größer als die Ursprungsrelation ist: T(Q) &gt; T®.
</br></p>
<p><strong>Idee 2</strong></br>
Daher könnte man nun das Minimum unter der Anzahl der Tupel in R und der Summe der Ergebniskardinalitäten wählen: <span class="math notranslate nohighlight">\(min[T(R), Summe der Ergebniskardinalitäten]\)</span>. Es ist keine perfekte Lösung, aber ein erster Versuch sich näher an das richtige Ergebnis heranzutasten.
</br></p>
<p><strong>Idee 3</strong></br>
Nutze die Wahrscheinlichkeitstheorie mit der Annahme, dass C1 und C2 unabhängig voneinander sind. Sei</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T(R) = n\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{C1}(R)) = m_{1}\)</span> und</p></li>
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{C2}(R)) = m_{2}\)</span>.</p></li>
</ul>
<p>Daraus ergibt sich
<span class="math notranslate nohighlight">\(T(Q) = n(1-(1-\frac{m_{1}}{n})(1-\frac{m_{2}}{n}))\)</span>. Wobei der Term <span class="math notranslate nohighlight">\((1-\frac{m_{1}}{n})\)</span> den Anteil der Tupel, die nicht C1 entsprechen, beschreibt. Der zweite ähnliche Term <span class="math notranslate nohighlight">\((1-\frac{m_{2}}{n})\)</span> beschreibt den Anteil der Tupel, die nicht C2 entsprechen.
</br></p>
<p><strong>Beispiel</strong></br>
Sei die Selektion <span class="math notranslate nohighlight">\(Q = \sigma_{A=10 OR B&lt;20}(R)\)</span> gegeben. Bilde zunächst wie in Idee 1 beschrieben von separat die Ergebniskardinalitäten beider Bedingungen und addiere beide anschließend:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{A=10}(R)) = T(R) / V(R,A) = 10000 / 50 = 200\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{B&lt;20}(R)) = T(R) / 3 = 3333\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T(Q) = 200 + 3333 = 3533\)</span></p></li>
</ul>
<p>Eine bessere Schätzung wäre mit Idee 3 möglich:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T(R) = 10000\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{A=10}(R)) = 200\)</span> und</p></li>
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{B&lt;20}(R)) = 3333\)</span>.</p></li>
</ul>
<p>Setzt man diese Werte in die Formel der Wahrscheinlichkeitstheorie ein, erhält man als Ergebnis 3466:
<span class="math notranslate nohighlight">\(T(Q) = n(1-(1-\frac{m_{1}}{n})(1-\frac{m_{2}}{n})) = 10000 (1-(1-\frac{200}{10000})(1-\frac{3333}{10000}))\)</span></p>
<p>Die Formel kann deutlich vereinfacht werden <span class="math notranslate nohighlight">\(m_{1} + m_{2} - n (\frac{m_{1}}{n} * \frac{m_{2}}{n})\)</span></br>
<span class="math notranslate nohighlight">\(= 200 + 3333 - 10000(\frac{200}{10000} * \frac{3333}{10000})\)</span></br>
<span class="math notranslate nohighlight">\(= 3533 - (\frac{666600}{10000})\)</span></br>
<span class="math notranslate nohighlight">\(= 3533 - 67\)</span></br>
<span class="math notranslate nohighlight">\(= 3466\)</span></br></p>
</section>
<section id="kostenschatzung-join">
<h3><span class="section-number">5.5.12. </span>Kostenschätzung - Join<a class="headerlink" href="#kostenschatzung-join" title="Permalink to this heading">#</a></h3>
<p>In dieser Vorlesung betrachten wir nur den Natural Join. Das Verfahren beim Equijoin wäre analog dazu. Ein Thetajoin mit “&lt;”, “&gt;” usw. wird wie zuvor geschätzt. Zum Beispiel mit <span class="math notranslate nohighlight">\(1/3 T(R) * 1/3 T(S)\)</span>.</br></p>
<p><span class="math notranslate nohighlight">\(R(X,Y) \Join S(Y,Z)\)</span></br>
Vereinfachend wird hier angenommen, dass wir nur über ein Attribut Y joinen. Ein Problem ist die Beziehung zwischen R.Y und S.Y. Man weiß nicht wie viele Elemente aus R.Y auch in S.Y auftauchen. Theoretisch kann man sagen, dass es disjunkte Mengen und nichts gleich ist. Damit würde man bei einem Join 0 Elemente erhalten: <span class="math notranslate nohighlight">\(T(R \Join S) = 0\)</span>. Eine weitere Möglichkeit wäre eine Fremdschlüsselbeziehung (mit einem Schlüssel in S). Dann wäre das Resultat die Menge an Tupeln in R: <span class="math notranslate nohighlight">\(T(R \Join S) = T(R)\)</span>. Es gibt noch eine dritte Möglichkeit, wenn man davon ausgeht, dass fast alles gleiche Werte sind: <span class="math notranslate nohighlight">\(T(R \Join S) = T(R) * T(S)\)</span>. </br></p>
<p>Es müssen also wieder ein paar Annahmen getroffen werden.
Die erste Annahme sagt, dass die Werte eines Attributs, das in mehreren Relationen auftaucht, vom Beginn einer Liste gewählt wird. Das ist das sogenannte <strong>Containment of Value Sets</strong>. Falls also die Distinct-Werte der Relation R kleiner gleich den Distinct-Werten der anderen Relation S sind (<span class="math notranslate nohighlight">\(V(R,Y) \leq V(S,Y)\)</span>), dann taucht jeder Y-Wert in R auch in S auf. </br>
Die zweite Annahme besagt, dass die Anzahl der Distinct-Werte eines nicht-Joinattributs erhalten bleiben: <span class="math notranslate nohighlight">\(V(R \Join S, X) = V(R,X)\)</span>. Auch <strong>Preservation of Value Sets</strong> genannt. Es ist realistisch, wenn von Gleichverteilung ausgegangen wird. Insbesondere, wenn die Relation S eine Fremdschlüsselbeziehung hat. Der einzige Fall bei dem es nicht mehr korrekt sein könnte ist, wenn das X ein Schlüssel ist.</br>
</br></p>
<p>Sei <span class="math notranslate nohighlight">\(V(R,Y) \leq V(S,Y)\)</span>, dann gilt:</p>
<ul class="simple">
<li><p>jedes Tupel aus R hat eine <span class="math notranslate nohighlight">\(1 / V(S,Y)\)</span> Chance, mit einem gegebenen S-Tupel zu joinen.</p></li>
<li><p>(da T(S) S-Tupel): Ein Tupel aus R hat <span class="math notranslate nohighlight">\(T(S) * 1/V(S,Y)\)</span> Joinpartner in S.</p></li>
<li><p>(da T® R-Tupel): <span class="math notranslate nohighlight">\(T(R \Join S) = T(R) * T(S) / V(S,Y)\)</span>.
</br></p></li>
</ul>
<p>Falls <span class="math notranslate nohighlight">\(V(R,Y) \leq V(S,Y)\)</span>, dann gilt <span class="math notranslate nohighlight">\(T(R \Join S) = T(R) * T(S) / V(R,Y)\)</span>. </br>
</br></p>
<p>Allgemein gilt: <span class="math notranslate nohighlight">\(T(R \Join S) = T(R) * T(S) / max[V(R,Y), V(S,Y)]\)</span>.
</br></p>
</section>
<section id="kostenschatzung-join-beispiel">
<h3><span class="section-number">5.5.13. </span>Kostenschätzung - Join Beispiel<a class="headerlink" href="#kostenschatzung-join-beispiel" title="Permalink to this heading">#</a></h3>
<p>Seien Joins zwischen drei Relationen gegeben:</br>
<span class="math notranslate nohighlight">\(R(A,B) \Join S(B,C) \Join U(C,D)\)</span>.</br></p>
<p>Die Anzahl der Tupel der Relationen ist wie folgt:</p>
<ul class="simple">
<li><p>T® = 1.000</p></li>
<li><p>T(S) = 2.000</p></li>
<li><p>T(U) = 5.000</p></li>
</ul>
<p>Die Selektionsfaktoren sind</p>
<ul class="simple">
<li><p>V(R,B) = 20</p></li>
<li><p>V(S,B)= 50</p></li>
<li><p>V(S,C) = 100</p></li>
<li><p>V(U,C)=500</p></li>
</ul>
<p>Die Joins werden in der Reihenfolge <span class="math notranslate nohighlight">\((R \Join S) \Join U\)</span> betrachtet.
Daher kann man zunächst <span class="math notranslate nohighlight">\(T(R \Join S)\)</span> berechnen:
<span class="math notranslate nohighlight">\(T(R \Join S) = T(R) * T(S) / max[V(R,B),V(S,B)] = 1.000 * 2.000 / 50 = 40.000\)</span> </br>
Aber man kann die Relation U auch direkt hinzujoin/heranmultiplizieren: <span class="math notranslate nohighlight">\(T(R \Join S \Join U) = T(R \Join S) * T(U) / max[V(R \Join S, C), V(U, C)] = 40.000 * 5.000 / max[100, 500] = 400.000\)</span> </br></p>
<p>Zur Probe können Sie <span class="math notranslate nohighlight">\(T(R \Join (S \Join U))\)</span> nachrechnen.</p>
<details>
  <summary><strong>Lösung</strong></summary>
    Auch wenn man zuerst die anderen Relationen miteinander joint, erhält man wieder das Selbe Ergebnis: 400000. 
</details>
</section>
<section id="kostenschatzung-join-mehrere-attribute">
<h3><span class="section-number">5.5.14. </span>Kostenschätzung Join - Mehrere Attribute<a class="headerlink" href="#kostenschatzung-join-mehrere-attribute" title="Permalink to this heading">#</a></h3>
<p><span class="math notranslate nohighlight">\(R(X,Y) \Join S(Y,Z)\)</span></br>
Y enthält nun mehr als ein Attribut. Die Schreibweise ist hier: <span class="math notranslate nohighlight">\(R(X,Y1,Y2) \Join S(Y1,Y2,Z)\)</span></br>
Die Ergebniskardinalität von <span class="math notranslate nohighlight">\(R \Join S\)</span> entspricht dem Produkt der Kardinalitäten von R und S, dividiert durch das Produkt des jeweils größeren von V(R,Y) und V(S,Y) für jedes Join-Attribut Y: <span class="math notranslate nohighlight">\(T(R \Join S) = T(R) * T(S) / ( max[V(R,Y1),V(S,Y1)] * max[V(R,Y2),V(S,Y2)] )\)</span></p>
</section>
<section id="kostenschatzung-mehrfacher-join">
<h3><span class="section-number">5.5.15. </span>Kostenschätzung - Mehrfacher Join<a class="headerlink" href="#kostenschatzung-mehrfacher-join" title="Permalink to this heading">#</a></h3>
<p>Im allgemeinen Fall <span class="math notranslate nohighlight">\( S = R_{1} \Join R_{2} \Join ... \Join R_{n} \)</span> wird in diesem Fall über das selbe Attribut A gejoint. Notiert wird es mit <span class="math notranslate nohighlight">\(V(R_{i}, A) = v_{i}\)</span>. Das Attribut A erscheint in k Relationen. Es gilt <span class="math notranslate nohighlight">\(v_{1} \leq v_{2} \leq ... \leq v_{k}\)</span> mit <span class="math notranslate nohighlight">\( k \leq n \)</span>. Die Frage ist nun wie die Kardinalität des Ergebnisses berechnet wird.</br>
Dazu eine kleine Gedankenhilfe:
Gegeben ist ein Tupel aus jeder der k Relationen. Gesucht wird die Wahrscheinlichkeit, dass alle im A-Wert übereinstimmen. Es gibt wieder das Containment of Value Sets: Jeder A-Wert von Tupeln aus <span class="math notranslate nohighlight">\(R_{1}\)</span> taucht in den anderen Relationen auf. Ein Tupel aus <span class="math notranslate nohighlight">\(R_{i}\)</span> hat eine Wahrscheinlichkeit von <span class="math notranslate nohighlight">\(1/v_{i}\)</span> mit einem gegebenen Tupel aus <span class="math notranslate nohighlight">\(R_{1}\)</span> übereinzustimmen. Zusammen ergibt sich <span class="math notranslate nohighlight">\(1 / v_{2} * v_{3} * … * v_{k}\)</span>. Die Wahrscheinlichkeiten der einzelnen Tupel der verschiedenen Relationen müssen nur multipliziert werden. </br>
Für das Gesamtvorgehen ist der Ausgangspunkt also das Produkt aller Kardinalitäten zu bilden. Betrachtet man die Selektivität muss für jedes Attribut, das mehr als einmal auftaucht, durch das Produkt aller <span class="math notranslate nohighlight">\(v_{i}\)</span> bis auf das kleinste (<span class="math notranslate nohighlight">\(v_{1}\)</span> dividiert werden.</p>
<p><strong>Beispiel</strong></br></p>
<ul class="simple">
<li><p>Die Anfrage ist <span class="math notranslate nohighlight">\(R(A,B,C) \Join S(B,C,D) \Join U(B,E)\)</span>.</p></li>
<li><p>Die Kardinalitäten sind</p>
<ul>
<li><p>T® = 1000;</p></li>
<li><p>T(S) = 2000;</p></li>
<li><p>T(U) = 5000.</p></li>
</ul>
</li>
<li><p>Die DISTINCT Werte sind</p>
<ul>
<li><p>V(R,B): 20;</p></li>
<li><p>V(R,C): 200;</p></li>
<li><p>V(S,B): 50;</p></li>
<li><p>V(S,C): 100;</p></li>
<li><p>V(U,B): 200.</p></li>
</ul>
</li>
</ul>
<p>Vorgehen: Zunächst zählt man alle (Tupel-)Kombinationen der Relationen auf: <span class="math notranslate nohighlight">\(1000 * 2000 * 5000 = 10.000.000.000\)</span>. Dann werden die Wahrscheinlichkeiten für gemeinsame Attribute multipliziert. Die Relation B hat drei- und die Relation C hat zweimal gemeinsame Attribute. Für B ergibt sich: <span class="math notranslate nohighlight">\(1/50 * 1/200\)</span>. Für C wiederrum: <span class="math notranslate nohighlight">\(1/200\)</span>.
Zusammen ergibt sich: </br>
<span class="math notranslate nohighlight">\(10.000.000.000 / (50 * 200 * 200)\)</span></br>
<span class="math notranslate nohighlight">\(= 10.000.000.000 / 2.000.000\)</span></br>
<span class="math notranslate nohighlight">\(= 5.000\)</span></p>
</section>
<section id="kostenschatzung-weitere-operationen">
<h3><span class="section-number">5.5.16. </span>Kostenschätzung - Weitere Operationen<a class="headerlink" href="#kostenschatzung-weitere-operationen" title="Permalink to this heading">#</a></h3>
<p><strong>Vereinigung</strong> <span class="math notranslate nohighlight">\((R \cup S)\)</span></br>
Bei einer Multimenge bildet man die Summe der Inputs. Bei einer normalen Menge wählt man eine Vereinigung der Relationen, die größer ist als die größte Relation und kleiner als die Summe der Tupel aller Relationen: <span class="math notranslate nohighlight">\(max[T(R), T(S)] \leq T(R \cup S) \leq T(R) + T(S)\)</span>. Z.B könnte man auch den Durchschnitt von Maximum und Summe berechnen: <span class="math notranslate nohighlight">\(AVG[T(R) + T(S), max[T(R), T(S)]]\)</span>.</p>
<p><strong>Schnittmenge</strong> <span class="math notranslate nohighlight">\((R \cap S)\)</span></br>
Die Schnittmenge der Relationen muss größer als 0, aber noch kleiner als die kleinste Relation sein: <span class="math notranslate nohighlight">\(0 ≤ T(R \cap S) \leq min[T(R), T(S)]\)</span>. Die erste Idee zur Vereinfachung ist es die kleinste Relation zu halbieren: <span class="math notranslate nohighlight">\(min[T(R), T(S)]/2\)</span>. Die zweite Idee ist es, es als Join aufzufassen. Dabei kommt es häufig zu einer extremen Unterschätzung.</p>
<p><strong>Differenz</strong></br>
Die Differenz muss kleiner als die anfängliche Relation und größer als das Maximum von 0 und der Differenz der Anzahl der Tupel der Relationen: <span class="math notranslate nohighlight">\(max[0,T(R) - T(S)] \leq T(R - S) \leq T(R)\)</span>. Hier wählt man z.B. eine Mitte mit <span class="math notranslate nohighlight">\(max[0, T(R) – T(S)/2]\)</span>.</p>
<p><strong>Duplikateliminierung</strong></br>
<span class="math notranslate nohighlight">\(T(\delta(R)) = V(R, [A_{1}, ..., A_{n}])\)</span>. Die Anzahl der Tupel muss kleiner gleich der Anzahl der Ausgangsrelation sein. Es darf natürlich nicht weniger als ein Tupel vorhanden sein: <span class="math notranslate nohighlight">\(1 \leq T(\delta(R)) \leq T(R)\)</span>. Man kann auch die Distinct-Werte miteinander multiplizieren <span class="math notranslate nohighlight">\(T(\delta(R)) \leq \prod_{i} V(R, A_{i})\)</span>. Z.B. kann dafür auch <span class="math notranslate nohighlight">\(T(\delta(R)) = min[T(R)/2, \prod_{i} V(R, A_{i})]\)</span> genutzt werden.</p>
<p><strong>Gruppierung und Aggregation</strong></br>
Die Anzahl der Tupel muss auf jeden Fall kleiner gleich der Anzahl der Tupel in der Ausgangsrelation sein, aber dennoch muss es mindestens ein Tupel geben: <span class="math notranslate nohighlight">\(1 \leq T(\gamma_{L}(R)) \leq T(R)\)</span>.
Falls nur ein Gruppierungsattribut gibt, gilt: <span class="math notranslate nohighlight">\(T(\gamma_{L}(R)) \leq V(R,L)\)</span>
Falls mehrere es mehrere gibt muss multipliziert werden: <span class="math notranslate nohighlight">\(T(\gamma_{L}(R)) \leq \prod_{i} V(R, L_{i})\)</span>. Man kann auch die Formel <span class="math notranslate nohighlight">\(T(\gamma_{L}(R)) = min[T(R)/10, \prod_{i} V(R, A_{i})]\)</span> nutzen.</p>
</section>
</section>
<section id="histogramme">
<h2><span class="section-number">5.6. </span>Histogramme<a class="headerlink" href="#histogramme" title="Permalink to this heading">#</a></h2>
<p>Für genauere Berechnung werden Histogramme verwendet. Nun ist nicht mehr nur die Kardinalität bekannt, sondern auch die Verteilung der Werte.</p>
<section id="id3">
<h3><span class="section-number">5.6.1. </span>Ablauf der Anfragebearbeitung<a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h3>
<p>Im Ablauf befinden sich die Histogramme im Bereich der Kostenschätzung.</p>
<a class="reference internal image-reference" href="../_images/Ablauf-Anfragebearbeitung_6.png"><img alt="Ablauf-Anfragebearbeitung_6" src="../_images/Ablauf-Anfragebearbeitung_6.png" style="width: 500px;" /></a>
</section>
<section id="schatzung-der-statistiken">
<h3><span class="section-number">5.6.2. </span>Schätzung der Statistiken<a class="headerlink" href="#schatzung-der-statistiken" title="Permalink to this heading">#</a></h3>
<p>Statistiken sind notwendig, um die Größe von Zwischenergebnissen zu berechnen, insbesondere T® und V(R,A). Statistiken werden auf Befehl des Administrators eingeholt. Zum Beispiel wird T® mittels Scan von R. V(R,A) kann mittels einer der vorigen Algorithmen ermittelt werden. Das ist ähnlich wie bei der Gruppierung auch separat für jedes Attribut. B® wird gezählt, falls R nicht clustered gespeichert ist. Falls es geclustered ist, dann wird <span class="math notranslate nohighlight">\((T(R) / Tupel pro Block)\)</span> berechnet.</p>
</section>
<section id="schatzung-der-statistiken-histogramme">
<h3><span class="section-number">5.6.3. </span>Schätzung der Statistiken - Histogramme<a class="headerlink" href="#schatzung-der-statistiken-histogramme" title="Permalink to this heading">#</a></h3>
<p>Histogramme stellen speichereffizient Werteverteilungen dar. Die Idee ist es, Gruppen von Werten (zusammenhängende Wertebereiche) in Buckets zusammenzufassen. Varianten von Buckets wären Equal-width und Equal-height. In den Buckets geht Genauigkeit verloren, weswegen man zusätzlich Häufigkeiten für die häufigsten Werte speichern kann.
Pro Bucket wird die durchschnittliche Anzahl der Tupel pro Einzel-Wert gespeichert. D.h. man nimmt innerhalb des Buckets eine Gleichverteilung an.
<strong>Vorteile</strong> sind geringere Schätzfehler, da Verteilungsannahmen nur in kleineren Bereichen getroffen werden. Außerdem ist der Speicherverbrauch durch das Zusammenfassen in Gruppen geringer.
Bei <strong>Design und Wartung</strong> bleiben ein paar Fragen offen:</p>
<ul class="simple">
<li><p>Wie werden Bucketgrenzen bestimmt?</p></li>
<li><p>Was wird pro Bucket gespeichert?</p></li>
<li><p>Wie werden Histogramme aktuell gehalten?</p></li>
</ul>
</section>
<section id="verteilungen-korpergewicht">
<h3><span class="section-number">5.6.4. </span>Verteilungen - Körpergewicht<a class="headerlink" href="#verteilungen-korpergewicht" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Verteilungen-Körpergewicht.png"><img alt="Verteilungen-Körpergewicht" src="../_images/Verteilungen-Körpergewicht.png" style="width: 500px;" /></a>
<p>In der Grafik sind Verteilungen zum Körpergewicht dargestellt. Die <strong>Normalverteilung</strong> hat einen Wertebereich von 120-40=80. Ihr Mittelwert beträgt 80 und die Standardabweichung (stddev) ist 12. Es betrifft 100.000 Personen.
Bei der <strong>Gleichverteilung</strong> wird angenommen, dass jede Gewichtsklasse mit der gleichen Häufigkeit auftaucht. Somit sind es 100.000/80=1250 Personen für jede Gewichtsklasse. Die Gleichverteilung ist somit in fast jedem Bereich fehleranfällig.
Die einzigen genauen Punkte sind die Schnittpunkte der beiden Verteilungen. An den anderen Stellen kommt es zu groben Fehlschätzungen.</p>
</section>
<section id="equi-width-histogramme">
<h3><span class="section-number">5.6.5. </span>Equi-Width Histogramme<a class="headerlink" href="#equi-width-histogramme" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Equi-Width-Histogramme.png"><img alt="Equi-Width-Histogramme" src="../_images/Equi-Width-Histogramme.png" style="width: 500px;" /></a>
<p>Etwas besser ist es, eine feste Anzahl an Buckets mit jeweils gleicher Breite zu erstellen. Der Vorteil ist, dass die Grenzen nicht mitgespeichert werden müssen. Der Startpunkt und die Breite genügen. Es wird eine Gleichverteilung in jedem Bucket angenommen. Ein Histogramm kann mittels eines Scans von R berechnet werden. Quellen für Schätzfehler sind zu wenige Buckets und, wenn sich die Werteverteilung innerhalb der Buckets stark unterscheidet.</p>
</section>
<section id="equi-height-histogramme">
<h3><span class="section-number">5.6.6. </span>Equi-Height-Histogramme<a class="headerlink" href="#equi-height-histogramme" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Equi-Height-Histogramme.png"><img alt="Equi-Height-Histogramme" src="../_images/Equi-Height-Histogramme.png" style="width: 500px;" /></a>
<p>Eine andere Variation ist das Equi-Height Histogramm. Auch bekannt als Equi-depth-Histogramme bzw. Perzentile. Nun probiert man, dass innerhalb eines Buckets sehr ähnliche Werte gespeichert werden. Es gibt eine feste Anzahl an Buckets. Zum Beispiel 10 Stück für 10%, 20%, usw. Die Bucketgrenzen werden so gewählt, dass jedes Bucket ungefähr die gleiche Anzahl an Tupeln enthält. Hier sind es 10.000 Personen pro Bucket. Die Bucketgrenzen müssen gespeichert werden. Die Berechnung der Histogramme erfolgt durch Sortierung und gleichgroße Sprünge.</p>
</section>
<section id="histogramme-zur-schatzung-fur-joins">
<h3><span class="section-number">5.6.7. </span>Histogramme zur Schätzung für Joins<a class="headerlink" href="#histogramme-zur-schatzung-fur-joins" title="Permalink to this heading">#</a></h3>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Wertebereich Temperator °F</p></th>
<th class="head"><p>Januar</p></th>
<th class="head"><p>Juli</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0-9</p></td>
<td><p>40</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>10-19</p></td>
<td><p>60</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>20-29</p></td>
<td><p>80</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>30-39</p></td>
<td><p>50</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>40-49</p></td>
<td><p>10</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>50-59</p></td>
<td><p>5</p></td>
<td><p>20</p></td>
</tr>
<tr class="row-even"><td><p>60-69</p></td>
<td><p>0</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-odd"><td><p>70-79</p></td>
<td><p>0</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-even"><td><p>80-89</p></td>
<td><p>0</p></td>
<td><p>60</p></td>
</tr>
<tr class="row-odd"><td><p>90-99</p></td>
<td><p>0</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">Januar</span><span class="o">.</span><span class="n">Tag</span><span class="p">,</span> <span class="n">Juli</span><span class="o">.</span><span class="n">Tag</span>
<span class="n">FROM</span> <span class="n">Januar</span><span class="p">,</span> <span class="n">Juli</span>
<span class="n">WHERE</span> <span class="n">Januar</span><span class="o">.</span><span class="n">temp</span> <span class="o">=</span> <span class="n">Juli</span><span class="o">.</span><span class="n">temp</span>
</pre></div>
</div>
<p>Die Schätzung pro Wertebereich erfolgt mit <span class="math notranslate nohighlight">\(Histo1 · Histo2 / Breite\)</span>. Besonders interessant sind die Wertebereiche von 40-49 und 50-59, da sowohl im Januar, als auch im Juli ein jeweils ein Wert steht: <span class="math notranslate nohighlight">\(10·5/10 + 5·20/10 = 5 + 10 = 15\)</span>. Insgesamt sind es also 15 gemessene Werte. </br>
Gibt es kein Histogramm, dann muss eine herkömmliche Schätzung gemacht werden. Man wüsste, dass es 245 Tupel  mit gleichverteilten Temperaturen pro Relation gibt. Die Berechnung für den Join ist dann 245·245/100 = 600 Tupel.
</br></p>
<p>Eine neue <strong>Variante</strong> ist es, die Histogramme jeweils die 3 häufigsten Werte auflisten und den Rest gruppieren zu lassen. Besonders ist es für z.B. Zipf-verteilte Daten geeignet.</p>
<p><strong>Beispiel</strong></p>
<p>Die Anfrage ist <span class="math notranslate nohighlight">\(R(A,B) \Join S(B,C)\)</span>.</br>
Das Histogramm für R.B ist</p>
<ul class="simple">
<li><p>1: 200;</p></li>
<li><p>0:150;</p></li>
<li><p>5: 100;</p></li>
<li><p>Rest: 550.</p></li>
</ul>
<p>Das Histogramm für S.B ist
0: 100;</p>
<ul class="simple">
<li><p>1: 80;</p></li>
<li><p>2: 70;</p></li>
<li><p>Rest: 250.</p></li>
</ul>
<p>Insgesamt gibt es in R 14 und in S 13 unterschiedlich Werte: V(R,B) = 14 und V(S,B) = 13. Die Resttupel in R (550 Tupel) haben somit 11 verschiedene Werte bei einer Annahme von je 50 Tupeln. Die Resttupel in S (250 Tupel) haben 10 verschiedene Werte bei einer Annahme von je 25 Tupeln. </br>
Man kann eine genaue Schätzung für die Werte 0 und 1 von B machen: <span class="math notranslate nohighlight">\(150·100 + 200·80=31000\)</span>. Der Wert „2“ kommt geschätzt 50 mal in R und 70 mal in S vor: <span class="math notranslate nohighlight">\(50 · 70 = 3500\)</span>. Insgesamt also 3500 Tupel. Der Wert „5“ kommt geschätzt 25 mal in S und 100 mal in R vor: <span class="math notranslate nohighlight">\(100 · 25 = 2500\)</span>. Für 9 weitere gemeinsame Werte in R und S ergibt sich dann: <span class="math notranslate nohighlight">\(9 · (50 · 25) = 11250\)</span>.</p>
</section>
<section id="erhebung-von-statistiken">
<h3><span class="section-number">5.6.8. </span>Erhebung von Statistiken<a class="headerlink" href="#erhebung-von-statistiken" title="Permalink to this heading">#</a></h3>
<p>Die Statistiken können nicht dauernd aktuell gehalten werden. Sie werden nur periodisch erhoben werden. Statistiken ändern sich nicht laufend und auch nicht radikal. Auch falsche Statistiken funktionieren, wenn sie konsistent angewendet werden.
Statistiken sollen selbst nicht zu einem hot-spot werden. Sie sollen nicht dauernd geändert werden, da sie oft gelesen werden.
Die Erhebung wird durch unterschiedliche Trigger ausgelöst. Sie kann regelmäßig bzw. periodisch ausgeführt werden oder nach einer festen Menge an Updates ausgelöst werden. Möglich wäre auch eine Erhebung, falls Schätzungen während der Anfrageausführung als zu ungenau erkannt werden. Außerdem kann sie auch durch einen Administrator ausgelöst werden. </br>
Die Berechnung der Statistiken ist sehr aufwändig. Ein Grund, warum sie nicht andauernd aktuell gehalten werden. Eine Lösung, um den Aufwand zu reduzieren ist es, Sampling zu nutzen. Man nimmt eine Teilmenge der Daten und erhebt darauf Statistiken. Sampling wird hier aber nicht weiter vertieft.</p>
</section>
</section>
<section id="joinreihenfolge">
<h2><span class="section-number">5.7. </span>Joinreihenfolge<a class="headerlink" href="#joinreihenfolge" title="Permalink to this heading">#</a></h2>
<section id="enumeration-physischer-anfrageplane">
<h3><span class="section-number">5.7.1. </span>Enumeration Physischer Anfragepläne<a class="headerlink" href="#enumeration-physischer-anfrageplane" title="Permalink to this heading">#</a></h3>
<p>Die erste Idee wäre es, eine <strong>vollständige Enumeration</strong> entlang aller Freiheitsgrade durchzuführen. Die Reihenfolge und die Gruppierung von assoziativen und kommutativen Operatoren kann abgeändert werden. Außerdem lässt sich der Algorithmus für jeden Operator und der Modus des Datentransports zwischen den Operatoren frei wählen.
Zu jedem Anfrageplan wird ein Kostenplan berechnet und daraus der Plan mit den geringsten Kosten ausgewählt. Durch das Ausführen einer vollständigen Enumeration enstehen zu viele Anfragepläne. Beispielsweise werden Abschnitte in den Plänen mehrfach berechnet. Die Anzahl der Pläne muss reduziert werden. Daher werden diverse bessere Methoden wie die Heuristische Auswahl, Branch-and-Bound, Hill-Climbing und Dynamische Programmierung/Selinger-Style Optimization verwendet.</p>
</section>
<section id="heuristische-auswahl">
<h3><span class="section-number">5.7.2. </span>Heuristische Auswahl<a class="headerlink" href="#heuristische-auswahl" title="Permalink to this heading">#</a></h3>
<p>Bei der Heuristischen Auswahl soll eine Sequenz bekannter Heuristiken angewendet werden, wie zum Beispiel ein Greedy-Verfahren für die Joinreihenfolge:</p>
<ol class="arabic simple">
<li><p>Wähle zuerst das Joinpaar mit dem kleinstem Zwischenergebnis.</p></li>
<li><p>Joine die Relation hinzu, die wiederum das kleinste Zwischenergebnis erzeugt.</p></li>
<li><p>usw.</p></li>
</ol>
<p>Weitere Heuristiken wären unter Anderem:</p>
<ul class="simple">
<li><p>Falls eine Selektion und ein Index auf ein Selektionsattribut gegeben sind, sollte man den Index-Scan wählen.</p></li>
<li><p>Führe mehrere Selektionen auf der selben Relation zugleich aus.</p></li>
<li><p>Falls der Index auf dem Joinattribut ist, soll ein Index-Join gewählt werden.</p></li>
<li><p>Falls ein Joininput sortiert ist, soll man den Sort-Merge-Join wählen, sofern kein Index vorhanden ist.</p></li>
</ul>
</section>
<section id="branch-and-bound">
<h3><span class="section-number">5.7.3. </span>Branch and Bound<a class="headerlink" href="#branch-and-bound" title="Permalink to this heading">#</a></h3>
<p>Eine weitere Idee ist Branch and Bound. Heuristiken werden zum Finden eines ersten guten Plans verwendet. Die Kosten des ersten guten Plans bilden sowohl eine obere Schranke für alle anderen Pläne, als auch für die Teilpläne. Für diverse Teile der Anfrage werden Pläne enumeriert. Es wird versucht einen Teil der Anfrage zu verbessern. Teilpläne, die mehr als die Schranke kosten, werden verworfen. Wenn ein besserer Gesamtplan gefunden wird, wird die Schranke gesenkt. Der Vorteil von Branch and Bound ist, dass die Optimierung jederzeit abgebrochen werden kann.</p>
</section>
<section id="hill-climbing">
<h3><span class="section-number">5.7.4. </span>Hill-Climbing<a class="headerlink" href="#hill-climbing" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Hill-Climbing.png"><img alt="Hill-Climbing" src="../_images/Hill-Climbing.png" style="width: 200px;" /></a>
<p>Hill Climbing beschreibt wie man einen ersten guten Plan mittels Heuristiken findet.
Dazu werden schrittweise ähnliche Pläne mit niedrigeren Kosten gesucht. Unter ähnlich versteht man hier, dass sich ein anderer Plan nur um eine Änderung unterscheidet. Sobald kein ähnlicher Plan mehr besser ist, ist das Verfahren fertig.
Der Nachteil von Hill-Climbing ist, dass es sich um ein Lokales Optimum handelt. Global hätte es eventuell noch einen besseren Plan gegeben. Ein globales Optimum zu finden benötigt zu viel Zeit. </br>
Es gibt verschiedene Varianten, um das Verfahren zu verbessern. Zum Einem das Iterative Improvement bei dem mit 10 verschiedenen Startplänen losgelegt wird. Zum Anderen das Simulated Annealing bei dem auch Verschlechterungen zugelassen werden.</p>
</section>
<section id="dynamische-programmierung-selinger-style-optimierung">
<h3><span class="section-number">5.7.5. </span>Dynamische Programmierung &amp; Selinger-style Optimierung<a class="headerlink" href="#dynamische-programmierung-selinger-style-optimierung" title="Permalink to this heading">#</a></h3>
<p>Ein Verfahren zur Berechnung ist die Dynamische Programmierung.
Es wird jeweils der beste Teilplan gesucht und verwendet, um einen höheren Teilplan zu bauen. Der Baum wird von unten nach oben (bottom-up) durchlaufen. </br>
Selinger hat die Dynamische Programmierung erweitert und abgeändert (Selinger-Style). Es wird nicht nur der beste Plan, sondern auch verschiedene, interessante Sortiervarianten (interesting order) gemerkt. Die Kosten einiger Pläne dürfen höher sein, sofern sie andere Vorteile mit sich bringen. Das Verfahren beeinflusst nicht die Kardinalitäten von Zwischenergebnissen, sondern die I/O-Kosten.</p>
</section>
<section id="richard-bellman">
<h3><span class="section-number">5.7.6. </span>Richard Bellman<a class="headerlink" href="#richard-bellman" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Richard-Bellman.png"><img alt="Richard-Bellman" src="../_images/Richard-Bellman.png" style="width: 300px;" /></a>
<p>Ein kurzer Exkurs zur Historie der Dynamischen Programmierung und dessen Erfinder. Richard Bellman (1920 – 1984) erhielt seinen PhD in Princeton. Er arbeitete unter Anderem von 1944 bis 1946 in Los Alamos.
Während Bellman bei der Rand Corporation arbeitete, erfand er 1953 die Dynamische Programmierung.
Zur Mathematik hat er viele Beiträge zugesteuert wie z.B. den Bellman-Ford Algorithmus:
Ein Algorithmus zum Berechnen aller kürzesten Wege für einen Startknoten.</p>
</section>
<section id="dp-fur-knapsack-problem">
<h3><span class="section-number">5.7.7. </span>DP für Knapsack Problem<a class="headerlink" href="#dp-fur-knapsack-problem" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Knapsach-Zweihander.png"><img alt="Knapsach-Zweihander" src="../_images/Knapsach-Zweihander.png" style="width: 150px;" /></a>
<a class="reference internal image-reference" href="../_images/Knapsack-SaintsChime.png"><img alt="Knapsack-SaintsChime" src="../_images/Knapsack-SaintsChime.png" style="width: 150px;" /></a>
<a class="reference internal image-reference" href="../_images/Knapsack-DragonriderBow.png"><img alt="Knapsack-DragonriderBow" src="../_images/Knapsack-DragonriderBow.png" style="width: 150px;" /></a>
<a class="reference internal image-reference" href="../_images/Knapsack-Rapier.png"><img alt="Knapsack-Rapier" src="../_images/Knapsack-Rapier.png" style="width: 150px;" /></a>
<a class="reference internal image-reference" href="../_images/Knapsack-DragonCrestShield.png"><img alt="Knapsack-DragonCrestShield" src="../_images/Knapsack-DragonCrestShield.png" style="width: 150px;" /></a>
<a class="reference internal image-reference" href="../_images/Knapsack-ShortBow.png"><img alt="Knapsack-ShortBow" src="../_images/Knapsack-ShortBow.png" style="width: 150px;" /></a>
<a class="reference internal image-reference" href="../_images/Knapsack-General.png"><img alt="Knapsack-General" src="../_images/Knapsack-General.png" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="../_images/Knapsack-Ausrüstung.png"><img alt="Knapsack-Ausrüstung" src="../_images/Knapsack-Ausrüstung.png" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="../_images/Knapsack-Rüstung.png"><img alt="Knapsack-Rüstung" src="../_images/Knapsack-Rüstung.png" style="width: 300px;" /></a>
<p><a class="reference external" href="https://darksouls3.wiki.fextralife.com/PvP+Builds">https://darksouls3.wiki.fextralife.com/PvP+Builds</a></p>
<p>Bei dem Knapsack Problem ist ein Rucksack mit begrenzten Gewicht gegeben. In den Rucksack möchte man möglichst gute Items ablegen. Die Items haben ein Gewicht und einen Nutzen. Das Gewicht des Rucksacks soll nicht überschritten werden.</p>
<p>Die Problemformulierung bei Knapsack lautet zum Beispiel wie folgt:</p>
<blockquote>
<div><p>I can carry 15 KG at most.</br>
How can I maximize my damage (dps)?</p>
</div></blockquote>
</section>
<section id="beispiel-knapsack-mit-dp">
<h3><span class="section-number">5.7.8. </span>Beispiel: Knapsack mit DP<a class="headerlink" href="#beispiel-knapsack-mit-dp" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Knapsack-mit-DP.png"><img alt="Knapsack-mit-DP" src="../_images/Knapsack-mit-DP.png" style="width: 500px;" /></a>
<p>Die Lösung des Problems wird durch einen Rückwärtslauf ermittelt. Durch eine Tabelle werden nach und nach Items ausgewählt. Die Kapazität wird fortlaufend notiert und berechnet. Das Resultat ist der maximale Nutzen.</p>
</section>
<section id="dp-traveling-salesman-problem">
<h3><span class="section-number">5.7.9. </span>DP: Traveling Salesman Problem<a class="headerlink" href="#dp-traveling-salesman-problem" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/DP-Traveling-Salesman-Problem.png"><img alt="DP-Traveling-Salesman-Problem" src="../_images/DP-Traveling-Salesman-Problem.png" style="width: 500px;" /></a>
<p>Ein ähnliches Verfahren wird beim Traveling Salesman Problem verwendet. Beim Traveling Salesman Problem sollen alle Städte besucht werden, ohne einen Pfad mehrmals zu betreten. Gesucht ist der kürzeste Pfad, der es ermöglicht.</p>
</section>
<section id="dynamic-programming-heldkarp-algorithmus">
<h3><span class="section-number">5.7.10. </span>Dynamic Programming (Held–Karp Algorithmus)<a class="headerlink" href="#dynamic-programming-heldkarp-algorithmus" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Dynamic-Programming.png"><img alt="Dynamic-Programming" src="../_images/Dynamic-Programming.png" style="width: 200px;" /></a>
<p>Zunächst wird a als Anfangs- und Endpunkt betrachtet. Für alle anderen Knoten i wird der Pfad mit den Minimalkosten von a nach i, welcher alle anderen Knoten enthält, gesucht. Sei <span class="math notranslate nohighlight">\(cost(i)\)</span> definiert als Kosten des Pfades. <span class="math notranslate nohighlight">\(cost(i) + dist(i, a)\)</span> entspricht dann der Rundreise mit <span class="math notranslate nohighlight">\(dist(i, a)\)</span> als Distanz von i nach a. Das Ergebnis ist das Minimum der <span class="math notranslate nohighlight">\([cost(i) + dist(i, a)]\)</span> Pfade.</br>
Mittels DP wird cost(i) berechnet:
Sei <span class="math notranslate nohighlight">\(C(S, i)\)</span> die Minimalkosten für ein Pfad von a nach i, der jeden Knoten in S genau
einmal besucht. Gestartet wird mit allen Teilmengen S der Größe 2. Für diese werden <span class="math notranslate nohighlight">\(C(S, i)\)</span> berechnet. Im nächsten Schritt werden Stufenweise die Teilmengen der Größe 3, 4 u.s.w. betrachtet.</p>
<ol class="arabic simple">
<li><p>Für <span class="math notranslate nohighlight">\(|S| = 2\)</span> gilt: <span class="math notranslate nohighlight">\(S ={a, i}\)</span> und <span class="math notranslate nohighlight">\(C(S, i) = dist(a, i)\)</span>.</p></li>
<li><p>Für <span class="math notranslate nohighlight">\(|S| &gt; 2\)</span> gilt:  <span class="math notranslate nohighlight">\(C(S, i) = min{ C(S-\{i\}, j) + dist(j, i)}\)</span>, wenn <span class="math notranslate nohighlight">\(j \neq i\)</span> und <span class="math notranslate nohighlight">\(j \neq a\)</span>.</p></li>
</ol>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(C(\{a,b\},b) = 3\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,c\} ,c) = 4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,d\} ,d) = 2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,e\} ,e) = 7\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,c\},c) = min\{C(\{a,b\},b)+dist(b,c)\}=3+4=7\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,d\},d) = min\{C(\{a,b\},b)+dist(b,d)\}=3+6=9\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,e\},e) = min\{C(\{a,b\},e)+dist(b,e)\}=3+3=6\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,c\},b) = min\{C(\{a,c\},c)+dist(c,b)\}=4+4=8\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,d\},b) = min\{C(\{a,d\},d)+dist(d,b)\}=2+6=8\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(...\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,c,d\},c) = min\{C(\{a,b,d\},d)+dist(d,c), C(\{a,b,d\},b)+dist(b,c)\}=min\{9+5,8+4\}=12\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(...\)</span></p></li>
</ul>
<p>Die Komplexität ist mit <span class="math notranslate nohighlight">\(O(n^{2}2^{n})\)</span> immernoch sehr hoch, aber vieles muss nicht mehr doppelt berechnet werden. Das Verfahren ist zwar besser als Backtracking aber noch zu schwer.</p>
</section>
<section id="dynamische-programmierung">
<h3><span class="section-number">5.7.11. </span>Dynamische Programmierung<a class="headerlink" href="#dynamische-programmierung" title="Permalink to this heading">#</a></h3>
<p>Die Dynamische Programmierung ist ein Optimaler Algorithmus. Schwierigkeiten dabei sind die Annahmen. Zum Einem muss das Prinzip der Optimalität gelten. Ein optimaler Teilplan führt immer zu einem optimalen Gesamtplan. Zum Anderen muss das Problem geschickt in Teilprobleme aufgeteilt werden. Der Aufwand kann zwar immernoch exponentiell sein, aber es können sich Operationen und Verdopplungen gespart werden.
Klassische Anwendungen für die Dynamische Programmierung sind das Knapsack Problem, das Traveling Salesman Problem, die Maschinenbelegung und das Transportproblem.</p>
</section>
<section id="anwendung-fur-left-deep-baume">
<h3><span class="section-number">5.7.12. </span>Anwendung für Left-Deep Bäume<a class="headerlink" href="#anwendung-fur-left-deep-baume" title="Permalink to this heading">#</a></h3>
</section>
<section id="anfrageplanung">
<h3><span class="section-number">5.7.13. </span>Anfrageplanung<a class="headerlink" href="#anfrageplanung" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Anfrageplanung.png"><img alt="Anfrageplanung" src="../_images/Anfrageplanung.png" style="width: 500px;" /></a>
<p>Bei der heuristischen Einschränkung des Suchraums gibt es bei den Anfragen keine Kreuzprodukte. Diese werden aussortiert. Das gilt nicht bei expliziten Kreuzprodukten in der Anfrage. Die Selektionsbedingungen sollen so früh wie möglich eingesetzt werden.
Betrachtet werden nur links-tiefe (left-deep) Bäume. Es wird nie die parallele Ausführung von Joins betrachtet. Es wird immer davon ausgegangen, dass ein Join nach dem Andern ausgeführt wird.</p>
</section>
<section id="anfragebearbeitung-optimierung">
<h3><span class="section-number">5.7.14. </span>Anfragebearbeitung – Optimierung<a class="headerlink" href="#anfragebearbeitung-optimierung" title="Permalink to this heading">#</a></h3>
<p>Bei der Optimierung wird nur die Joinreihenfolge und nicht die Parallelität betrachtet. Bei mehr-Prozessor Systemen wiederrum wird nicht nur die Reihenfolge, sondern auch die Parallelisierung berücksichtigt. Bei verteilten System kommen noch die Speicherorte der Zwischenergebnisse hinzu. Der Join ist i.d.R. der teuerste Operator.
Die Optimierung konzentriert sich auf die beste Reihenfolge. Ziel sind möglichst geringe Zwischenkosten.
Weitere Optimierungsschritte, wie das Schieben der Selektionen nach unten, werden später angewandt.
Bei n Relationen gibt es <span class="math notranslate nohighlight">\(n!\)</span> Alternativen, aber meistens enthalten die Alternativen ein kartesisches Produkt.</p>
</section>
<section id="dynamische-programmierung-optimierung-im-system-r">
<h3><span class="section-number">5.7.15. </span>Dynamische Programmierung: Optimierung im System-R<a class="headerlink" href="#dynamische-programmierung-optimierung-im-system-r" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Selinger.png"><img alt="Selinger" src="../_images/Selinger.png" style="width: 200px;" /></a>
<p>Das Verfahren von Selinger ist auch bekannt unter dem Namen: “Selinger-style query optimization”. Selinger ist eine Pionierin im Bereich von Datenbanksystemen. Ein klassischer Artikel zur Anfrageoptimierung ist [SAC+79]. Ursprünglich wurde das Verfahren bei IBM im System-R eingesetzt und ist heutzutage weit verbreitet.
</br></br>
Die Grundidee der Optimierung ist es, nur “Left-deep” Anfragebäume zu verwenden. D.h. nur die Joinreihenfolge ist von Bedeutung. Die innere und die äußere Relation bleibt unberücksichtigt.
Anfragepläne werden durch dynamische Programmierung (DP) von unten nach oben (bottom-up) generiert.
Zusätzlich sind auch interesting orders (interessante Sortierungen) und interesting sites (interessante Ausführungsorte) wichtig, werden aber in anderen Veranstaltungen behandelt.</p>
<a class="reference internal image-reference" href="../_images/AccessPathSelection-IBM.png"><img alt="AccessPathSelection-IBM" src="../_images/AccessPathSelection-IBM.png" style="width: 500px;" /></a>
<p>Das Paper der IBM Research Division zu “Access Path Selection in a Relational Database Management System.”</p>
</section>
<section id="bottom-up-anfrageplangenerierung">
<h3><span class="section-number">5.7.16. </span>Bottom-up Anfrageplangenerierung<a class="headerlink" href="#bottom-up-anfrageplangenerierung" title="Permalink to this heading">#</a></h3>
<p>■ Annahme 1:
Nach dem Join über k Relationen ist die Wahl der Join-Methode die k+1te Relation hinzuzujoinen unabhängig
von den vorigen Join-Methoden.
□ Joinmethoden: Nested Loops, Hashjoin, Sort-Merge Join usw.
■ Annahme 2:
Jeder Teilplan eines optimalen Plans ist ebenfalls optimal.
□ Entspricht dem Prinzip der Optimalität
□ Anders: Wenn sich zwei Pläne nur in einem Teilplan unterscheiden, so ist der Plan mit dem besseren Teilplan
auch der bessere Gesamtplan
■ Bottom-up Anfrageplangenerierung:
□ Berechne die optimalen Pläne für den Join über (jede Kombination von) k Relationen
o Suboptimale Pläne werden verworfen
o Erweitere diese Pläne zu optimalen Plänen für k+1 Relationen.
o usw. bis k = n</p>
</section>
<section id="id4">
<h3><span class="section-number">5.7.17. </span>Dynamische Programmierung<a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Dynamische-Programmierung.png"><img alt="Dynamische-Programmierung" src="../_images/Dynamische-Programmierung.png" style="width: 500px;" /></a>
</section>
<section id="dp-grundidee-fur-anfrageoptimierung">
<h3><span class="section-number">5.7.18. </span>DP – Grundidee für Anfrageoptimierung<a class="headerlink" href="#dp-grundidee-fur-anfrageoptimierung" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Dynamische-Programmierung_2.png"><img alt="Dynamische-Programmierung_2" src="../_images/Dynamische-Programmierung_2.png" style="width: 400px;" /></a>
<p>■ Für jede Kombination merke (in einer Hilfstabelle):
□ Geschätzte Größe des Ergebnisses (Kardinalität)
□ Geschätzte minimale Kosten
– Hier zur Vereinfachung: Größe des Zwischenergebnisses
□ Joinreihenfolge, die diese Kosten verursacht (= optimaler Teilplan)
■ Induktion über Anzahl der Relationen im Plan
□ N=1: Für jede Relation
– Kardinalität = Kardinalität der Relation
– Kosten = 0 (zur Vereinfachung)
– Joinreihenfolge: n/a
□ N=2: Für jedes Relationenpaar R, S
– Kardinalität = |R| x |S| x sf
– Kosten = 0
– Joinreihenfolge: kleinere Relation links
– Clou: R und S jeweils mit besten access-path
□ N=3: Für jedes Tripel R, S, T
– Clou: Nur bestes Relationenpaar aus dem Tripel wird um dritte Relation ergänzt</p>
</section>
<section id="dp-beispiel">
<h3><span class="section-number">5.7.19. </span>DP – Beispiel<a class="headerlink" href="#dp-beispiel" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/DP-Beispiel.png"><img alt="DP-Beispiel" src="../_images/DP-Beispiel.png" style="width: 200px;" /></a>
<p>■ Anfrage über Relationen R, S, T, U.
■ Vier Join-Bedingungen</p>
<a class="reference internal image-reference" href="../_images/DP-Beispiel_2.png"><img alt="DP-Beispiel_2" src="../_images/DP-Beispiel_2.png" style="width: 500px;" /></a>
<a class="reference internal image-reference" href="../_images/DP-Beispiel_3.png"><img alt="DP-Beispiel_3" src="../_images/DP-Beispiel_3.png" style="width: 500px;" /></a>
<a class="reference internal image-reference" href="../_images/DP-Beispiel_4.png"><img alt="DP-Beispiel_4" src="../_images/DP-Beispiel_4.png" style="width: 500px;" /></a>
</section>
<section id="dp-interesting-orders-interessante-sortierung">
<h3><span class="section-number">5.7.20. </span>DP - interesting orders (Interessante Sortierung)<a class="headerlink" href="#dp-interesting-orders-interessante-sortierung" title="Permalink to this heading">#</a></h3>
<p>■ WdH.: Prinzip der Optimalität: Wenn sich zwei Pläne nur in einem Teilplan unterscheiden, so ist der Plan mit dem besseren Teilplan
auch der bessere Gesamtplan.
■ Gegenbeispiel?
□ R(A,B) ⋈ S(A,C) ⋈ T(A,D)
□ Bester (lokaler) Plan für R ⋈ S: Hash-Join
□ Best (globaler) Gesamtplan:
– 1. Sort-merge Join über R und S
– 2. Sort-merge Join mit T
■ Warum könnte dies so sein?
□ Das Zwischenergebnis von R ⋈sort-mergeS ist nach Join-Attribut A sortiert.
□ Dies ist eine interesting order, die später ausgenutzt werden kann:
– Spätere sort-merge Joins
– Gruppierung (GROUP BY)
– Sortierung (ORDER BY)
– Eindeutige Tupel (DISTINCT)</p>
<p>■ Bei Auswahl des besten Teilplans:
□ Kostenvergleich genügt nicht.
– Es gibt keine vollständige Ordnung der Teilpläne nach Kosten.
□ Auch Sortierungen müssen berücksichtigt werden.
■ Lösung: Für jede Kombination von Relationen, speichere mehrere Sortiervarianten:
□ Nach jeder Variante der beteiligten Teilpläne
□ Die “leere” Sortierung
□ DP Tabellen werden „breiter“.
■ Kostenmodell muss verfeinert werden
□ Echte I/O Kosten, statt Größe des Zwischenergebnisses
■ Merke außerdem Join- und Sortieroperationen, die diese Sortierung erzeugen.
□ Also der Plan</p>
</section>
<section id="dp-algorithmus">
<h3><span class="section-number">5.7.21. </span>DP – Algorithmus<a class="headerlink" href="#dp-algorithmus" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/DP-Algorithmus.png"><img alt="DP-Algorithmus" src="../_images/DP-Algorithmus.png" style="width: 500px;" /></a>
<p>Quelle: <a class="reference external" href="http://dx.doi.org/10.1145/371578.371598">http://dx.doi.org/10.1145/371578.371598</a></p>
</section>
</section>
<section id="physische-anfrageplane">
<h2><span class="section-number">5.8. </span>Physische Anfragepläne<a class="headerlink" href="#physische-anfrageplane" title="Permalink to this heading">#</a></h2>
<section id="letzte-schritte">
<h3><span class="section-number">5.8.1. </span>Letzte Schritte<a class="headerlink" href="#letzte-schritte" title="Permalink to this heading">#</a></h3>
<p>■ Wahl des jeweiligen Algorithmus
□ Wenn nicht schon zuvor (z.B. bei DP) geschehen
□ Hier nur beispielhaft: Selektion und Join
■ Pipelining vs. Blocking
■ Zugriffsmethoden für Relationen</p>
<p>■ Pipelining vs. Blocking</p>
<p>■ Zugriffsmethoden für Relationen</p>
</section>
<section id="wahl-der-selektionsmethode">
<h3><span class="section-number">5.8.2. </span>Wahl der Selektionsmethode<a class="headerlink" href="#wahl-der-selektionsmethode" title="Permalink to this heading">#</a></h3>
<p>Wahl der Selektionsmethode
■ Schon kennengelernt
□ Variante 1: Ganz R lesen und Selektionsbedingung auf jedes Tupel anwenden
□ Variante 2: Falls Index auf Selektionsattribut vorhanden: Zugriff über Index
– Voraussetzung: Index und Gleichheitsbedingung
■ Jetzt: Verallgemeinerung auf mehrere Selektionen auf verschiedenen Attributen
□ Mit oder ohne Index
□ Gleichheit oder Ungleichheit (&lt;, &gt;, ≤, ≥, ≠)</p>
<p>■ Annahme: Mindestens eine Selektionsbedingung kann einen Index verwenden.
■ Vorgehen mit Indizes (jeweils viele Alternativen):
□ Verwende Indizes um Schnittmenge der Pointermengen zu ermitteln
□ Lese diese Tupel ein (Index-scan)
□ Wende darauf „Filter“-Operator an: Prüft alle übrigen Bedingungen
■ Vorgehen ohne Indizes
□ Table-scan für ganz R
□ Wende Filter-Operator für alle Bedingungen an
■ Filter-Operator findet nur im Hauptspeicher statt: Keine Kosten
■ Jetzt: Kostenvergleich der Alternativen</p>
</section>
<section id="kostenvergleich-der-selektionsmethoden">
<h3><span class="section-number">5.8.3. </span>Kostenvergleich der Selektionsmethoden<a class="headerlink" href="#kostenvergleich-der-selektionsmethoden" title="Permalink to this heading">#</a></h3>
<p>■ Bisher: Kostenschätzung durch Schätzung der Ergebnisgröße
□ Kardinalität des Zwischenergebnisses
■ Jetzt: Nur Implementierungsvarianten mit jeweils gleichem Ergebnis
□ Deshalb wieder: Disk I/O
□ Annahme: Indizes kosten nichts (da sehr kleine Datenmengen)
■ Beispiel: sA=10, B&lt;20®
□ Variante 1: Tablescan
– B® falls R clustered
– T® falls R nicht clustered
□ Variante 2: Index auf A verwenden
– B®/V(R,A) falls Index clustering
– T®/V(R,A) falls Index nicht clustering
□ Variante 3: Index auf B verwenden
– B®/3 falls Index clustering
– T®/3 falls Index nicht clustering
□ Variante 4 …</p>
</section>
<section id="kostenvergleich-der-selektionsmethoden-beispiel">
<h3><span class="section-number">5.8.4. </span>Kostenvergleich der Selektionsmethoden – Beispiel<a class="headerlink" href="#kostenvergleich-der-selektionsmethoden-beispiel" title="Permalink to this heading">#</a></h3>
<p>■ sX=1, Y=2, Z&lt;5®
□ T® = 5.000, B® = 200, V(R,X)=100, V(R,Y)=500
□ R sei clustered
□ Indizes auf X und Y nicht clustering
□ Index auf Z clustering (B-Baum)
■ Variante 1: Table-scan und Filter
□ Kosten: B® = 200 I/O
■ Variante 2: Index-scan mit X-Index; Filter für den Rest
□ Kosten: T®/V(R,X) = 5.000/100 = 50 I/O
■ Variante 3: Index-scan mit Y-Index; Filter für den Rest
□ Kosten: T®/V(R,Y) = 5.000/500 = 10 I/O
■ Variante 4: Index-scan mit (clustering) Z-Index; Filter für den Rest
□ Kosten: B®/3= 200/3 = 67 I/O</p>
</section>
<section id="wahl-der-join-methode">
<h3><span class="section-number">5.8.5. </span>Wahl der Join-Methode<a class="headerlink" href="#wahl-der-join-methode" title="Permalink to this heading">#</a></h3>
<p>■ Kosten je nach Joinmethode (siehe voriger Foliensatz)
□ Annahme: Man kennt M (verfügbarer Hauptspeicher)
– Und M ändert sich nicht während der Ausführung
□ Annahme: Man kennt B®, T®, V(R, …)
■ Ideen falls Annahmen nicht stimmen
□ One-pass oder Nested-loop Algorithmus als default
– Prinzip „Hoffnung“
□ Wähle Sort-merge-join falls mindestens ein Input bereits nach Joinattribut sortiert ist.
□ Wähle Sort-merge-join bei mehr als einem Join auf gleichem Attribut
– (R(A,B) ⋈ S(B,C)) ⋈ T(B,D)
□ R(A,B) ⋈ S(B,C): Falls R klein und Index auf S.B: Wähle Index-Join
□ Falls weder Sortierung noch Indizes vorhanden sind: Wähle Hash-Join
– Kosten hängen nur von kleinerem Input ab, nicht von beiden Inputs
■ Analoge Überlegungen für Mengenoperationen</p>
</section>
<section id="pipelining-vs-blocking">
<h3><span class="section-number">5.8.6. </span>Pipelining vs. Blocking<a class="headerlink" href="#pipelining-vs-blocking" title="Permalink to this heading">#</a></h3>
<p>■ Naiv: Blocking (auch „Materialisierend“)
□ Jeder Operator speichert sein Zwischenergebnis auf Disk
■ Besser: Vermischung der Ausführung verschiedener Operatoren
□ Pipelining
□ Kette von Iteratoren
■ Vorteile von Pipelining
□ Weniger I/O
□ Frühe Ergebnisse bei der Anwendung
■ Nachteile des Pipelining?
□ Nicht jeder Operator funktioniert
□ Anzahl CPUs zu gering
□ Jeder Operator hat weniger Hauptspeicher
□ =&gt; Ungünstigere Algorithmen müssen gewählt werden
■ Pipelining also nicht immer besser!</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "LUH-DBS/GDBS_Script",
            ref: "main/",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./05"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="../04/anfrageausfuehrung.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">4. </span>Anfrageausführung</p>
      </div>
    </a>
    <a class="right-next"
       href="../06/large-scale-data-management.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">6. </span>Large Scale Data Management</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wiederholung-anfragebearbeitung">5.1. Wiederholung: Anfragebearbeitung</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grundproblem">5.1.1. Grundproblem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ablauf-der-anfragebearbeitung">5.1.2. Ablauf der Anfragebearbeitung</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">5.2. Ablauf der Anfragebearbeitung</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing">5.2.1. Parsing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algebraische-transformationsregeln">5.3. Algebraische Transformationsregeln</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kommutativitat-und-assoziativitat">5.3.1. Kommutativität und Assoziativität</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#weitere-regeln">5.3.2. Weitere Regeln</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#logische-anfrageplane">5.4. Logische Anfragepläne</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zwei-schritte">5.4.1. Zwei Schritte</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-anfragebearbeitung">5.4.2. Beispiel - Anfragebearbeitung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ubergang-zum-physischen-anfrageplan">5.4.3. Übergang zum Physischen Anfrageplan</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenmodell">5.5. Kostenmodell</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenbasierte-optimierung-wiederholung">5.5.1. Kostenbasierte Optimierung (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problemgrosze-suchraum-wiederholung">5.5.2. Problemgröße (Suchraum) (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenmodell-wiederholung">5.5.3. Kostenmodell (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#statistiken-wiederholung">5.5.4. Statistiken (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kosten-von-operationen">5.5.5. Kosten von Operationen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-projektion">5.5.6. Kostenschätzung - Projektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-selektion">5.5.7. Kostenschätzung - Selektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#selektivitat-schatzen">5.5.8. Selektivität schätzen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-fur-skew-zipf-verteilung">5.5.9. Beispiel für Skew: Zipf-Verteilung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">5.5.10. Kostenschätzung - Selektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-selektion-mit-disjunktion">5.5.11. Kostenschätzung - Selektion mit Disjunktion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join">5.5.12. Kostenschätzung - Join</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join-beispiel">5.5.13. Kostenschätzung - Join Beispiel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join-mehrere-attribute">5.5.14. Kostenschätzung Join - Mehrere Attribute</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-mehrfacher-join">5.5.15. Kostenschätzung - Mehrfacher Join</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-weitere-operationen">5.5.16. Kostenschätzung - Weitere Operationen</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#histogramme">5.6. Histogramme</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">5.6.1. Ablauf der Anfragebearbeitung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schatzung-der-statistiken">5.6.2. Schätzung der Statistiken</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schatzung-der-statistiken-histogramme">5.6.3. Schätzung der Statistiken - Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#verteilungen-korpergewicht">5.6.4. Verteilungen - Körpergewicht</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equi-width-histogramme">5.6.5. Equi-Width Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equi-height-histogramme">5.6.6. Equi-Height-Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#histogramme-zur-schatzung-fur-joins">5.6.7. Histogramme zur Schätzung für Joins</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#erhebung-von-statistiken">5.6.8. Erhebung von Statistiken</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#joinreihenfolge">5.7. Joinreihenfolge</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#enumeration-physischer-anfrageplane">5.7.1. Enumeration Physischer Anfragepläne</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#heuristische-auswahl">5.7.2. Heuristische Auswahl</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#branch-and-bound">5.7.3. Branch and Bound</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hill-climbing">5.7.4. Hill-Climbing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung-selinger-style-optimierung">5.7.5. Dynamische Programmierung &amp; Selinger-style Optimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#richard-bellman">5.7.6. Richard Bellman</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-fur-knapsack-problem">5.7.7. DP für Knapsack Problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-knapsack-mit-dp">5.7.8. Beispiel: Knapsack mit DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-traveling-salesman-problem">5.7.9. DP: Traveling Salesman Problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamic-programming-heldkarp-algorithmus">5.7.10. Dynamic Programming (Held–Karp Algorithmus)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung">5.7.11. Dynamische Programmierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anwendung-fur-left-deep-baume">5.7.12. Anwendung für Left-Deep Bäume</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anfrageplanung">5.7.13. Anfrageplanung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anfragebearbeitung-optimierung">5.7.14. Anfragebearbeitung – Optimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung-optimierung-im-system-r">5.7.15. Dynamische Programmierung: Optimierung im System-R</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bottom-up-anfrageplangenerierung">5.7.16. Bottom-up Anfrageplangenerierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">5.7.17. Dynamische Programmierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-grundidee-fur-anfrageoptimierung">5.7.18. DP – Grundidee für Anfrageoptimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-beispiel">5.7.19. DP – Beispiel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-interesting-orders-interessante-sortierung">5.7.20. DP - interesting orders (Interessante Sortierung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-algorithmus">5.7.21. DP – Algorithmus</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#physische-anfrageplane">5.8. Physische Anfragepläne</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#letzte-schritte">5.8.1. Letzte Schritte</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wahl-der-selektionsmethode">5.8.2. Wahl der Selektionsmethode</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenvergleich-der-selektionsmethoden">5.8.3. Kostenvergleich der Selektionsmethoden</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenvergleich-der-selektionsmethoden-beispiel">5.8.4. Kostenvergleich der Selektionsmethoden – Beispiel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wahl-der-join-methode">5.8.5. Wahl der Join-Methode</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pipelining-vs-blocking">5.8.6. Pipelining vs. Blocking</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Prof. Dr. Ziawasch Abedjan
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>