

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>5. Optimierung &#8212; Online-Skript Datenbanksysteme II</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '05/optimierung';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. Large Scale Data Management" href="../06/large-scale-data-management.html" />
    <link rel="prev" title="4. Anfrageausführung" href="../04/anfrageausfuehrung.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/DBIS_Kurzlogo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/DBIS_Kurzlogo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Datenbanksysteme II
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../01/speicherung.html">1. Speicherung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02/repraesentation.html">2. Repräsentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03/indizes.html">3. Indizes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04/anfrageausfuehrung.html">4. Anfrageausführung</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">5. Optimierung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06/large-scale-data-management.html">6. Large Scale Data Management</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/LUH-DBS/GDBS_Script" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/LUH-DBS/GDBS_Script/issues/new?title=Issue%20on%20page%20%2F05/optimierung.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/05/optimierung.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Optimierung</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wiederholung-anfragebearbeitung">5.1. Wiederholung: Anfragebearbeitung</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grundproblem">5.1.1. Grundproblem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ablauf-der-anfragebearbeitung">5.1.2. Ablauf der Anfragebearbeitung</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">5.2. Ablauf der Anfragebearbeitung</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing">5.2.1. Parsing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algebraische-transformationsregeln">5.3. Algebraische Transformationsregeln</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kommutativitat-und-assoziativitat">5.3.1. Kommutativität und Assoziativität</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#weitere-regeln">5.3.2. Weitere Regeln</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#logische-anfrageplane">5.4. Logische Anfragepläne</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zwei-schritte">5.4.1. Zwei Schritte</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-anfragebearbeitung">5.4.2. Beispiel - Anfragebearbeitung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ubergang-zum-physischen-anfrageplan">5.4.3. Übergang zum Physischen Anfrageplan</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenmodell">5.5. Kostenmodell</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenbasierte-optimierung-wiederholung">5.5.1. Kostenbasierte Optimierung (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problemgrosze-suchraum-wiederholung">5.5.2. Problemgröße (Suchraum) (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenmodell-wiederholung">5.5.3. Kostenmodell (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#statistiken-wiederholung">5.5.4. Statistiken (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kosten-von-operationen">5.5.5. Kosten von Operationen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-projektion">5.5.6. Kostenschätzung - Projektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-selektion">5.5.7. Kostenschätzung - Selektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#selektivitat-schatzen">5.5.8. Selektivität schätzen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-fur-skew-zipf-verteilung">5.5.9. Beispiel für Skew: Zipf-Verteilung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">5.5.10. Kostenschätzung - Selektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-selektion-mit-disjunktion">5.5.11. Kostenschätzung - Selektion mit Disjunktion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join">5.5.12. Kostenschätzung - Join</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join-beispiel">5.5.13. Kostenschätzung - Join Beispiel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join-mehrere-attribute">5.5.14. Kostenschätzung Join - Mehrere Attribute</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-mehrfacher-join">5.5.15. Kostenschätzung - Mehrfacher Join</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-weitere-operationen">5.5.16. Kostenschätzung - Weitere Operationen</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#histogramme">5.6. Histogramme</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">5.6.1. Ablauf der Anfragebearbeitung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schatzung-der-statistiken">5.6.2. Schätzung der Statistiken</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schatzung-der-statistiken-histogramme">5.6.3. Schätzung der Statistiken - Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#verteilungen-korpergewicht">5.6.4. Verteilungen - Körpergewicht</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equi-width-histogramme">5.6.5. Equi-Width Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equi-height-histogramme">5.6.6. Equi-Height-Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#histogramme-zur-schatzung-fur-joins">5.6.7. Histogramme zur Schätzung für Joins</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#erhebung-von-statistiken">5.6.8. Erhebung von Statistiken</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#joinreihenfolge">5.7. Joinreihenfolge</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#enumeration-physischer-anfrageplane">5.7.1. Enumeration Physischer Anfragepläne</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#heuristische-auswahl">5.7.2. Heuristische Auswahl</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#branch-and-bound">5.7.3. Branch and Bound</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hill-climbing">5.7.4. Hill-Climbing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung-selinger-style-optimierung">5.7.5. Dynamische Programmierung &amp; Selinger-style Optimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#richard-bellman">5.7.6. Richard Bellman</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-fur-knapsack-problem">5.7.7. DP für Knapsack Problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-knapsack-mit-dp">5.7.8. Beispiel: Knapsack mit DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-traveling-salesman-problem">5.7.9. DP: Traveling Salesman Problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamic-programming-heldkarp-algorithmus">5.7.10. Dynamic Programming (Held–Karp Algorithmus)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung">5.7.11. Dynamische Programmierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anwendung-fur-left-deep-baume">5.7.12. Anwendung für Left-Deep Bäume</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anfrageplanung">5.7.13. Anfrageplanung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anfragebearbeitung-optimierung">5.7.14. Anfragebearbeitung – Optimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung-optimierung-im-system-r">5.7.15. Dynamische Programmierung: Optimierung im System-R</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bottom-up-anfrageplangenerierung">5.7.16. Bottom-up Anfrageplangenerierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">5.7.17. Dynamische Programmierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-grundidee-fur-anfrageoptimierung">5.7.18. DP – Grundidee für Anfrageoptimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-beispiel">5.7.19. DP – Beispiel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-interesting-orders-interessante-sortierung">5.7.20. DP - interesting orders (Interessante Sortierung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-algorithmus">5.7.21. DP – Algorithmus</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#physische-anfrageplane">5.8. Physische Anfragepläne</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wahl-der-selektionsmethode">5.8.1. Wahl der Selektionsmethode</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenvergleich-der-selektionsmethoden">5.8.2. Kostenvergleich der Selektionsmethoden</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wahl-der-join-methode">5.8.3. Wahl der Join-Methode</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pipelining-vs-blocking">5.8.4. Pipelining vs. Blocking</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="optimierung">
<h1><span class="section-number">5. </span>Optimierung<a class="headerlink" href="#optimierung" title="Permalink to this heading">#</a></h1>
<p>Im Fokus dieses Kapitels steht die Optimierung auf logischer Ebene, wobei es eher um die Daten selbst geht und weniger um die Speicherabbildung.</p>
<section id="wiederholung-anfragebearbeitung">
<h2><span class="section-number">5.1. </span>Wiederholung: Anfragebearbeitung<a class="headerlink" href="#wiederholung-anfragebearbeitung" title="Permalink to this heading">#</a></h2>
<p>Bevor die Details der Optimierung vertieft werden, lohnt es sich, einen erneuten Blick auf die Anfragebearbeitung zu werfen, insbesondere im Kontext des Grundproblems und des Ablaufs.</p>
<section id="grundproblem">
<h3><span class="section-number">5.1.1. </span>Grundproblem<a class="headerlink" href="#grundproblem" title="Permalink to this heading">#</a></h3>
<p>Anfragen in SQL und der Relationalen Algebra sind deklarativ. Solche Anfragen müssen in ausführbare (prozedurale) Form transformiert werden. Also in echte ausführbare Programme. Die Ziele dabei sind ein “QEP” (prozeduraler Query Execution Plan) und Effizienz. Eine Anfrage soll schnell sein und wenige Ressourcen verbrauchen (CPU, I/O, RAM, Bandbreite).</p>
</section>
<section id="ablauf-der-anfragebearbeitung">
<h3><span class="section-number">5.1.2. </span>Ablauf der Anfragebearbeitung<a class="headerlink" href="#ablauf-der-anfragebearbeitung" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p><strong>Parsing</strong></br>
Als erstes wird die Anfrage geparsed und überprüft, ob diese syntaktisch korrekt ist. Danach werden die Elemente semantisch überprüft und ein Parsebaum erstellt.</p></li>
<li><p><strong>Wahl des logischen Anfrageplans</strong></br>
Im zweiten Schritt werden exponentiell viele Bäume mit logischen Operatoren erstellt. Darunter wird der optimale Plan ausgewählt, indem vorher logisch, regelbasiert und kostenbasiert optimiert wird.</p></li>
<li><p><strong>Wahl des physischen Anfrageplans</strong></br>
Anhand des logischen Plans wird ein ausführbares Programm mit physischen Operatoren erstellt. Das Programm enthält Algorithmen und Scan-Operatoren. Der optimale Plan wird physisch optimiert und dann ausgewählt. Zum Schluss wird der ausgewählte Anfrageplan ausgeführt.</p></li>
</ol>
 <!-- <img src="pictures/Ablauf-Anfragebearbeitung.png" alt="Ablauf-Anfragebearbeitung" width="250" style="background-color: white;"/> -->
<figure class="align-default" id="id1">
<img alt="../_images/Ablauf-Anfragebearbeitung.png" src="../_images/Ablauf-Anfragebearbeitung.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.1 </span><span class="caption-text">Ablauf der Anfragebearbeitung</span><a class="headerlink" href="#id1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<!-- <img src="pictures/Meme-Finish-SQL-Query.png" alt="Meme-Finish-SQL-Query" width="250" style="background-color: white;"/> -->
<figure class="align-default" id="meme-finish-sql-query">
<img alt="../_images/Meme-Finish-SQL-Query.png" src="../_images/Meme-Finish-SQL-Query.png" />
</figure>
</section>
</section>
<section id="id2">
<h2><span class="section-number">5.2. </span>Ablauf der Anfragebearbeitung<a class="headerlink" href="#id2" title="Permalink to this heading">#</a></h2>
<p>Die einzelnen Schritte bei der Anfragebearbeitung werden nun genauer betrachtet.</p>
<section id="parsing">
<h3><span class="section-number">5.2.1. </span>Parsing<a class="headerlink" href="#parsing" title="Permalink to this heading">#</a></h3>
<p>Beginnend beim Parsing wird auf <strong>syntaktische Korrektheit</strong> überprüft. Dafür wird eine Grammatik für einen Teil von SQL betrachtet. (SFW steht für SelectFromWhere): </br></p>
<ul class="simple">
<li><p>Anfragen</p>
<ul>
<li><p>&lt;Anfrage&gt; :: = &lt;SFW&gt;</p></li>
<li><p>&lt;Anfrage&gt; :: = ( &lt;SFW&gt; )</p></li>
<li><p>die Mengenoperatoren fehlen</p></li>
</ul>
</li>
<li><p>SFWs</p>
<ul>
<li><p>&lt;SFW&gt; ::= SELECT &lt;SelListe&gt; FROM &lt;FromListe&gt; WHERE &lt;Bedingung&gt;</p></li>
<li><p>die Gruppierung, Sortierung etc. fehlen</p></li>
</ul>
</li>
<li><p>Listen</p>
<ul>
<li><p>&lt;SelListe&gt; ::= &lt;Attribut&gt;, &lt;SelListe&gt;</p></li>
<li><p>&lt;SelListe&gt; ::= &lt;Attribut&gt;</p></li>
<li><p>&lt;FromListe&gt; ::= &lt;Relation&gt;, &lt;FromListe&gt;</p></li>
<li><p>&lt;FromListe&gt; ::= &lt;Relation&gt;</p></li>
</ul>
</li>
<li><p>Bedingungen</p>
<ul>
<li><p>&lt;Bedingung&gt; ::= &lt;Bedingung&gt; AND &lt;Bedingung&gt;</p></li>
<li><p>&lt;Bedingung&gt; ::= &lt;Tupel&gt; IN &lt;Anfrage&gt;</p></li>
<li><p>&lt;Bedingung&gt; ::= &lt;Attribut&gt; = &lt;Attribut&gt;</p></li>
<li><p>&lt;Bedingung&gt; ::= &lt;Attribut&gt; LIKE &lt;Muster&gt;</p></li>
</ul>
</li>
<li><p>&lt;Tupel&gt;, &lt;Attribut&gt;, &lt;Relation&gt; und &lt;Muster&gt; sind nicht durch eine grammatische Regel definiert</p></li>
</ul>
<p>Die vollständige Grammatik kann man zum Beispiel <a class="reference external" href="http://docs.openlinksw.com/virtuoso/GRAMMAR.html">hier</a> finden.
</br></br></p>
<p>Anschließend wird während der Übersetzung die <strong>semantische Korrektheit</strong> überprüft. Beantwortet werden dabei generell Fragen wie:</p>
<ul class="simple">
<li><p>Existieren die Relationen und Sichten der FROM Klausel?</p></li>
<li><p>Existieren die Attribute in den genannten Relationen? Sind sie eindeutig?</p></li>
<li><p>Sind die Typen für die Vergleiche korrekt?</p></li>
<li><p>Ist die Aggregation korrekt?</p></li>
</ul>
<figure class="align-default" id="id3">
<img alt="../_images/Ablauf-Anfragebearbeitung_2.png" src="../_images/Ablauf-Anfragebearbeitung_2.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.2 </span><span class="caption-text">Ablauf der Anfragebearbeitung - Parsen</span><a class="headerlink" href="#id3" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="algebraische-transformationsregeln">
<h2><span class="section-number">5.3. </span>Algebraische Transformationsregeln<a class="headerlink" href="#algebraische-transformationsregeln" title="Permalink to this heading">#</a></h2>
<p>Das Ziel ist es aus dem Parsebaum einen logischen Anfrageplan zu erstellen. Ohne die Semantik der Anfrage zu ändern, soll sie in eine interne Darstellung verwandelt werden. Um die Anfrage effizienter auszuführen, sollen insbesondere kleine Zwischenergebnisse erzielt werden. </br>
Am Ende sollen es äquivalente Ausdrücke sein. Zwei Ausdrücke der relationalen Algebra heißen äquivalent, falls sie die gleichen Operanden (=Relationen) nutzt und für jede mögliche Instanz der Datenbank stets die gleiche Antwortrelation ausgibt.</p>
<figure class="align-default" id="id4">
<img alt="../_images/Ablauf-Anfragebearbeitung_3.png" src="../_images/Ablauf-Anfragebearbeitung_3.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.3 </span><span class="caption-text">Ablauf der Anfragebearbeitung - Transformation</span><a class="headerlink" href="#id4" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="kommutativitat-und-assoziativitat">
<h3><span class="section-number">5.3.1. </span>Kommutativität und Assoziativität<a class="headerlink" href="#kommutativitat-und-assoziativitat" title="Permalink to this heading">#</a></h3>
<p>Die Gesetze gelten jeweils für Mengen und Multimengen. Die verwendeten Ausdrücke können in beide Richtungen verwendet werden.</p>
<ul class="simple">
<li><p>? ist kommutativ und assoziativ</p>
<ul>
<li><p>R ? S = S ? R</p></li>
<li><p>(R ? S) ? T = R ? (S ? T)</p></li>
</ul>
</li>
<li><p>∪ ist kommutativ und assoziativ</p>
<ul>
<li><p>R ∪ S = S ∪ R</p></li>
<li><p>(R ∪ S) ∪ T = R ∪ (S ∪ T)</p></li>
</ul>
</li>
<li><p>∩ ist kommutativ und assoziativ</p>
<ul>
<li><p>R ∩ S = S ∩ R</p></li>
<li><p>(R ∩ S) ∩ T = R ∩ (S ∩ T)</p></li>
</ul>
</li>
<li><p>⨝ ist kommutativ und assoziativ</p>
<ul>
<li><p>R ⨝ S = S ⨝ R</p></li>
<li><p>(R ⨝ S) ⨝ T = R ⨝ (S ⨝ T)</p></li>
</ul>
</li>
</ul>
</section>
<section id="weitere-regeln">
<h3><span class="section-number">5.3.2. </span>Weitere Regeln<a class="headerlink" href="#weitere-regeln" title="Permalink to this heading">#</a></h3>
<p>Für Selektionen und Projektionen gelten die folgenden Regeln:</p>
<ul class="simple">
<li><p>Selektion σ</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(σ_{c_1 ∧ c_2}(R) = σ_{c_1}(σ_{c_2}(R))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(σ_{c_1 ∨ c_2}(R) = σ_{c_1}(R) ∪ σ_{c_2}(R)\)</span></p>
<ul>
<li><p>nicht bei Multimengen</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\( σ_{c_1}(σ_{c_2}(R)) = σ_{c_2}(σ_{c_1}(R))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\( σ_{c}(R Φ S) ≡ (σ_{c}(R)) Φ (σ_{c}(S))\)</span></p>
<ul>
<li><p>Φ ∈ {∪, ∩, -, ⨝}</p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\( σ_{c}(R Φ S) ≡ (σ_{c}(R)) Φ S\)</span></p>
<ul>
<li><p>Φ ∈ {∪, ∩, -, ⨝}</p></li>
<li><p>Falls sich c nur auf die Attribute in R bezieht.
</br></p></li>
</ul>
</li>
</ul>
</li>
<li><p>Projektion π</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(π_{L}(R ⨝ S) = π_{L}(π_{M}(R) ⨝ π_{N}(S))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(π_{L}(R ⨝_{C} S) = π_{L}(π_{M}(R) ⨝_{C} π_{N}(S))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(π_{L}(R × S) = π_{L}(π_{M}(R) × π_{N}(S))\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(π_{L}(σ_{c}(R)) = π_{L}(σ_{c}(π_{M}(R))\)</span></p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="logische-anfrageplane">
<h2><span class="section-number">5.4. </span>Logische Anfragepläne<a class="headerlink" href="#logische-anfrageplane" title="Permalink to this heading">#</a></h2>
<p>Um nun zu einem logischen Anfrageplan zu gelangen, benötigt es zwei Schritte.</p>
<figure class="align-default" id="id5">
<img alt="../_images/Ablauf-Anfragebearbeitung_4.png" src="../_images/Ablauf-Anfragebearbeitung_4.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.4 </span><span class="caption-text">Ablauf der Anfragebearbeitung - Logischer Anfrageplan</span><a class="headerlink" href="#id5" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="zwei-schritte">
<h3><span class="section-number">5.4.1. </span>Zwei Schritte<a class="headerlink" href="#zwei-schritte" title="Permalink to this heading">#</a></h3>
<p><strong>Schritt 1</strong></br>
In Schritt 1 wird der Parsebaum in einen Ausdruck der relationalen Algebra übersetzt und dann wieder als Baum dargestellt. Unter anderem werden auch Subanfragen aufgelöst. Letzteres wird aber nicht in dieser Vorlesung weiter thematisiert.
</br></p>
<p><strong>Schritt 2</strong></br>
Der Baum wird im zweitem Schritt gemäß der Transformationsregeln umgeformt. Man kann auch “Vor-Optimierungen” mittels Heuristiken durchführen. Dazu zählt unter Anderem:</p>
<ul class="simple">
<li><p>das Pushen von Selektionen,</p></li>
<li><p>das Einbauen und Pushen von Projektionen,</p></li>
<li><p>das Zusammenfügen von Selektion und Kreuzprodukt zu einem Join,</p></li>
<li><p>die Gruppierung von Vereinigungen und Joins,</p></li>
<li><p>und eventuell das Verschieben und Einbauen von Duplikateliminierungen.</p></li>
</ul>
</section>
<section id="beispiel-anfragebearbeitung">
<h3><span class="section-number">5.4.2. </span>Beispiel - Anfragebearbeitung<a class="headerlink" href="#beispiel-anfragebearbeitung" title="Permalink to this heading">#</a></h3>
<p>In diesem Beispiel ist ein Ausdruck der relationalen Algebra in einem Parsebaum dargestellt <em>(siehe Fig. 5.5)</em> . Die zugehörige SQL-Anfrage wäre</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">Nachname</span>
<span class="n">FROM</span> <span class="n">mitarbeiter</span> <span class="n">m</span><span class="p">,</span> <span class="n">projekte</span> <span class="n">p</span>
<span class="n">WHERE</span> <span class="n">p</span><span class="o">.</span><span class="n">Budget</span> <span class="o">&lt;</span> <span class="mi">40000</span>
<span class="n">AND</span> <span class="n">m</span><span class="o">.</span><span class="n">p_id</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">p_id</span><span class="p">;</span>
</pre></div>
</div>
<p>Man sollte damit beginnen das Kreuzprodukt mit der Selektion zu einem Join zu kombinieren.</p>
<figure class="align-default" id="anfragebearbeitung-beispiel-1">
<img alt="../_images/Anfragebearbeitung-Beispiel-1.png" src="../_images/Anfragebearbeitung-Beispiel-1.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.5 </span><span class="caption-text">Beispiel Parsebaum zur SQL-Anfrage - Schritt 1</span><a class="headerlink" href="#anfragebearbeitung-beispiel-1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Als nächstes sollte man versuchen die andere Selektion weiter nach unten zu pushen (Push-Down). Ziel ist es mit möglichst wenigen Tupeln in jedem Teilschritt zu arbeiten. Die gegebene Selektion kann direkt vor die Projekt-Relation geschoben werden.</p>
<figure class="align-default" id="anfragebearbeitung-beispiel-2">
<img alt="../_images/Anfragebearbeitung-Beispiel-2.png" src="../_images/Anfragebearbeitung-Beispiel-2.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.6 </span><span class="caption-text">Schrittt 2</span><a class="headerlink" href="#anfragebearbeitung-beispiel-2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>In einem weiterem Schritt können die benötigten Attribute aus den Ausgangsrelationen direkt rausprojiziert werden.</p>
<figure class="align-default" id="anfragebearbeitung-beispiel-3">
<img alt="../_images/Anfragebearbeitung-Beispiel-3.png" src="../_images/Anfragebearbeitung-Beispiel-3.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.7 </span><span class="caption-text">Schritt 3</span><a class="headerlink" href="#anfragebearbeitung-beispiel-3" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="ubergang-zum-physischen-anfrageplan">
<h3><span class="section-number">5.4.3. </span>Übergang zum Physischen Anfrageplan<a class="headerlink" href="#ubergang-zum-physischen-anfrageplan" title="Permalink to this heading">#</a></h3>
<p>Hierbei gibt es diverse Freiheitsgrade:</p>
<ol class="arabic simple">
<li><p>Die Reihenfolge und Gruppierung von assoziativen und kommutativen Operatoren können vertauscht werden. Das ist zum Beispiel der Fall bei Joins, Vereinigungen und Schnittmengen.</p></li>
<li><p>Für jeden Operator kann ein Algorithmus gewählt werden. Damit sind die aus dem vorherigen Kapitel kennengelernten Hash-basierten, Sort-basierten oder auch One-Pass Algorithmen gemeint.</p></li>
<li><p>Es können zusätzliche Operatoren (Sort und Projektion), die im logischen Plan selbst nicht auftauchen, hinzugefügt werden.</p></li>
<li><p>Außerdem kann der Modus des Datentransports zwischen den Operatoren gewählt werden. Modi wären eine temporäre Tabelle oder eine Pipeline mit Iterator.</p></li>
</ol>
<p>Dafür braucht man in jedem Fall zunächst eine Kostenabschätzung. Man möchte herausfinden, wann es sinnvoll ist, welche Operationsreihenfolgen zu nutzen und wie viel ein Plan gesamt kostet.</p>
</section>
</section>
<section id="kostenmodell">
<h2><span class="section-number">5.5. </span>Kostenmodell<a class="headerlink" href="#kostenmodell" title="Permalink to this heading">#</a></h2>
<p>Beim Kostenmodell werden die Kardinalitäten abgschätzt. Man möchte wissen wie viele Tupel es gibt und wie viele unterschiedliche Werte in den einzelnen Attributen einer Relation vorhanden sind.</p>
<figure class="align-default" id="ablauf-der-anfragebearbeitung-kardinalitaten-schatzen">
<img alt="../_images/Ablauf-Anfragebearbeitung_5.png" src="../_images/Ablauf-Anfragebearbeitung_5.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.8 </span><span class="caption-text">Ablauf der Anfragebearbeitung - Kardinalitäten schätzen</span><a class="headerlink" href="#ablauf-der-anfragebearbeitung-kardinalitaten-schatzen" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="kostenbasierte-optimierung-wiederholung">
<h3><span class="section-number">5.5.1. </span>Kostenbasierte Optimierung (Wiederholung)<a class="headerlink" href="#kostenbasierte-optimierung-wiederholung" title="Permalink to this heading">#</a></h3>
<p>Konzeptionell werden alle denkbaren Ausführungspläne generiert. Die Kosten für jeden Plan werden anhand eines Kostenmodells bewertet. Dazu werden Statistiken und Histogramme hinzugezogen. Die Parameter werden anhand der Rechnerarchitektur, auf der die Datenbank aufgesetzt ist, kalibriert. Die Optimierung ist abhängig vom verfügbaren Speicher. Dann wird anhand des Aufwands-Kostenmodell geschaut was und wie optimiert werden soll. Entweder Durchsatz maximierend oder nicht Antwortzeit-minimierend. Entsprechend wird der günstigste Plan ausgeführt. Wichtig ist, dass nicht zu lange optimiert wird, da sich sonst der ganze Aufwand nicht lohnen könnte.</p>
<figure class="align-default" id="timecost-meme">
<img alt="../_images/TimeCost-Meme.png" src="../_images/TimeCost-Meme.png" />
</figure>
</section>
<section id="problemgrosze-suchraum-wiederholung">
<h3><span class="section-number">5.5.2. </span>Problemgröße (Suchraum) (Wiederholung)<a class="headerlink" href="#problemgrosze-suchraum-wiederholung" title="Permalink to this heading">#</a></h3>
<p>Wie zuvor erwähnt, werden konzeptionell alle denkbaren Ausführungspläne generiert. Man berechnet nun die Bushy-Pläne mit n Tabellen. Bushy-Plan bedeutet, dass der Baum immer balanciert ist.</p>
<div class="math notranslate nohighlight">
\[\frac{(2(n-1))!}{(n-1)!}\]</div>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>n</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(2^n\)</span></p></th>
<th class="head"><p>n!</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(\frac{(2(n-1))!}{(n-1)!}\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>2</strong></p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p><strong>5</strong></p></td>
<td><p>32</p></td>
<td><p>120</p></td>
<td><p>1680</p></td>
</tr>
<tr class="row-even"><td><p><strong>10</strong></p></td>
<td><p>1024</p></td>
<td><p>3628800</p></td>
<td><p>1,76 · 10^10</p></td>
</tr>
<tr class="row-odd"><td><p><strong>20</strong></p></td>
<td><p>1048576</p></td>
<td><p>2,4 · 10^18</p></td>
<td><p>4,3 · 10^27</p></td>
</tr>
</tbody>
</table>
</br>
<p>Die Anzahl der Deep-Pläne mit n Tabellen ist n!. Die Plankosten unterscheiden sich um viele Größenordnungen. Das Optimierungsproblem ist NP-hard (NP-Schwer).
</br></p>
<p>Folie: Prof. Alfons Kemper, TU München.</p>
</section>
<section id="kostenmodell-wiederholung">
<h3><span class="section-number">5.5.3. </span>Kostenmodell (Wiederholung)<a class="headerlink" href="#kostenmodell-wiederholung" title="Permalink to this heading">#</a></h3>
<p>Gegeben ist ein algebraischer Ausdruck z.B. ein Anfrageplan. Das Kostenmodell <em>(siehe Fig. 5.9)</em> schätzt die Ausführungskosten für diesen Ausdruck. Im Kostenmodell werden Punkte wie die Indexinformationen, die Ballungs-Informationen (Clustering on disk), die DB-Kardinalitäten und die Attributverteilungen berücksichtigt.</p>
<figure class="align-default" id="id6">
<img alt="../_images/Kostenmodell.png" src="../_images/Kostenmodell.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.9 </span><span class="caption-text">Kostenmodell</span><a class="headerlink" href="#id6" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="statistiken-wiederholung">
<h3><span class="section-number">5.5.4. </span>Statistiken (Wiederholung)<a class="headerlink" href="#statistiken-wiederholung" title="Permalink to this heading">#</a></h3>
<p>Man kann unterschiedliche Statistiken für das Kostenmodell nutzen. Für die Statistiken kann man verschiedene Werte berücksichtigen. Zu jeder Basisrelation gibt es die Anzahl der tupel und die Größe der einzelnen Tupel.
Zu (jedem) Attribut gibt es den minimalen und maximalen Wert, eine Werteverteilung (Histogramm) und die Anzahl der distinct Werte. Zum System sind die Speichergröße, die Bandbreite, I/O- und CPU-Zeiten angegeben.
</br></p>
<p>Das eigentliche Problem ist das Erstellen und Updaten der Statistiken. Wenn man eine Datenbank hat, die sich sehr schnell immer wieder verändert, müssen die Statistiken dazu auch häufig neu erstellt werden (<code class="docutils literal notranslate"><span class="pre">runstats()</span></code>). Dies kostet weitere Ressourcen. Man sollte sich überlegen wie genau man die Statistiken haben möchte und dementsprechend viel Zeit in das Optimieren investieren. Aus diesem Grund initiiert man meist nur explizit/manuell die Erstellung und das Update der Statistiken.</p>
<figure class="align-default" id="histogram-of-arrvials">
<img alt="../_images/Statistiken-Histogram-of-arrivals.png" src="../_images/Statistiken-Histogram-of-arrivals.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.10 </span><span class="caption-text">Histogramm über die Ankünfte</span><a class="headerlink" href="#histogram-of-arrvials" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="kosten-von-operationen">
<h3><span class="section-number">5.5.5. </span>Kosten von Operationen<a class="headerlink" href="#kosten-von-operationen" title="Permalink to this heading">#</a></h3>
<p>Das wesentliche Kostenmerkmal bei Operationen ist die Anzahl der Tupel im Input. Insbesondere ist die Frage, ob die Relation in den Hauptspeicher passt und man darauf Operationen wie Selektion, Projektion, Sortierung und Join ausführen kann.  </br>
Der Output ist immer der Input des nächsten Operators. Deshalb schätzt ein Kostenmodell unter anderem für jede Operation die Anzahl der Ausgabetupel.
Zum Schätzen wird die „Selektivität“ in Bezug auf Inputgröße herangezogen. Sie gibt an wie viele Eingabetupel ein Operator herausselektiert und wie viele Ausgabetupel dann erwartet werden können. Es wird auch „Selektivitätsfaktor“ (selectivity factor, sf) genannt.</p>
<ul class="simple">
<li><p>#Ausgabetupel = #Eingabetupel x Selektivität</p></li>
</ul>
</section>
<section id="kostenschatzung-projektion">
<h3><span class="section-number">5.5.6. </span>Kostenschätzung - Projektion<a class="headerlink" href="#kostenschatzung-projektion" title="Permalink to this heading">#</a></h3>
<p>Die Größe des Zwischenergebnisses kann bei der Projektion exakt ausgerechnet werden. </br>
</br>
<strong>Beispiele</strong></br>
Gegeben ist eine Relation R(A integer(4), B integer(4), C varchar(100)) mit einem Tupelheader von 12 Byte.</p>
<p><strong>1:</strong></br>
Somit ergeben sich insgesamt 120 Byte pro Tupel. Ein Block besteht aus 1024 Byte mit einem 24 Byte Header. Also sind es 8 Tupel pro Block. </br>
Bei einer Relation R mit 10000 Tupeln: <span class="math notranslate nohighlight">\(T(R)\)</span> = 10000, kommt man bei 8 Tupeln pro Block, auf insgesamt 1250 Blöcke, die benötigt werden: <span class="math notranslate nohighlight">\(B(R)\)</span> = 1250.
</br></p>
<p><strong>2:</strong></br>
<span class="math notranslate nohighlight">\(Q_{1} = \pi_{A+B,C}(R)\)</span></br>
Daraus ergeben sich 116 Byte pro Tupel. Bei 8 Tupeln pro Block hat man wieder 1250 Blöcke pro Tupel: <span class="math notranslate nohighlight">\(B(Q_{1})\)</span> = 1250.
</br></p>
<p><strong>3:</strong></br>
<span class="math notranslate nohighlight">\(Q_{2} = \pi_{A,B}(R)\)</span> </br>
Man erhält 20 Byte pro Tupel. Insgesamt also 50 Tupel pro Block und <span class="math notranslate nohighlight">\(B(Q_{2})\)</span> = 200.</p>
</section>
<section id="kostenschatzung-selektion">
<h3><span class="section-number">5.5.7. </span>Kostenschätzung - Selektion<a class="headerlink" href="#kostenschatzung-selektion" title="Permalink to this heading">#</a></h3>
<p>Im Gegensatz zur Projektion bleibt zwar die Tupelgröße, aber die Anzahl der Tupel sinkt bei der Selektion. </br>
<span class="math notranslate nohighlight">\(Q=\sigma_{A=c}(R)\)</span> </br>
Die Formel zur Selektion zeigt einen Vergleich zwischen dem Attribut A und der Konstante c. Basierend auf Annahmen kann man die Anzahl der Ausgabetupel berechnen. Die erste Annahme ist, dass die Werte gleich verteilt sind. Die zweite, dass c einer dieser Werte ist. Zur Berechnung nutzt man die Formel <span class="math notranslate nohighlight">\(T(Q) = \frac{T(R)}{V(R,A)}\)</span>. <span class="math notranslate nohighlight">\(V(R,A)\)</span> ist die Anzahl der distinct Werte in Spalte A. D.h. der Selektivitäsfaktor ist <span class="math notranslate nohighlight">\(\frac{1}{V(R,A)}\)</span>. Bessere Abschätzungen sind mittels Histogrammen möglich.<br />
<br></p>
<p><span class="math notranslate nohighlight">\(Q=\sigma_{A&lt;c}(R)\)</span></br>
Der Vergleich der Selektion A &lt; c macht eine Bereichsabfrage. Es gibt Möglichkeiten dies genau abzuschätzen. Einfachheitshalber nutzen wir hier eine erste Abschätzung: <span class="math notranslate nohighlight">\(T(Q) = \frac{T(R)}{2}\)</span>. Typischer ist die Formel <span class="math notranslate nohighlight">\(T(Q) = \frac{T(R)}{3}\)</span>.
<br></p>
<p><span class="math notranslate nohighlight">\(Q=\sigma_{A \neq c}(R)\)</span></br>
Man möchte in der Selektion nicht die Attribute haben, die der Konstante c entsprechen. Eine erste einfache Abschätzung wäre es davon auszugehen, dass man (fast) alles zurückbekommt: <span class="math notranslate nohighlight">\(T(Q) = T(R)\)</span>. Etwas genauer ist stattdessen die Formel <span class="math notranslate nohighlight">\(T(Q) = \frac{T(R) · (V(R,A) - 1)}{V(R,A)}\)</span>. Sie ist sehr ähnlich zu der ersten Formel vom Vergleich (<span class="math notranslate nohighlight">\(Q=\sigma_{A=c}(R)\)</span>). Der Unterschied besteht darin, dass sie nicht alle Tupel zurückgibt, die gleich der Konstante sind, sondern genau das Gegenteil: Alle Tupel, die ungleich der Konstante sind.
</br></p>
<p>Hat man Konjunktionen bei mehreren Selektionsbedingungen, multipliziert man die Selektivitätsfaktoren. Die Annahme dafür ist die Unabhängigkeit der Bedingungen.</p>
</section>
<section id="selektivitat-schatzen">
<h3><span class="section-number">5.5.8. </span>Selektivität schätzen<a class="headerlink" href="#selektivitat-schatzen" title="Permalink to this heading">#</a></h3>
<p>In Abbildung 5.11 ist ein Auszug aus dem Werk für das System R von Selinger et al. aus dem Jahre 1979 zu sehen. Man sieht die Möglichkeiten zur Einschätzung der Selektivität. Beim Schätzen wird fast immer eine Gleichverteilung angenommen.</p>
<figure class="align-default" id="system-r">
<img alt="../_images/Selektivität-schätzen.png" src="../_images/Selektivität-schätzen.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.11 </span><span class="caption-text">Auszug aus dem Werk von Selinger et al.</span><a class="headerlink" href="#system-r" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="beispiel-fur-skew-zipf-verteilung">
<h3><span class="section-number">5.5.9. </span>Beispiel für Skew: Zipf-Verteilung<a class="headerlink" href="#beispiel-fur-skew-zipf-verteilung" title="Permalink to this heading">#</a></h3>
<figure class="align-default" id="george-kingsley-zipf">
<img alt="../_images/George-Kingsley-Zipf.png" src="../_images/George-Kingsley-Zipf.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.12 </span><span class="caption-text">George Kingsley Zipf</span><a class="headerlink" href="#george-kingsley-zipf" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Eine sehr bekannte Verteilung ist die Zipf-Verteilung von George Kingsley Zipf (1902 - 1950). Sie modelliert Worthäufigkeiten in den Texten einer Sprache. Die Wörter werden nach ihren Häufigkeiten sortiert. Die Häufigkeit des häufigsten Wortes sei dabei h. Wenn alles sortiert ist kann man beispielsweise für den i-ten Wert die Häufigkeit berechnen. Der i-te Wert tauch dann genau <span class="math notranslate nohighlight">\(\frac{h}{i^{\frac{1}{2}}}\)</span> mal auf. Der zughörige Graph sieht wie folgt aus:</p>
<figure class="align-default" id="skew-graph">
<img alt="../_images/Beispiel-Skew-Graph.png" src="../_images/Beispiel-Skew-Graph.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.13 </span><span class="caption-text">Skew Graph</span><a class="headerlink" href="#skew-graph" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Wenige Werte kommen sehr häufig vor, die vielen anderen Werte kommen hingegen sehr selten vor. Anhand der Verteilung könnte man nun probieren die Kardinalitätsabschätzung anzupassen. Dennoch sollte es eher gelassen werden. Die durchschnittliche Antwortkardinalität bleibt weiter <span class="math notranslate nohighlight">\(\frac{T(R)}{V(R,A)}\)</span>. Durch die Annahme, dass Konstanten in Selektionsbedingungen gleichverteilt gewählt werden, kann es bei der Zipf-Verteilung der Konstanten zu einer Unterschätzung kommen.</p>
<p>Abbildung 5.14 zeigt das Prinzip von Zipf’s law. Außerdem ist es unabhängig von der jeweils gewählten Sprache.</p>
<figure class="align-default" id="zipfs-law">
<img alt="../_images/Zipfs-law.png" src="../_images/Zipfs-law.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.14 </span><span class="caption-text">Zipfs Law</span><a class="headerlink" href="#zipfs-law" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>A plot of the rank versus frequency for the first 10 million words in 30 Wikipedias (dumps from October 2015) in a <a class="reference external" href="https://en.wikipedia.org/wiki/Log%E2%80%93log_plot">log-log</a> scale.</p>
</section>
<section id="id7">
<h3><span class="section-number">5.5.10. </span>Kostenschätzung - Selektion<a class="headerlink" href="#id7" title="Permalink to this heading">#</a></h3>
<p><strong>Beispiele</strong></br>
Gegeben ist eine Relation R mit <span class="math notranslate nohighlight">\(T(R) = 10000\)</span> und <span class="math notranslate nohighlight">\(V(R,A) = 50\)</span>.
</br></p>
<p><strong>1:</strong></br>
<span class="math notranslate nohighlight">\(Q = \sigma_{A=10 ∧ B&lt;20}(R)\)</span></br>
Die Ausgabetupel werden geschätzt mit <span class="math notranslate nohighlight">\(T(Q) = 10000 · \frac{1}{50} · \frac{1}{3} = 67\)</span>.
</br></p>
<p><strong>2:</strong></br>
<span class="math notranslate nohighlight">\(Q = \sigma_{A=10 ∧ A&gt;20}(R)\)</span></br>
Im ersten Moment würde man die Ausgabetupel mit <span class="math notranslate nohighlight">\(T(Q) = 10000 · \frac{1}{50} · \frac{1}{3} = 67\)</span> schätzen. Bei genauerer Betrachtung fällt auf, dass die Bedingung so nicht möglich ist. Das Attribut kann gleichzeitig nicht genau 10 und über 20 sein. Besser ist die Abschätzung <span class="math notranslate nohighlight">\(T(Q) = 0\)</span>. Ein Optimierer sollte solche Fälle erkennen.
</br></p>
</section>
<section id="kostenschatzung-selektion-mit-disjunktion">
<h3><span class="section-number">5.5.11. </span>Kostenschätzung - Selektion mit Disjunktion<a class="headerlink" href="#kostenschatzung-selektion-mit-disjunktion" title="Permalink to this heading">#</a></h3>
<p><span class="math notranslate nohighlight">\(Q = \sigma_{C_1 ∨ C_2}(R2)\)</span></br></p>
<p><strong>Idee 1</strong></br>
Bilde die Summe der Ergebniskardinalitäten mit der Annahme, dass kein Tupel beide Bedingungen erfüllt. Dennoch kann es dazu führen, dass das Ergebnis größer als die Ursprungsrelation ist: <span class="math notranslate nohighlight">\(T(Q) &gt; T(R)\)</span>.
</br></p>
<p><strong>Idee 2</strong></br>
Daher könnte man nun das Minimum unter der Anzahl der Tupel in R und der Summe der Ergebniskardinalitäten wählen: <span class="math notranslate nohighlight">\(min[T(R), Summe der Ergebniskardinalitäten]\)</span>. Es ist keine perfekte Lösung, aber ein erster Versuch sich näher an das richtige Ergebnis heranzutasten.
</br></p>
<p><strong>Idee 3</strong></br>
Nutze die Wahrscheinlichkeitstheorie mit der Annahme, dass <span class="math notranslate nohighlight">\(C_1\)</span> und <span class="math notranslate nohighlight">\(C_2\)</span> unabhängig voneinander sind. Sei</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T(R) = n\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{C_1}(R)) = m_{1}\)</span> und</p></li>
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{C_2}(R)) = m_{2}\)</span>.</p></li>
</ul>
<p>Daraus ergibt sich
<span class="math notranslate nohighlight">\(T(Q) = n(1-(1-\frac{m_{1}}{n})(1-\frac{m_{2}}{n}))\)</span>. Wobei der Term <span class="math notranslate nohighlight">\((1-\frac{m_{1}}{n})\)</span> den Anteil der Tupel, die nicht <span class="math notranslate nohighlight">\(C_1\)</span> entsprechen, beschreibt. Der zweite ähnliche Term <span class="math notranslate nohighlight">\((1-\frac{m_{2}}{n})\)</span> beschreibt den Anteil der Tupel, die nicht <span class="math notranslate nohighlight">\(C_2\)</span> entsprechen.
</br></p>
<p><strong>Beispiel</strong></br>
Sei die Selektion <span class="math notranslate nohighlight">\(Q = \sigma_{A=10 ∨ B&lt;20}(R)\)</span> gegeben. Bilde zunächst wie in Idee 1 beschrieben von separat die Ergebniskardinalitäten beider Bedingungen und addiere beide anschließend:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{A=10}(R)) = \frac{T(R)}{V(R,A)} = \frac{10000}{50} = 200\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{B&lt;20}(R)) = \frac{T(R)}{3} = 3333\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T(Q) = 200 + 3333 = 3533\)</span></p></li>
</ul>
<p>Eine bessere Schätzung wäre mit Idee 3 möglich:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T(R) = 10000\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{A=10}(R)) = 200\)</span> und</p></li>
<li><p><span class="math notranslate nohighlight">\(T(\sigma_{B&lt;20}(R)) = 3333\)</span>.</p></li>
</ul>
<p>Setzt man diese Werte in die Formel der Wahrscheinlichkeitstheorie ein, erhält man als Ergebnis 3466:
<span class="math notranslate nohighlight">\(T(Q) = n(1-(1-\frac{m_{1}}{n})(1-\frac{m_{2}}{n})) = 10000 (1-(1-\frac{200}{10000})(1-\frac{3333}{10000}))\)</span></p>
<p>Die Formel kann deutlich vereinfacht werden <span class="math notranslate nohighlight">\(m_{1} + m_{2} - n (\frac{m_{1}}{n} · \frac{m_{2}}{n})\)</span></br>
<span class="math notranslate nohighlight">\(= 200 + 3333 - 10000(\frac{200}{10000} · \frac{3333}{10000})\)</span></br>
<span class="math notranslate nohighlight">\(= 3533 - (\frac{666600}{10000})\)</span></br>
<span class="math notranslate nohighlight">\(= 3533 - 67\)</span></br>
<span class="math notranslate nohighlight">\(= 3466\)</span></br></p>
</section>
<section id="kostenschatzung-join">
<h3><span class="section-number">5.5.12. </span>Kostenschätzung - Join<a class="headerlink" href="#kostenschatzung-join" title="Permalink to this heading">#</a></h3>
<p>In dieser Vorlesung betrachten wir nur den Natural Join. Das Verfahren beim Equijoin wäre analog dazu. Ein Thetajoin mit “&lt;”, “&gt;” usw. wird wie zuvor geschätzt. Zum Beispiel mit <span class="math notranslate nohighlight">\(\frac{1}{3} T(R) · \frac{1}{3} T(S)\)</span>.</br></p>
<p><span class="math notranslate nohighlight">\(R(X,Y) \Join S(Y,Z)\)</span></br>
Vereinfachend wird hier angenommen, dass wir nur über ein Attribut Y joinen. Ein Problem ist die Beziehung zwischen R.Y und S.Y. Man weiß nicht wie viele Elemente aus R.Y auch in S.Y auftauchen. Theoretisch kann man sagen, dass es disjunkte Mengen und nichts gleich ist. Damit würde man bei einem Join 0 Elemente erhalten: <span class="math notranslate nohighlight">\(T(R \Join S) = 0\)</span>. Eine weitere Möglichkeit wäre eine Fremdschlüsselbeziehung (mit einem Schlüssel in S). Dann wäre das Resultat die Menge an Tupeln in R: <span class="math notranslate nohighlight">\(T(R \Join S) = T(R)\)</span>. Es gibt noch eine dritte Möglichkeit, wenn man davon ausgeht, dass fast alles gleiche Werte sind: <span class="math notranslate nohighlight">\(T(R \Join S) = T(R) · T(S)\)</span>. </br></p>
<p>Es müssen also wieder ein paar Annahmen getroffen werden.
Die erste Annahme sagt, dass die Werte eines Attributs, das in mehreren Relationen auftaucht, vom Beginn einer Liste gewählt wird. Das ist das sogenannte <strong>Containment of Value Sets</strong>. Falls also die Distinct-Werte der Relation R kleiner gleich den Distinct-Werten der anderen Relation S sind (<span class="math notranslate nohighlight">\(V(R,Y) \leq V(S,Y)\)</span>), dann taucht jeder Y-Wert in R auch in S auf. </br>
Die zweite Annahme besagt, dass die Anzahl der Distinct-Werte eines nicht-Joinattributs erhalten bleiben: <span class="math notranslate nohighlight">\(V(R \Join S, X) = V(R,X)\)</span>. Auch <strong>Preservation of Value Sets</strong> genannt. Es ist realistisch, wenn von Gleichverteilung ausgegangen wird. Insbesondere, wenn die Relation S eine Fremdschlüsselbeziehung hat. Der einzige Fall bei dem es nicht mehr korrekt sein könnte ist, wenn das X ein Schlüssel ist.</br>
</br></p>
<p>Sei <span class="math notranslate nohighlight">\(V(R,Y) \leq V(S,Y)\)</span>, dann gilt:</p>
<ul class="simple">
<li><p>jedes Tupel aus R hat eine <span class="math notranslate nohighlight">\(\frac{1}{V(S,Y)}\)</span> Chance, mit einem gegebenen S-Tupel zu joinen.</p></li>
<li><p>(da <span class="math notranslate nohighlight">\(T(S)\)</span> S-Tupel): Ein Tupel aus R hat <span class="math notranslate nohighlight">\(T(S) · \frac{1}{V(S,Y)}\)</span> Joinpartner in S.</p></li>
<li><p>(da <span class="math notranslate nohighlight">\(T(R)\)</span> R-Tupel): <span class="math notranslate nohighlight">\(T(R \Join S) = \frac{T(R) · T(S)} {V(S,Y)}\)</span>.
</br></p></li>
</ul>
<p>Falls <span class="math notranslate nohighlight">\(V(R,Y) \leq V(S,Y)\)</span>, dann gilt <span class="math notranslate nohighlight">\(T(R \Join S) = \frac{T(R) · T(S)}{V(R,Y)}\)</span>. </br>
</br></p>
<p>Allgemein gilt: <span class="math notranslate nohighlight">\(T(R \Join S) = \frac{T(R) · T(S)}{max[V(R,Y), V(S,Y)]}\)</span>.
</br></p>
</section>
<section id="kostenschatzung-join-beispiel">
<h3><span class="section-number">5.5.13. </span>Kostenschätzung - Join Beispiel<a class="headerlink" href="#kostenschatzung-join-beispiel" title="Permalink to this heading">#</a></h3>
<p>Seien Joins zwischen drei Relationen gegeben:</br>
<span class="math notranslate nohighlight">\(R(A,B) \Join S(B,C) \Join U(C,D)\)</span>.</br></p>
<p>Die Anzahl der Tupel der Relationen ist wie folgt:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T(R) = 1.000\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T(S) = 2.000\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T(U) = 5.000\)</span></p></li>
</ul>
<p>Die Selektionsfaktoren sind</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(V(R,B) = 20\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(V(S,B)= 50\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(V(S,C) = 100\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(V(U,C)=500\)</span></p></li>
</ul>
<p>Die Joins werden in der Reihenfolge <span class="math notranslate nohighlight">\((R \Join S) \Join U\)</span> betrachtet.
Daher kann man zunächst <span class="math notranslate nohighlight">\(T(R \Join S)\)</span> berechnen:
<span class="math notranslate nohighlight">\(T(R \Join S) = \frac{T(R) · T(S)}{max[V(R,B),V(S,B)]} = \frac{1.000 · 2.000}{50} = 40.000\)</span> </br>
Aber man kann die Relation U auch direkt hinzujoin/heranmultiplizieren: <span class="math notranslate nohighlight">\(T(R \Join S \Join U) = \frac{T(R \Join S) · T(U)} {max[V(R \Join S, C), V(U, C)]} = \frac{40.000 · 5.000}{ max[100, 500]} = 400.000\)</span> </br></p>
<p>Zur Probe können Sie <span class="math notranslate nohighlight">\(T(R \Join (S \Join U))\)</span> nachrechnen.</p>
<details>
  <summary><strong>Lösung</strong></summary>
    Auch wenn man zuerst die anderen Relationen miteinander joint, erhält man wieder das Selbe Ergebnis: 400000. 
</details>
</section>
<section id="kostenschatzung-join-mehrere-attribute">
<h3><span class="section-number">5.5.14. </span>Kostenschätzung Join - Mehrere Attribute<a class="headerlink" href="#kostenschatzung-join-mehrere-attribute" title="Permalink to this heading">#</a></h3>
<p><span class="math notranslate nohighlight">\(R(X,Y) \Join S(Y,Z)\)</span></br></p>
<p>Y enthält nun mehr als ein Attribut. Die Schreibweise ist hier: <span class="math notranslate nohighlight">\(R(X,Y1,Y2) \Join S(Y1,Y2,Z)\)</span></br>
Die Ergebniskardinalität von <span class="math notranslate nohighlight">\(R \Join S\)</span> entspricht dem Produkt der Kardinalitäten von R und S, dividiert durch das Produkt des jeweils größeren von V(R,Y) und V(S,Y) für jedes Join-Attribut Y: <span class="math notranslate nohighlight">\(T(R \Join S) = \frac{T(R) · T(S)}{( max[V(R,Y1),V(S,Y1)] · max[V(R,Y2),V(S,Y2)]) }\)</span></p>
</section>
<section id="kostenschatzung-mehrfacher-join">
<h3><span class="section-number">5.5.15. </span>Kostenschätzung - Mehrfacher Join<a class="headerlink" href="#kostenschatzung-mehrfacher-join" title="Permalink to this heading">#</a></h3>
<p>Im allgemeinen Fall <span class="math notranslate nohighlight">\( S = R_{1} \Join R_{2} \Join ... \Join R_{n} \)</span> wird in diesem Fall über das selbe Attribut A gejoint. Notiert wird es mit <span class="math notranslate nohighlight">\(V(R_{i}, A) = v_{i}\)</span>. Das Attribut A erscheint in k Relationen. Es gilt <span class="math notranslate nohighlight">\(v_{1} \leq v_{2} \leq ... \leq v_{k}\)</span> mit <span class="math notranslate nohighlight">\( k \leq n \)</span>. Die Frage ist nun wie die Kardinalität des Ergebnisses berechnet wird.</br>
Dazu eine kleine Gedankenhilfe:
Gegeben ist ein Tupel aus jeder der k Relationen. Gesucht wird die Wahrscheinlichkeit, dass alle im A-Wert übereinstimmen. Es gibt wieder das Containment of Value Sets: Jeder A-Wert von Tupeln aus <span class="math notranslate nohighlight">\(R_{1}\)</span> taucht in den anderen Relationen auf. Ein Tupel aus <span class="math notranslate nohighlight">\(R_{i}\)</span> hat eine Wahrscheinlichkeit von <span class="math notranslate nohighlight">\(\frac{1}{v_{i}}\)</span> mit einem gegebenen Tupel aus <span class="math notranslate nohighlight">\(R_{1}\)</span> übereinzustimmen. Zusammen ergibt sich <span class="math notranslate nohighlight">\(\frac{1}{v_{2} · v_{3} · … · v_{k}}\)</span>. Die Wahrscheinlichkeiten der einzelnen Tupel der verschiedenen Relationen müssen nur multipliziert werden. </br>
Für das Gesamtvorgehen ist der Ausgangspunkt also das Produkt aller Kardinalitäten zu bilden. Betrachtet man die Selektivität muss für jedes Attribut, das mehr als einmal auftaucht, durch das Produkt aller <span class="math notranslate nohighlight">\(v_{i}\)</span> bis auf das kleinste (<span class="math notranslate nohighlight">\(v_{1}\)</span> dividiert werden.</p>
<p><strong>Beispiel</strong></br></p>
<ul class="simple">
<li><p>Die Anfrage ist <span class="math notranslate nohighlight">\(R(A,B,C) \Join S(B,C,D) \Join U(B,E)\)</span>.</p></li>
<li><p>Die Kardinalitäten sind</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(T(R) = 1000\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(T(S) = 2000\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(T(U) = 5000\)</span>.</p></li>
</ul>
</li>
<li><p>Die DISTINCT Werte sind</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(V(R,B): 20\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(V(R,C): 200\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(V(S,B): 50\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(V(S,C): 100\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(V(U,B): 200\)</span>.</p></li>
</ul>
</li>
</ul>
<p>Vorgehen: Zunächst zählt man alle (Tupel-)Kombinationen der Relationen auf: <span class="math notranslate nohighlight">\(1000 · 2000 · 5000 = 10.000.000.000\)</span>. Dann werden die Wahrscheinlichkeiten für gemeinsame Attribute multipliziert. Die Relation B hat drei- und die Relation <span class="math notranslate nohighlight">\(C\)</span> hat zweimal gemeinsame Attribute. Für B ergibt sich: <span class="math notranslate nohighlight">\(\frac{1}{50} · \frac{1}{200}\)</span>. Für <span class="math notranslate nohighlight">\(C\)</span> wiederrum: <span class="math notranslate nohighlight">\(\frac{1}{200}\)</span>.
Zusammen ergibt sich: </br>
<span class="math notranslate nohighlight">\(\frac{10.000.000.000}{(50 · 200 · 200)}\)</span></br>
<span class="math notranslate nohighlight">\(= \frac{10.000.000.000}{2.000.000}\)</span></br>
<span class="math notranslate nohighlight">\(= 5.000\)</span></p>
</section>
<section id="kostenschatzung-weitere-operationen">
<h3><span class="section-number">5.5.16. </span>Kostenschätzung - Weitere Operationen<a class="headerlink" href="#kostenschatzung-weitere-operationen" title="Permalink to this heading">#</a></h3>
<p><strong>Vereinigung</strong> <span class="math notranslate nohighlight">\((R \cup S)\)</span></br>
Bei einer Multimenge bildet man die Summe der Inputs. Bei einer normalen Menge wählt man eine Vereinigung der Relationen, die größer ist als die größte Relation und kleiner als die Summe der Tupel aller Relationen: <span class="math notranslate nohighlight">\(max[T(R), T(S)] \leq T(R \cup S) \leq T(R) + T(S)\)</span>. Z.B könnte man auch den Durchschnitt von Maximum und Summe berechnen: <span class="math notranslate nohighlight">\(AVG[T(R) + T(S), max[T(R), T(S)]]\)</span>.</p>
<p><strong>Schnittmenge</strong> <span class="math notranslate nohighlight">\((R \cap S)\)</span></br>
Die Schnittmenge der Relationen muss größer als 0, aber noch kleiner als die kleinste Relation sein: <span class="math notranslate nohighlight">\(0 ≤ T(R \cap S) \leq min[T(R), T(S)]\)</span>. Die erste Idee zur Vereinfachung ist es die kleinste Relation zu halbieren: <span class="math notranslate nohighlight">\(\frac{min[T(R), T(S)]}{2}\)</span>. Die zweite Idee ist es, es als Join aufzufassen. Dabei kommt es häufig zu einer extremen Unterschätzung.</p>
<p><strong>Differenz</strong></br>
Die Differenz muss kleiner als die anfängliche Relation und größer als das Maximum von 0 und der Differenz der Anzahl der Tupel der Relationen: <span class="math notranslate nohighlight">\(max[0,T(R) - T(S)] \leq T(R - S) \leq T(R)\)</span>. Hier wählt man z.B. eine Mitte mit <span class="math notranslate nohighlight">\(max[0, T(R) – \frac{T(S)}{2}]\)</span>.</p>
<p><strong>Duplikateliminierung</strong></br>
<span class="math notranslate nohighlight">\(T(\delta(R)) = V(R, [A_{1}, ..., A_{n}])\)</span>. Die Anzahl der Tupel muss kleiner gleich der Anzahl der Ausgangsrelation sein. Es darf natürlich nicht weniger als ein Tupel vorhanden sein: <span class="math notranslate nohighlight">\(1 \leq T(\delta(R)) \leq T(R)\)</span>. Man kann auch die Distinct-Werte miteinander multiplizieren <span class="math notranslate nohighlight">\(T(\delta(R)) \leq \prod_{i} V(R, A_{i})\)</span>. Z.B. kann dafür auch <span class="math notranslate nohighlight">\(T(\delta(R)) = min[\frac{T(R)}{2}, \prod_{i} V(R, A_{i})]\)</span> genutzt werden.</p>
<p><strong>Gruppierung und Aggregation</strong></br>
Die Anzahl der Tupel muss auf jeden Fall kleiner gleich der Anzahl der Tupel in der Ausgangsrelation sein, aber dennoch muss es mindestens ein Tupel geben: <span class="math notranslate nohighlight">\(1 \leq T(\gamma_{L}(R)) \leq T(R)\)</span>.
Falls nur ein Gruppierungsattribut gibt, gilt: <span class="math notranslate nohighlight">\(T(\gamma_{L}(R)) \leq V(R,L)\)</span>
Falls mehrere es mehrere gibt muss multipliziert werden: <span class="math notranslate nohighlight">\(T(\gamma_{L}(R)) \leq \prod_{i} V(R, L_{i})\)</span>. Man kann auch die Formel <span class="math notranslate nohighlight">\(T(\gamma_{L}(R)) = min[\frac{T(R)}{10}, \prod_{i} V(R, A_{i})]\)</span> nutzen.</p>
</section>
</section>
<section id="histogramme">
<h2><span class="section-number">5.6. </span>Histogramme<a class="headerlink" href="#histogramme" title="Permalink to this heading">#</a></h2>
<p>Für genauere Berechnung werden Histogramme verwendet. Nun ist nicht mehr nur die Kardinalität bekannt, sondern auch die Verteilung der Werte.</p>
<section id="id8">
<h3><span class="section-number">5.6.1. </span>Ablauf der Anfragebearbeitung<a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h3>
<p>Im Ablauf befinden sich die Histogramme im Bereich der Kostenschätzung.</p>
<figure class="align-default" id="id9">
<img alt="../_images/Ablauf-Anfragebearbeitung_6.png" src="../_images/Ablauf-Anfragebearbeitung_6.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.15 </span><span class="caption-text">Ablauf der Anfragebearbeitung - Kosten schätzen</span><a class="headerlink" href="#id9" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="schatzung-der-statistiken">
<h3><span class="section-number">5.6.2. </span>Schätzung der Statistiken<a class="headerlink" href="#schatzung-der-statistiken" title="Permalink to this heading">#</a></h3>
<p>Statistiken sind notwendig, um die Größe von Zwischenergebnissen zu berechnen, insbesondere <span class="math notranslate nohighlight">\(T(R)\)</span> und <span class="math notranslate nohighlight">\(V(R,A)\)</span>. Statistiken werden auf Befehl des Administrators eingeholt. Zum Beispiel wird <span class="math notranslate nohighlight">\(T(R)\)</span> mittels Scan von R. <span class="math notranslate nohighlight">\(V(R,A)\)</span> kann mittels einer der vorigen Algorithmen ermittelt werden. Das ist ähnlich wie bei der Gruppierung auch separat für jedes Attribut. <span class="math notranslate nohighlight">\(B(R)\)</span> wird gezählt, falls <span class="math notranslate nohighlight">\(R\)</span> nicht clustered gespeichert ist. Falls es geclustered ist, dann wird <span class="math notranslate nohighlight">\(\frac{T(R)}{Tupel \ pro \ Block}\)</span> berechnet.</p>
</section>
<section id="schatzung-der-statistiken-histogramme">
<h3><span class="section-number">5.6.3. </span>Schätzung der Statistiken - Histogramme<a class="headerlink" href="#schatzung-der-statistiken-histogramme" title="Permalink to this heading">#</a></h3>
<p>Histogramme stellen speichereffizient Werteverteilungen dar. Die Idee ist es, Gruppen von Werten (zusammenhängende Wertebereiche) in Buckets zusammenzufassen. Varianten von Buckets wären Equal-width und Equal-height. In den Buckets geht Genauigkeit verloren, weswegen man zusätzlich Häufigkeiten für die häufigsten Werte speichern kann.
Pro Bucket wird die durchschnittliche Anzahl der Tupel pro Einzel-Wert gespeichert. D.h. man nimmt innerhalb des Buckets eine Gleichverteilung an.
<strong>Vorteile</strong> sind geringere Schätzfehler, da Verteilungsannahmen nur in kleineren Bereichen getroffen werden. Außerdem ist der Speicherverbrauch durch das Zusammenfassen in Gruppen geringer.
Bei <strong>Design und Wartung</strong> bleiben ein paar Fragen offen:</p>
<ul class="simple">
<li><p>Wie werden Bucketgrenzen bestimmt?</p></li>
<li><p>Was wird pro Bucket gespeichert?</p></li>
<li><p>Wie werden Histogramme aktuell gehalten?</p></li>
</ul>
</section>
<section id="verteilungen-korpergewicht">
<h3><span class="section-number">5.6.4. </span>Verteilungen - Körpergewicht<a class="headerlink" href="#verteilungen-korpergewicht" title="Permalink to this heading">#</a></h3>
<p>In der Grafik sind Verteilungen zum Körpergewicht dargestellt. Die <strong>Normalverteilung</strong> hat einen Wertebereich von 120-40=80. Ihr Mittelwert beträgt 80 und die Standardabweichung (stddev) ist 12. Es betrifft 100.000 Personen.
Bei der <strong>Gleichverteilung</strong> wird angenommen, dass jede Gewichtsklasse mit der gleichen Häufigkeit auftaucht. Somit sind es <span class="math notranslate nohighlight">\(\frac{100.000}{80}=1250\)</span> Personen für jede Gewichtsklasse. Die Gleichverteilung ist somit in fast jedem Bereich fehleranfällig.
Die einzigen genauen Punkte sind die Schnittpunkte der beiden Verteilungen. An den anderen Stellen kommt es zu groben Fehlschätzungen.</p>
<figure class="align-default" id="id10">
<img alt="../_images/Verteilungen-Körpergewicht.png" src="../_images/Verteilungen-Körpergewicht.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.16 </span><span class="caption-text">Histogramm zur Körpergewichtsverteilung</span><a class="headerlink" href="#id10" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="equi-width-histogramme">
<h3><span class="section-number">5.6.5. </span>Equi-Width Histogramme<a class="headerlink" href="#equi-width-histogramme" title="Permalink to this heading">#</a></h3>
<p>Etwas besser ist es, eine feste Anzahl an Buckets mit jeweils gleicher Breite zu erstellen. Der Vorteil ist, dass die Grenzen nicht mitgespeichert werden müssen. Der Startpunkt und die Breite genügen. Es wird eine Gleichverteilung in jedem Bucket angenommen. Ein Histogramm kann mittels eines Scans von R berechnet werden. Quellen für Schätzfehler sind zu wenige Buckets und, wenn sich die Werteverteilung innerhalb der Buckets stark unterscheidet.</p>
<figure class="align-default" id="id11">
<img alt="../_images/Equi-Width-Histogramme.png" src="../_images/Equi-Width-Histogramme.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.17 </span><span class="caption-text">Equi-Width-Histogramm</span><a class="headerlink" href="#id11" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="equi-height-histogramme">
<h3><span class="section-number">5.6.6. </span>Equi-Height-Histogramme<a class="headerlink" href="#equi-height-histogramme" title="Permalink to this heading">#</a></h3>
<p>Eine andere Variation ist das Equi-Height Histogramm. Auch bekannt als Equi-depth-Histogramme bzw. Perzentile. Nun probiert man, dass innerhalb eines Buckets sehr ähnliche Werte gespeichert werden. Es gibt eine feste Anzahl an Buckets. Zum Beispiel 10 Stück für 10%, 20%, usw. Die Bucketgrenzen werden so gewählt, dass jedes Bucket ungefähr die gleiche Anzahl an Tupeln enthält. Hier sind es 10.000 Personen pro Bucket. Die Bucketgrenzen müssen gespeichert werden. Die Berechnung der Histogramme erfolgt durch Sortierung und gleichgroße Sprünge.</p>
<figure class="align-default" id="id12">
<img alt="../_images/Equi-Height-Histogramme.png" src="../_images/Equi-Height-Histogramme.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.18 </span><span class="caption-text">Equi-Height-Histogramm</span><a class="headerlink" href="#id12" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="histogramme-zur-schatzung-fur-joins">
<h3><span class="section-number">5.6.7. </span>Histogramme zur Schätzung für Joins<a class="headerlink" href="#histogramme-zur-schatzung-fur-joins" title="Permalink to this heading">#</a></h3>
<p>Die Schätzung pro Wertebereich erfolgt mit <span class="math notranslate nohighlight">\(\frac{Histo1 · Histo2}{Breite}\)</span>. Besonders interessant sind die Wertebereiche von 40-49 und 50-59, da sowohl im Januar, als auch im Juli ein jeweils ein Wert steht: <span class="math notranslate nohighlight">\(\frac{10·5}{10} + \frac{5·20}{10} = 5 + 10 = 15\)</span>. Insgesamt sind es also 15 gemessene Werte. </br>
Gibt es kein Histogramm, dann muss eine herkömmliche Schätzung gemacht werden. Man wüsste, dass es 245 Tupel mit gleichverteilten Temperaturen pro Relation gibt. Die Berechnung für den Join ist dann <span class="math notranslate nohighlight">\(\frac{245·245}{100} = 600 \ Tupel\)</span>.
</br></p>
<p>Eine neue <strong>Variante</strong> ist es, die Histogramme jeweils die 3 häufigsten Werte auflisten und den Rest gruppieren zu lassen. Besonders ist es für z.B. Zipf-verteilte Daten geeignet.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Wertebereich Temperator °F</p></th>
<th class="head"><p>Januar</p></th>
<th class="head"><p>Juli</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0-9</p></td>
<td><p>40</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>10-19</p></td>
<td><p>60</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>20-29</p></td>
<td><p>80</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>30-39</p></td>
<td><p>50</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>40-49</p></td>
<td><p>10</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>50-59</p></td>
<td><p>5</p></td>
<td><p>20</p></td>
</tr>
<tr class="row-even"><td><p>60-69</p></td>
<td><p>0</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-odd"><td><p>70-79</p></td>
<td><p>0</p></td>
<td><p>100</p></td>
</tr>
<tr class="row-even"><td><p>80-89</p></td>
<td><p>0</p></td>
<td><p>60</p></td>
</tr>
<tr class="row-odd"><td><p>90-99</p></td>
<td><p>0</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">Januar</span><span class="o">.</span><span class="n">Tag</span><span class="p">,</span> <span class="n">Juli</span><span class="o">.</span><span class="n">Tag</span>
<span class="n">FROM</span> <span class="n">Januar</span><span class="p">,</span> <span class="n">Juli</span>
<span class="n">WHERE</span> <span class="n">Januar</span><span class="o">.</span><span class="n">temp</span> <span class="o">=</span> <span class="n">Juli</span><span class="o">.</span><span class="n">temp</span>
</pre></div>
</div>
<p><strong>Beispiel</strong></p>
<p>Die Anfrage ist <span class="math notranslate nohighlight">\(R(A,B) \Join S(B,C)\)</span>.</br>
Das Histogramm für <span class="math notranslate nohighlight">\(R.B\)</span> ist</p>
<ul class="simple">
<li><p>1: 200;</p></li>
<li><p>0:150;</p></li>
<li><p>5: 100;</p></li>
<li><p>Rest: 550.</p></li>
</ul>
<p>Das Histogramm für <span class="math notranslate nohighlight">\(S.B\)</span> ist
0: 100;</p>
<ul class="simple">
<li><p>1: 80;</p></li>
<li><p>2: 70;</p></li>
<li><p>Rest: 250.</p></li>
</ul>
<p>Insgesamt gibt es in <span class="math notranslate nohighlight">\(R\)</span> 14 und in <span class="math notranslate nohighlight">\(S\)</span> 13 unterschiedlich Werte: <span class="math notranslate nohighlight">\(V(R,B) = 14\)</span> und <span class="math notranslate nohighlight">\(V(S,B) = 13\)</span>. Die Resttupel in <span class="math notranslate nohighlight">\(R\)</span> (550 Tupel) haben somit 11 verschiedene Werte bei einer Annahme von je 50 Tupeln. Die Resttupel in <span class="math notranslate nohighlight">\(S\)</span> (250 Tupel) haben 10 verschiedene Werte bei einer Annahme von je 25 Tupeln. </br>
Man kann eine genaue Schätzung für die Werte 0 und 1 von <span class="math notranslate nohighlight">\(B\)</span> machen: <span class="math notranslate nohighlight">\(150·100 + 200·80=31000\)</span>. Der Wert „2“ kommt geschätzt 50 mal in <span class="math notranslate nohighlight">\(R\)</span> und 70 mal in <span class="math notranslate nohighlight">\(S\)</span> vor: <span class="math notranslate nohighlight">\(50 · 70 = 3500\)</span>. Insgesamt also 3500 Tupel. Der Wert „5“ kommt geschätzt 25 mal in <span class="math notranslate nohighlight">\(S\)</span> und 100 mal in <span class="math notranslate nohighlight">\(R\)</span> vor: <span class="math notranslate nohighlight">\(100 · 25 = 2500\)</span>. Für 9 weitere gemeinsame Werte in <span class="math notranslate nohighlight">\(R\)</span> und <span class="math notranslate nohighlight">\(S\)</span> ergibt sich dann: <span class="math notranslate nohighlight">\(9 · (50 · 25) = 11250\)</span>.</p>
</section>
<section id="erhebung-von-statistiken">
<h3><span class="section-number">5.6.8. </span>Erhebung von Statistiken<a class="headerlink" href="#erhebung-von-statistiken" title="Permalink to this heading">#</a></h3>
<p>Die Statistiken können nicht dauernd aktuell gehalten werden. Sie werden nur periodisch erhoben werden. Statistiken ändern sich nicht laufend und auch nicht radikal. Auch falsche Statistiken funktionieren, wenn sie konsistent angewendet werden.
Statistiken sollen selbst nicht zu einem hot-spot werden. Sie sollen nicht dauernd geändert werden, da sie oft gelesen werden.
Die Erhebung wird durch unterschiedliche Trigger ausgelöst. Sie kann regelmäßig bzw. periodisch ausgeführt werden oder nach einer festen Menge an Updates ausgelöst werden. Möglich wäre auch eine Erhebung, falls Schätzungen während der Anfrageausführung als zu ungenau erkannt werden. Außerdem kann sie auch durch einen Administrator ausgelöst werden. </br>
Die Berechnung der Statistiken ist sehr aufwändig. Ein Grund, warum sie nicht andauernd aktuell gehalten werden. Eine Lösung, um den Aufwand zu reduzieren ist es, Sampling zu nutzen. Man nimmt eine Teilmenge der Daten und erhebt darauf Statistiken. Sampling wird hier aber nicht weiter vertieft.</p>
</section>
</section>
<section id="joinreihenfolge">
<h2><span class="section-number">5.7. </span>Joinreihenfolge<a class="headerlink" href="#joinreihenfolge" title="Permalink to this heading">#</a></h2>
<section id="enumeration-physischer-anfrageplane">
<h3><span class="section-number">5.7.1. </span>Enumeration Physischer Anfragepläne<a class="headerlink" href="#enumeration-physischer-anfrageplane" title="Permalink to this heading">#</a></h3>
<p>Die erste Idee wäre es, eine <strong>vollständige Enumeration</strong> entlang aller Freiheitsgrade durchzuführen. Die Reihenfolge und die Gruppierung von assoziativen und kommutativen Operatoren kann abgeändert werden. Außerdem lässt sich der Algorithmus für jeden Operator und der Modus des Datentransports zwischen den Operatoren frei wählen.
Zu jedem Anfrageplan wird ein Kostenplan berechnet und daraus der Plan mit den geringsten Kosten ausgewählt. Durch das Ausführen einer vollständigen Enumeration enstehen zu viele Anfragepläne. Beispielsweise werden Abschnitte in den Plänen mehrfach berechnet. Die Anzahl der Pläne muss reduziert werden. Daher werden diverse bessere Methoden wie die Heuristische Auswahl, Branch-and-Bound, Hill-Climbing und Dynamische Programmierung/Selinger-Style Optimization verwendet.</p>
</section>
<section id="heuristische-auswahl">
<h3><span class="section-number">5.7.2. </span>Heuristische Auswahl<a class="headerlink" href="#heuristische-auswahl" title="Permalink to this heading">#</a></h3>
<p>Bei der Heuristischen Auswahl soll eine Sequenz bekannter Heuristiken angewendet werden, wie zum Beispiel ein Greedy-Verfahren für die Joinreihenfolge:</p>
<ol class="arabic simple">
<li><p>Wähle zuerst das Joinpaar mit dem kleinstem Zwischenergebnis.</p></li>
<li><p>Joine die Relation hinzu, die wiederum das kleinste Zwischenergebnis erzeugt.</p></li>
<li><p>usw.</p></li>
</ol>
<p>Weitere Heuristiken wären unter Anderem:</p>
<ul class="simple">
<li><p>Falls eine Selektion und ein Index auf ein Selektionsattribut gegeben sind, sollte man den Index-Scan wählen.</p></li>
<li><p>Führe mehrere Selektionen auf der selben Relation zugleich aus.</p></li>
<li><p>Falls der Index auf dem Joinattribut ist, soll ein Index-Join gewählt werden.</p></li>
<li><p>Falls ein Joininput sortiert ist, soll man den Sort-Merge-Join wählen, sofern kein Index vorhanden ist.</p></li>
</ul>
</section>
<section id="branch-and-bound">
<h3><span class="section-number">5.7.3. </span>Branch and Bound<a class="headerlink" href="#branch-and-bound" title="Permalink to this heading">#</a></h3>
<p>Eine weitere Idee ist Branch and Bound. Heuristiken werden zum Finden eines ersten guten Plans verwendet. Die Kosten des ersten guten Plans bilden sowohl eine obere Schranke für alle anderen Pläne, als auch für die Teilpläne. Für diverse Teile der Anfrage werden Pläne enumeriert. Es wird versucht einen Teil der Anfrage zu verbessern. Teilpläne, die mehr als die Schranke kosten, werden verworfen. Wenn ein besserer Gesamtplan gefunden wird, wird die Schranke gesenkt. Der Vorteil von Branch and Bound ist, dass die Optimierung jederzeit abgebrochen werden kann.</p>
</section>
<section id="hill-climbing">
<h3><span class="section-number">5.7.4. </span>Hill-Climbing<a class="headerlink" href="#hill-climbing" title="Permalink to this heading">#</a></h3>
<p>Hill Climbing beschreibt wie man einen ersten guten Plan mittels Heuristiken findet.
Dazu werden schrittweise ähnliche Pläne mit niedrigeren Kosten gesucht. Unter ähnlich versteht man hier, dass sich ein anderer Plan nur um eine Änderung unterscheidet. Sobald kein ähnlicher Plan mehr besser ist, ist das Verfahren fertig.
Der Nachteil von Hill-Climbing ist, dass es sich um ein Lokales Optimum handelt. Global hätte es eventuell noch einen besseren Plan gegeben. Ein globales Optimum zu finden benötigt zu viel Zeit. </br>
Es gibt verschiedene Varianten, um das Verfahren zu verbessern. Zum Einem das Iterative Improvement bei dem mit 10 verschiedenen Startplänen losgelegt wird. Zum Anderen das Simulated Annealing bei dem auch Verschlechterungen zugelassen werden.</p>
</section>
<section id="dynamische-programmierung-selinger-style-optimierung">
<h3><span class="section-number">5.7.5. </span>Dynamische Programmierung &amp; Selinger-style Optimierung<a class="headerlink" href="#dynamische-programmierung-selinger-style-optimierung" title="Permalink to this heading">#</a></h3>
<p>Ein Verfahren zur Berechnung ist die Dynamische Programmierung.
Es wird jeweils der beste Teilplan gesucht und verwendet, um einen höheren Teilplan zu bauen. Der Baum wird von unten nach oben (bottom-up) durchlaufen. </br>
Selinger hat die Dynamische Programmierung erweitert und abgeändert (Selinger-Style). Es wird nicht nur der beste Plan, sondern auch verschiedene, interessante Sortiervarianten (interesting order) gemerkt. Die Kosten einiger Pläne dürfen höher sein, sofern sie andere Vorteile mit sich bringen. Das Verfahren beeinflusst nicht die Kardinalitäten von Zwischenergebnissen, sondern die I/O-Kosten.</p>
</section>
<section id="richard-bellman">
<h3><span class="section-number">5.7.6. </span>Richard Bellman<a class="headerlink" href="#richard-bellman" title="Permalink to this heading">#</a></h3>
<figure class="align-default" id="id13">
<img alt="../_images/Richard-Bellman.png" src="../_images/Richard-Bellman.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.19 </span><span class="caption-text">Richard Bellmann</span><a class="headerlink" href="#id13" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Ein kurzer Exkurs zur Historie der Dynamischen Programmierung und dessen Erfinder. Richard Bellman (1920 - 1984) erhielt seinen PhD in Princeton. Er arbeitete unter Anderem von 1944 bis 1946 in Los Alamos.
Während Bellman bei der Rand Corporation arbeitete, erfand er 1953 die Dynamische Programmierung.
Zur Mathematik hat er viele Beiträge zugesteuert wie z.B. den Bellman-Ford Algorithmus:
Ein Algorithmus zum Berechnen aller kürzesten Wege für einen Startknoten.</p>
</section>
<section id="dp-fur-knapsack-problem">
<h3><span class="section-number">5.7.7. </span>DP für Knapsack Problem<a class="headerlink" href="#dp-fur-knapsack-problem" title="Permalink to this heading">#</a></h3>
<p>Bei dem Knapsack Problem ist ein Rucksack mit begrenzten Gewicht gegeben. In den Rucksack möchte man möglichst gute Items ablegen. Die Items haben ein Gewicht und einen Nutzen. Das Gewicht des Rucksacks soll nicht überschritten werden.</p>
<p>Ein Beispiel zur Problemformulierung:</p>
<blockquote>
<div><p>I can carry 15 KG at most.</br>
How can I maximize my damage (dps)?</p>
</div></blockquote>
</br>
<a class="reference internal image-reference" href="../_images/Knapsack.png"><img alt="Knapsack" src="../_images/Knapsack.png" style="width: 1000px;" /></a>
</section>
<section id="beispiel-knapsack-mit-dp">
<h3><span class="section-number">5.7.8. </span>Beispiel: Knapsack mit DP<a class="headerlink" href="#beispiel-knapsack-mit-dp" title="Permalink to this heading">#</a></h3>
<p>Die Lösung des Problems wird durch einen Rückwärtslauf ermittelt. Durch eine Tabelle <em>(siehe Fig. 5.20)</em> werden nach und nach Items ausgewählt. Die Kapazität wird fortlaufend notiert und berechnet. Das Resultat ist der maximale Nutzen.</p>
<figure class="align-default" id="knapsack-mit-dp">
<img alt="../_images/Knapsack-mit-DP.png" src="../_images/Knapsack-mit-DP.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.20 </span><span class="caption-text">Knapsack Tabelle</span><a class="headerlink" href="#knapsack-mit-dp" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="dp-traveling-salesman-problem">
<h3><span class="section-number">5.7.9. </span>DP: Traveling Salesman Problem<a class="headerlink" href="#dp-traveling-salesman-problem" title="Permalink to this heading">#</a></h3>
<p>Ein ähnliches Verfahren wird beim Traveling Salesman Problem verwendet <em>(siehe Fig. 5.21)</em> . Beim Traveling Salesman Problem sollen alle Städte besucht werden, ohne einen Pfad mehrmals zu betreten. Gesucht ist der kürzeste Pfad, der es ermöglicht.</p>
<figure class="align-default" id="traveling-salesman-problem">
<img alt="../_images/DP-Traveling-Salesman-Problem.png" src="../_images/DP-Traveling-Salesman-Problem.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.21 </span><span class="caption-text">Traveling-Salesman-Problem</span><a class="headerlink" href="#traveling-salesman-problem" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="dynamic-programming-heldkarp-algorithmus">
<h3><span class="section-number">5.7.10. </span>Dynamic Programming (Held–Karp Algorithmus)<a class="headerlink" href="#dynamic-programming-heldkarp-algorithmus" title="Permalink to this heading">#</a></h3>
<p>Zunächst wird a als Anfangs- und Endpunkt betrachtet. Für alle anderen Knoten i wird der Pfad mit den Minimalkosten von a nach i, welcher alle anderen Knoten enthält, gesucht. Sei <span class="math notranslate nohighlight">\(cost(i)\)</span> definiert als Kosten des Pfades. <span class="math notranslate nohighlight">\(cost(i) + dist(i, a)\)</span> entspricht dann der Rundreise mit <span class="math notranslate nohighlight">\(dist(i, a)\)</span> als Distanz von i nach a. Das Ergebnis ist das Minimum der <span class="math notranslate nohighlight">\([cost(i) + dist(i, a)]\)</span> Pfade.</br>
Mittels DP wird <span class="math notranslate nohighlight">\(cost(i)\)</span> berechnet:
Sei <span class="math notranslate nohighlight">\(C(S, i)\)</span> die Minimalkosten für ein Pfad von a nach i, der jeden Knoten in <span class="math notranslate nohighlight">\(S\)</span> genau
einmal besucht. Gestartet wird mit allen Teilmengen <span class="math notranslate nohighlight">\(S\)</span> der Größe 2. Für diese werden <span class="math notranslate nohighlight">\(C(S, i)\)</span> berechnet. Im nächsten Schritt werden Stufenweise die Teilmengen der Größe 3, 4 u.s.w. betrachtet.</p>
<a class="reference internal image-reference" href="../_images/Dynamic-Programming.png"><img alt="Dynamic-Programming" src="../_images/Dynamic-Programming.png" style="width: 200px;" /></a>
<p><br> <br></p>
<ol class="arabic simple">
<li><p>Für <span class="math notranslate nohighlight">\(|S| = 2\)</span> gilt: <span class="math notranslate nohighlight">\(S ={a, i}\)</span> und <span class="math notranslate nohighlight">\(C(S, i) = dist(a, i)\)</span>.</p></li>
<li><p>Für <span class="math notranslate nohighlight">\(|S| &gt; 2\)</span> gilt:  <span class="math notranslate nohighlight">\(C(S, i) = min{ C(S-\{i\}, j) + dist(j, i)}\)</span>, wenn <span class="math notranslate nohighlight">\(j \neq i\)</span> und <span class="math notranslate nohighlight">\(j \neq a\)</span>.</p></li>
</ol>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(C(\{a,b\},b) = 3\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,c\} ,c) = 4\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,d\} ,d) = 2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,e\} ,e) = 7\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,c\},c) = min\{C(\{a,b\},b)+dist(b,c)\}=3+4=7\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,d\},d) = min\{C(\{a,b\},b)+dist(b,d)\}=3+6=9\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,e\},e) = min\{C(\{a,b\},e)+dist(b,e)\}=3+3=6\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,c\},b) = min\{C(\{a,c\},c)+dist(c,b)\}=4+4=8\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,d\},b) = min\{C(\{a,d\},d)+dist(d,b)\}=2+6=8\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(...\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(C(\{a,b,c,d\},c) = min\{C(\{a,b,d\},d)+dist(d,c), C(\{a,b,d\},b)+dist(b,c)\}=min\{9+5,8+4\}=12\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(...\)</span></p></li>
</ul>
<p>Die Komplexität ist mit <span class="math notranslate nohighlight">\(O(n^{2}2^{n})\)</span> immernoch sehr hoch, aber vieles muss nicht mehr doppelt berechnet werden. Das Verfahren ist zwar besser als Backtracking aber noch zu schwer.</p>
</section>
<section id="dynamische-programmierung">
<h3><span class="section-number">5.7.11. </span>Dynamische Programmierung<a class="headerlink" href="#dynamische-programmierung" title="Permalink to this heading">#</a></h3>
<p>Die Dynamische Programmierung ist ein Optimaler Algorithmus. Schwierigkeiten dabei sind die Annahmen. Zum Einen muss das Prinzip der Optimalität gelten. Ein optimaler Teilplan führt immer zu einem optimalen Gesamtplan. Zum Anderen muss das Problem geschickt in Teilprobleme aufgeteilt werden. Der Aufwand kann zwar immernoch exponentiell sein, aber es können sich Operationen und Verdopplungen gespart werden.
Klassische Anwendungen für die Dynamische Programmierung sind das Knapsack Problem, das Traveling Salesman Problem, die Maschinenbelegung und das Transportproblem.</p>
</section>
<section id="anwendung-fur-left-deep-baume">
<h3><span class="section-number">5.7.12. </span>Anwendung für Left-Deep Bäume<a class="headerlink" href="#anwendung-fur-left-deep-baume" title="Permalink to this heading">#</a></h3>
</section>
<section id="anfrageplanung">
<h3><span class="section-number">5.7.13. </span>Anfrageplanung<a class="headerlink" href="#anfrageplanung" title="Permalink to this heading">#</a></h3>
<p>Bei der heuristischen Einschränkung des Suchraums gibt es bei den Anfragen keine Kreuzprodukte. Diese werden aussortiert, da sie für einen erhöhten Ressourcenverbrauch und lange Ausführungszeiten verantwortlich sein können. Das gilt nicht bei expliziten Kreuzprodukten in der Anfrage. Die Selektionsbedingungen sollen so früh wie möglich eingesetzt werden.
Betrachtet werden nur links-tiefe (left-deep) Bäume. Es wird nie die parallele Ausführung von Joins betrachtet. Es wird immer davon ausgegangen, dass ein Join nach dem anderen ausgeführt wird.</p>
<figure class="align-default" id="id14">
<img alt="../_images/Anfrageplanung.png" src="../_images/Anfrageplanung.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.22 </span><span class="caption-text">Unterschiedliche Bäume bei der Anfrageplanung</span><a class="headerlink" href="#id14" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="anfragebearbeitung-optimierung">
<h3><span class="section-number">5.7.14. </span>Anfragebearbeitung – Optimierung<a class="headerlink" href="#anfragebearbeitung-optimierung" title="Permalink to this heading">#</a></h3>
<p>Bei der Optimierung wird nur die Joinreihenfolge und nicht die Parallelität betrachtet. Bei mehr-Prozessor Systemen wiederrum wird nicht nur die Reihenfolge, sondern auch die Parallelisierung berücksichtigt. Bei verteilten System kommen noch die Speicherorte der Zwischenergebnisse hinzu. Der Join ist i.d.R. der teuerste Operator.
Die Optimierung konzentriert sich auf die beste Reihenfolge. Ziel sind möglichst geringe Zwischenkosten.
Weitere Optimierungsschritte, wie das Schieben der Selektionen nach unten, werden später angewandt.
Bei n Relationen gibt es <span class="math notranslate nohighlight">\(n!\)</span> Alternativen, aber meistens enthalten die Alternativen ein kartesisches Produkt.</p>
</section>
<section id="dynamische-programmierung-optimierung-im-system-r">
<h3><span class="section-number">5.7.15. </span>Dynamische Programmierung: Optimierung im System-R<a class="headerlink" href="#dynamische-programmierung-optimierung-im-system-r" title="Permalink to this heading">#</a></h3>
<figure class="align-default" id="selinger">
<img alt="../_images/Selinger.png" src="../_images/Selinger.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.23 </span><span class="caption-text">Patricia Selinger</span><a class="headerlink" href="#selinger" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Das Verfahren von Selinger ist auch bekannt unter dem Namen: “Selinger-style query optimization”. Selinger ist eine Pionierin im Bereich von Datenbanksystemen. Ein klassischer Artikel zur Anfrageoptimierung ist [SAC+79]. Ursprünglich wurde das Verfahren bei IBM im System-R eingesetzt und ist heutzutage weit verbreitet.
</br></br>
Die Grundidee der Optimierung ist es, nur “Left-deep” Anfragebäume zu verwenden. D.h. nur die Joinreihenfolge ist von Bedeutung. Die innere und die äußere Relation bleibt unberücksichtigt.
Anfragepläne werden durch dynamische Programmierung (DP) von unten nach oben (bottom-up) generiert.
Zusätzlich sind auch interesting orders (interessante Sortierungen) und interesting sites (interessante Ausführungsorte) wichtig, werden aber in anderen Veranstaltungen behandelt.</p>
<figure class="align-default" id="accesspathselection-ibm">
<img alt="../_images/AccessPathSelection-IBM.png" src="../_images/AccessPathSelection-IBM.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.24 </span><span class="caption-text">Paper der IBM Research Division zu “Access Path Selection in a Relational Database Management System.”</span><a class="headerlink" href="#accesspathselection-ibm" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="bottom-up-anfrageplangenerierung">
<h3><span class="section-number">5.7.16. </span>Bottom-up Anfrageplangenerierung<a class="headerlink" href="#bottom-up-anfrageplangenerierung" title="Permalink to this heading">#</a></h3>
<p>Bei der Bottom-up Anfrageplangenerierung müssen zunächst zwei Annahmen getroffen werden.
Bei der ersten Annahme ist nach dem Join über k Relationen die Wahl der Join-Methode die k+1te Relation hinzuzujoinen unabhängig von den vorigen Join-Methoden.
von den vorigen Join-Methoden. Joinmethoden sind unter Anderem Nested Loops, Hashjoin, Sort-Merge Join usw.</br>
Bei der zweiten Annahme wird angenommen, dass jeder Teilplan eines optimalen Plans ebenfalls optimal ist. Dies entspricht dem <strong>Prinzip der Optimalität</strong>.
Wenn sich zwei Pläne nur in einem Teilplan unterscheiden, so ist der Plan mit dem besseren Teilplan auch der bessere Gesamtplan. </br>
Die <strong>Bottom-up Anfrageplangenerierung</strong> berechnet die optimalen Pläne für den Join über (jede Kombination von) k Relationen. Dabei werden die suboptimale Pläne verworfen. Alle anderen Pläne werden zu optimalen Plänen für k+1 Relationen erweitert (usw. bis k = n).</p>
</section>
<section id="id15">
<h3><span class="section-number">5.7.17. </span>Dynamische Programmierung<a class="headerlink" href="#id15" title="Permalink to this heading">#</a></h3>
<p>Begonnen wird in der Dynamischen Programmierung bei der leeren Menge. Danach werden die Relationen <span class="math notranslate nohighlight">\((R, S, T, U)\)</span> einzeln und in Kombination miteinander betrachtet bis man eine Kombination aller möglichen Relationen erhält <span class="math notranslate nohighlight">\((R,S,T,U)\)</span>.</p>
<figure class="align-default" id="id16">
<img alt="../_images/Dynamische-Programmierung.png" src="../_images/Dynamische-Programmierung.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.25 </span><span class="caption-text">Dynamische Programmierung</span><a class="headerlink" href="#id16" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="dp-grundidee-fur-anfrageoptimierung">
<h3><span class="section-number">5.7.18. </span>DP – Grundidee für Anfrageoptimierung<a class="headerlink" href="#dp-grundidee-fur-anfrageoptimierung" title="Permalink to this heading">#</a></h3>
<p>Für jede Kombination der verschiedenen Relationen muss man sich in einer Hilfstabelle die geschätzte Größe des Ergebnisses (Kardinalität) und die geschätzten minimalen Kosten notieren. Hier wird zur Vereinfachung die Größe des Zwischenergebnisses gemerkt. Die Joinreihenfolge, die diese Kosten verursacht entspricht dem optimalen Teilplan. </br>
</br>
Es wird eine Induktion über die Anzahl der Relationen im Plan durchgeführt.
Beginnend bei <span class="math notranslate nohighlight">\(N=1\)</span> wird für jede Relation die Kardinalität notiert. Sie ist gleich der Kardinalität der Relation. Ein weiterer Punkt sind die Kosten. Sie sind im ersten Schritt (zur Vereinfachung) gleich 0, da noch kein Join ausgeführt wurde. Die Joinreihenfolge ist n/a, da in diesem Schritt nur einzelne Relationen betrachtet werden.
Ist <span class="math notranslate nohighlight">\(N=2\)</span> wird für jedes Relationenpaar wie <span class="math notranslate nohighlight">\(R, S\)</span> die Kardinalität mit <span class="math notranslate nohighlight">\(Kardinalität = |R| \times |S| \times sf\)</span> berechnet. Die Kosten bleiben weiterhin bei 0, weil noch immernoch kein Join ausgeführt wurde. Für die Joinreihenfolge ist noch zu beachten, dass die kleinere Relation links ist. Der Clou dabei ist, dass <span class="math notranslate nohighlight">\(R\)</span> und <span class="math notranslate nohighlight">\(S\)</span> jeweils mit besten access-path gejoint werden.
Für <span class="math notranslate nohighlight">\(N=3\)</span> wird jedes Tripel <span class="math notranslate nohighlight">\(R, S, T\)</span> betrachtet. Der Clou ist, dass nur das beste Relationenpaar aus dem Tripel um eine dritte Relation ergänzt wird.</p>
</section>
<section id="dp-beispiel">
<h3><span class="section-number">5.7.19. </span>DP – Beispiel<a class="headerlink" href="#dp-beispiel" title="Permalink to this heading">#</a></h3>
<figure class="align-default" id="id17">
<img alt="../_images/DP-Beispiel.png" src="../_images/DP-Beispiel.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.26 </span><span class="caption-text">Dynamische Programmierung - Beispiel</span><a class="headerlink" href="#id17" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Im Beispiel <em>(siehe Fig. 5.26)</em> wird eine Anfrage über die vier Relationen <span class="math notranslate nohighlight">\(R, S, T, U\)</span> gestellt.
Es gibt vier Join-Bedingungen. In der Tabelle werden Kardinalität, Kosten und der optimale Plan festgehalten. Im ersten Schritt <em>(siehe Fig. 5.27)</em> ist der optimale Plan ein Scan der jeweiligen Relation.</p>
<figure class="align-default" id="id18">
<img alt="../_images/DP-Beispiel_2.png" src="../_images/DP-Beispiel_2.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.27 </span><span class="caption-text">DP Schritt 1</span><a class="headerlink" href="#id18" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Zwischen den Relationen, die kein Joinattribut haben, muss ein Kreuzprodukt gebildet werden. Das wäre der Fall bei <span class="math notranslate nohighlight">\(S, T\)</span> und <span class="math notranslate nohighlight">\(T, R\)</span>. Die Kreuzprodukte werden im weiteren Verlauf nicht weiter berücksichtigt. Alle anderen Kombinationen an Relationen werden über die jeweiligen Joinattriubte miteinander gejoint. </br>
Um Joins mit drei Relationen zu bilden, müssen die Joins zwischen zwei Relationen mit den günstigsten Kardinalitäten ausgewählt werden. Für die Kombination {<span class="math notranslate nohighlight">\({R, S, T}\)</span>} würden {<span class="math notranslate nohighlight">\({R, S}\)</span>}, {<span class="math notranslate nohighlight">\({R, T}\)</span>} und {<span class="math notranslate nohighlight">\({S, T}\)</span>} in Frage kommen. Da aber {<span class="math notranslate nohighlight">\({R, T}\)</span>} eine sehr hohe Kardnalität hat und auch vorher bereits aussortiert wurde, wählt man die anderen beiden: {<span class="math notranslate nohighlight">\({R, S}\)</span>} und {<span class="math notranslate nohighlight">\({S, T}\)</span>}. Die Kosten sind dann die Kardinalität der günstigeren Relationen. In dem Fall {<span class="math notranslate nohighlight">\({S, T}\)</span>} mit 2000.</p>
<figure class="align-default" id="id19">
<img alt="../_images/DP-Beispiel_3.png" src="../_images/DP-Beispiel_3.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.28 </span><span class="caption-text">DP Schritt 2 und 3</span><a class="headerlink" href="#id19" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Zum Schluss <em>(siehe Fig. 5.29)</em> berechnet man die Summe aus Kardinalität und Kosten. Somit ist der Joinplan mit Kosten von 3000 der optimale Plan.</p>
<figure class="align-default" id="id20">
<img alt="../_images/DP-Beispiel_4.png" src="../_images/DP-Beispiel_4.png" />
<figcaption>
<p><span class="caption-number">Fig. 5.29 </span><span class="caption-text">DP Letzter Schritt</span><a class="headerlink" href="#id20" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="dp-interesting-orders-interessante-sortierung">
<h3><span class="section-number">5.7.20. </span>DP - interesting orders (Interessante Sortierung)<a class="headerlink" href="#dp-interesting-orders-interessante-sortierung" title="Permalink to this heading">#</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prinzip der Optimalität: Wenn sich zwei Pläne nur in einem Teilplan unterscheiden, so ist der Plan mit dem besseren Teilplan immer vorzuziehen.</p>
</div>
<p>Ein Gegenbeispiel zu dem Prinzip der Optimalität ist das Beispiel mit dem Plan <span class="math notranslate nohighlight">\(R(A,B) \Join S(A,C) \Join T(A,D)\)</span>. Der beste lokale Plan für <span class="math notranslate nohighlight">\(R \Join S\)</span> ist ein Hash-Join. Aber für den globalen Plan wäre zunächst ein Sort-merge Join über R und S
und dann ein Sort-merge Join mit T besser geeignet. </br>
Der Grund dafür ist, dass das Zwischenergebnis von <span class="math notranslate nohighlight">\(R \Join _{sort-merge} S\)</span> nach dem Join-Attribut A sortiert ist. Dies ist eine sogenannte <strong>interesting order</strong>, die später ausgenutzt werden kann durch:</p>
<ul class="simple">
<li><p>Spätere sort-merge Joins</p></li>
<li><p>Gruppierung (<code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code>)</p></li>
<li><p>Sortierung (<code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code>)</p></li>
<li><p>Eindeutige Tupel (<code class="docutils literal notranslate"><span class="pre">DISTINCT</span></code>)</p></li>
</ul>
<p>Bei der Auswahl des besten Teilplans genügt ein Kostenvergleich nicht, da es keine vollständige Ordnung der Teilpläne nach Kosten gibt. Auch Sortierungen müssen hierbei berücksichtigt werden. </br>
Gelöst wird das Problem, indem man für jede Kombination von Relationen, mehrere Sortiervarianten speichert. Das kann nach jeder Variante der beteiligten Teilpläne sein. Die “leere” Sortierung ist der Ausgangspunkt. Also die Variante, die der anfänglichen Sortierung entspricht. Die ursprünglichen DP Tabellen werden somit immer größer, da jede Kombination noch unterschiedliche Joinvarianten beinhaltet. </br>
Das Kostenmodell muss auch verfeinert werden. Es werden echte I/O Kosten, statt der Größe des Zwischenergebnisses, genommen. Außerdem werden die Join- und Sortieroperationen (der Plan), die diese Sortierung erzeugen, gemerkt.</p>
</section>
<section id="dp-algorithmus">
<h3><span class="section-number">5.7.21. </span>DP – Algorithmus<a class="headerlink" href="#dp-algorithmus" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/DP-Algorithmus.png"><img alt="DP-Algorithmus" src="../_images/DP-Algorithmus.png" style="width: 500px;" /></a>
<p>Ein DP Algorithmus kann beispielsweise wie der aus dem Paper <a class="reference external" href="http://dx.doi.org/10.1145/371578.371598">The state of the art in distributed query processing</a> von Donald Kossmann ausehen.</p>
</section>
</section>
<section id="physische-anfrageplane">
<h2><span class="section-number">5.8. </span>Physische Anfragepläne<a class="headerlink" href="#physische-anfrageplane" title="Permalink to this heading">#</a></h2>
<p>Bei den Physischen Anfrageplänen müssen noch einige letzte Schritte vollführt werden.
Dazu gehört die Wahl des jeweiligen Algorithmus, wenn das nicht schon zuvor (z.B. bei DP) geschehen ist. Hier werden nur beispielhaft Selektions- und Joinmethoden angeschnitten. Außerdem muss zwischen Pipelining und Blocking, sowie die Zugriffsmethoden für Relationen gewählt werden.</p>
<section id="wahl-der-selektionsmethode">
<h3><span class="section-number">5.8.1. </span>Wahl der Selektionsmethode<a class="headerlink" href="#wahl-der-selektionsmethode" title="Permalink to this heading">#</a></h3>
<p>Zuvor wurden schon zwei Varianten behandelt. Bei der Ersten muss R ganz gelesen und die Selektionsbedingung auf jedes Tupel angewendet werden. Bei der zweiten Variante wird über den Index zugegriffen, falls der Index auf dem Selektionsattribut vorhanden ist. Die Voraussetzungen dafür sind die Index- und Gleichheitsbedingung. </br>
</br>
Jetzt wird eine Verallgemeinerung auf mehrere Selektionen auf verschiedenen Attributen betrachtet. Sowohl mit, als auch ohne Index. Bei Gleichheit oder eben auch bei Ungleichheit (<span class="math notranslate nohighlight">\(&lt;\)</span>, <span class="math notranslate nohighlight">\(&gt;\)</span>, <span class="math notranslate nohighlight">\(\leq\)</span>, <span class="math notranslate nohighlight">\(\geq\)</span>, <span class="math notranslate nohighlight">\(\neq\)</span>). </br>
</br>
Es muss eine Annahme vorweg gelten: Mindestens eine Selektionsbedingung kann einen Index verwenden. </br>
Das Vorgehen mit Indizes (jeweils viele Alternativen hierzu) beginnt mit dem Ermitteln der Schnittmenge der Pointermengen unter Verwendung von Indizes. Dann werden die Tupel eingelesen (Index-scan). Darauf wird ein „Filter“-Operator angewandt, der alle übrigen Bedingungen prüft.</br>
Beim Vorgehen ohne Indizes wird zunächst ein Table-scan für ganz R ausgeführt. Es wird dann ein Filter-Operator für alle Bedingungen angewandt. Der Filter-Operator findet nur im Hauptspeicher statt, sodass dieser keine Kosten verursacht.</p>
</section>
<section id="kostenvergleich-der-selektionsmethoden">
<h3><span class="section-number">5.8.2. </span>Kostenvergleich der Selektionsmethoden<a class="headerlink" href="#kostenvergleich-der-selektionsmethoden" title="Permalink to this heading">#</a></h3>
<p>Bisher wurde die Kostenschätzung durch die Schätzung der Ergebnisgröße durchgeführt, also durch die Kardinalität des Zwischenergebnisses. Jetzt werden nur Implementierungsvarianten mit jeweils gleichem Ergebnis verwendet. Deshalb wieder mit Disk I/O. Es gilt die Annahme, dass Indizes nichts kosten, da es sehr kleine Datenmengen sind. </br>
</br></p>
<p><strong>Beispiel 1</strong></br></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(sA=10\)</span>, <span class="math notranslate nohighlight">\(B&lt;20(R)\)</span></p></li>
<li><p>Variante 1: Tablescan</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(B(R)\)</span> falls R clustered</p></li>
<li><p><span class="math notranslate nohighlight">\(T(R)\)</span> falls R nicht clustered</p></li>
</ul>
</li>
<li><p>Variante 2: Index auf A verwenden</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\frac{B(R)}{V(R,A)}\)</span> falls Index clustering</p></li>
<li><p><span class="math notranslate nohighlight">\(\frac{T(R)}{V(R,A)}\)</span> falls Index nicht clustering</p></li>
</ul>
</li>
<li><p>Variante 3: Index auf B verwenden</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\frac{B(R)}{3}\)</span> falls Index clustering</p></li>
<li><p><span class="math notranslate nohighlight">\(\frac{T(R)}{3}\)</span> falls Index nicht clustering</p></li>
</ul>
</li>
<li><p>Variante 4 …</p></li>
</ul>
<p><strong>Beispiel 2</strong></br></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(sX=1\)</span>, <span class="math notranslate nohighlight">\(Y=2\)</span>, <span class="math notranslate nohighlight">\(Z&lt;5(R)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(T(R) = 5.000\)</span>, <span class="math notranslate nohighlight">\(B(R) = 200\)</span>, <span class="math notranslate nohighlight">\(V(R,X)=100\)</span>, <span class="math notranslate nohighlight">\(V(R,Y)=500\)</span></p></li>
<li><p>Sei R clustered. Die Indizes auf X und Y haben kein, aber der Index auf Z hat clustering (B-Baum).</p></li>
<li><p>Variante 1: Table-scan und Filter</p>
<ul>
<li><p>Kosten: <span class="math notranslate nohighlight">\(B(R) = 200 \ I/O\)</span></p></li>
</ul>
</li>
<li><p>Variante 2: Index-scan mit X-Index; Filter für den Rest</p>
<ul>
<li><p>Kosten: <span class="math notranslate nohighlight">\(\frac{T(R)}{V(R,X)} = \frac{5.000}{100} = 50 \ I/O\)</span></p></li>
</ul>
</li>
<li><p>Variante 3: Index-scan mit Y-Index; Filter für den Rest</p>
<ul>
<li><p>Kosten: <span class="math notranslate nohighlight">\(\frac{T(R)}{V(R,Y)} = \frac{5.000}{500} = 10 \ I/O\)</span></p></li>
<li><p>Variante 4: Index-scan mit (clustering) Z-Index; Filter für den Rest</p></li>
<li><p>Kosten: <span class="math notranslate nohighlight">\(\frac{B(R)}{3}= \frac{200}{3} = 67 \ I/O\)</span></p></li>
</ul>
</li>
</ul>
</section>
<section id="wahl-der-join-methode">
<h3><span class="section-number">5.8.3. </span>Wahl der Join-Methode<a class="headerlink" href="#wahl-der-join-methode" title="Permalink to this heading">#</a></h3>
<p>Man kann die Join-Methode je nach Kosten wählen (siehe voriger Foliensatz). Unter den Annahmen, dass man M (verfügbarer Hauptspeicher) kennt und M sich nicht während der Ausführung ändert. Außerdem gilt die Annahme, dass man <span class="math notranslate nohighlight">\(B(R), T(R)\)</span> und <span class="math notranslate nohighlight">\(V(R, ...)\)</span> kennt.
</br>
</br>
Mögliche Ideen, falls die Annahmen nicht stimmen, sind One-pass oder Nested-loop Algorithmen als default. Dabei gilt das Prinzip der „Hoffnung“. </br>
</br>
Der <strong>Sort-merge-join</strong> wird gewählt, falls mindestens ein Input bereits nach einem Joinattribut sortiert ist oder auch, falls es mehr als ein Join auf dem gleichem Attribut gibt: <span class="math notranslate nohighlight">\((R(A,B) \Join S(B,C)) \Join T(B,D)\)</span>.</br></p>
<p>Der <strong>Index-Join</strong> wird gewählt, falls die Relation R klein ist und es einen Index auf S.B gibt: <span class="math notranslate nohighlight">\(R(A,B) \Join S(B,C)\)</span>. </br></p>
<p>Falls weder Sortierung noch Indizes vorhanden sind, wird der <strong>Hash-Join</strong> gewählt. Die Kosten hängen nur vom kleinerem Input ab, nicht von den beiden Inputs. </br>
Analoge Überlegungen gelten auch für die Mengenoperationen.</p>
</section>
<section id="pipelining-vs-blocking">
<h3><span class="section-number">5.8.4. </span>Pipelining vs. Blocking<a class="headerlink" href="#pipelining-vs-blocking" title="Permalink to this heading">#</a></h3>
<p>Ein naiver Versuch ist das Blocking (auch „Materialisierend“). Jeder Operator speichert sein Zwischenergebnis auf der Disk. Besser ist eine Vermischung der Ausführung verschiedener Operatoren wie es beim Pipelining und den Ketten von Iteratoren der Fall ist. Die Vorteile von Pipelining sind ein geringerer I/O Verbrauch und frühe Ergebnisse bei der Anwendung. Nachteile des Pipelining sind, dass nicht jeder Operator funktioniert, die Anzahl der CPUs zu gering oder jeder Operator weniger Hauptspeicher. Somit müssen ungünstigere Algorithmen gewählt werden. Pipelining ist also nicht immer besser!</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "LUH-DBS/GDBS_Script",
            ref: "main/",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./05"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="../04/anfrageausfuehrung.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">4. </span>Anfrageausführung</p>
      </div>
    </a>
    <a class="right-next"
       href="../06/large-scale-data-management.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">6. </span>Large Scale Data Management</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#wiederholung-anfragebearbeitung">5.1. Wiederholung: Anfragebearbeitung</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#grundproblem">5.1.1. Grundproblem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ablauf-der-anfragebearbeitung">5.1.2. Ablauf der Anfragebearbeitung</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">5.2. Ablauf der Anfragebearbeitung</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parsing">5.2.1. Parsing</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algebraische-transformationsregeln">5.3. Algebraische Transformationsregeln</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kommutativitat-und-assoziativitat">5.3.1. Kommutativität und Assoziativität</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#weitere-regeln">5.3.2. Weitere Regeln</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#logische-anfrageplane">5.4. Logische Anfragepläne</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zwei-schritte">5.4.1. Zwei Schritte</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-anfragebearbeitung">5.4.2. Beispiel - Anfragebearbeitung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ubergang-zum-physischen-anfrageplan">5.4.3. Übergang zum Physischen Anfrageplan</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenmodell">5.5. Kostenmodell</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenbasierte-optimierung-wiederholung">5.5.1. Kostenbasierte Optimierung (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problemgrosze-suchraum-wiederholung">5.5.2. Problemgröße (Suchraum) (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenmodell-wiederholung">5.5.3. Kostenmodell (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#statistiken-wiederholung">5.5.4. Statistiken (Wiederholung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kosten-von-operationen">5.5.5. Kosten von Operationen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-projektion">5.5.6. Kostenschätzung - Projektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-selektion">5.5.7. Kostenschätzung - Selektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#selektivitat-schatzen">5.5.8. Selektivität schätzen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-fur-skew-zipf-verteilung">5.5.9. Beispiel für Skew: Zipf-Verteilung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">5.5.10. Kostenschätzung - Selektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-selektion-mit-disjunktion">5.5.11. Kostenschätzung - Selektion mit Disjunktion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join">5.5.12. Kostenschätzung - Join</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join-beispiel">5.5.13. Kostenschätzung - Join Beispiel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-join-mehrere-attribute">5.5.14. Kostenschätzung Join - Mehrere Attribute</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-mehrfacher-join">5.5.15. Kostenschätzung - Mehrfacher Join</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenschatzung-weitere-operationen">5.5.16. Kostenschätzung - Weitere Operationen</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#histogramme">5.6. Histogramme</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">5.6.1. Ablauf der Anfragebearbeitung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schatzung-der-statistiken">5.6.2. Schätzung der Statistiken</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schatzung-der-statistiken-histogramme">5.6.3. Schätzung der Statistiken - Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#verteilungen-korpergewicht">5.6.4. Verteilungen - Körpergewicht</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equi-width-histogramme">5.6.5. Equi-Width Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#equi-height-histogramme">5.6.6. Equi-Height-Histogramme</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#histogramme-zur-schatzung-fur-joins">5.6.7. Histogramme zur Schätzung für Joins</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#erhebung-von-statistiken">5.6.8. Erhebung von Statistiken</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#joinreihenfolge">5.7. Joinreihenfolge</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#enumeration-physischer-anfrageplane">5.7.1. Enumeration Physischer Anfragepläne</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#heuristische-auswahl">5.7.2. Heuristische Auswahl</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#branch-and-bound">5.7.3. Branch and Bound</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hill-climbing">5.7.4. Hill-Climbing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung-selinger-style-optimierung">5.7.5. Dynamische Programmierung &amp; Selinger-style Optimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#richard-bellman">5.7.6. Richard Bellman</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-fur-knapsack-problem">5.7.7. DP für Knapsack Problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#beispiel-knapsack-mit-dp">5.7.8. Beispiel: Knapsack mit DP</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-traveling-salesman-problem">5.7.9. DP: Traveling Salesman Problem</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamic-programming-heldkarp-algorithmus">5.7.10. Dynamic Programming (Held–Karp Algorithmus)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung">5.7.11. Dynamische Programmierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anwendung-fur-left-deep-baume">5.7.12. Anwendung für Left-Deep Bäume</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anfrageplanung">5.7.13. Anfrageplanung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anfragebearbeitung-optimierung">5.7.14. Anfragebearbeitung – Optimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dynamische-programmierung-optimierung-im-system-r">5.7.15. Dynamische Programmierung: Optimierung im System-R</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#bottom-up-anfrageplangenerierung">5.7.16. Bottom-up Anfrageplangenerierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">5.7.17. Dynamische Programmierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-grundidee-fur-anfrageoptimierung">5.7.18. DP – Grundidee für Anfrageoptimierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-beispiel">5.7.19. DP – Beispiel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-interesting-orders-interessante-sortierung">5.7.20. DP - interesting orders (Interessante Sortierung)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dp-algorithmus">5.7.21. DP – Algorithmus</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#physische-anfrageplane">5.8. Physische Anfragepläne</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wahl-der-selektionsmethode">5.8.1. Wahl der Selektionsmethode</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenvergleich-der-selektionsmethoden">5.8.2. Kostenvergleich der Selektionsmethoden</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#wahl-der-join-methode">5.8.3. Wahl der Join-Methode</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pipelining-vs-blocking">5.8.4. Pipelining vs. Blocking</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Prof. Dr. Ziawasch Abedjan
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>