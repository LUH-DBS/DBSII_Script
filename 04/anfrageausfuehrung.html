

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>4. Anfrageausführung &#8212; Online-Skript Datenbanksysteme II</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '04/anfrageausfuehrung';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5. Optimierung" href="../05/optimierung.html" />
    <link rel="prev" title="3. Indizes" href="../03/indizes.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/DBIS_Kurzlogo.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/DBIS_Kurzlogo.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Datenbanksysteme II
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../01/speicherung.html">1. Speicherung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02/repraesentation.html">2. Repräsentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03/indizes.html">3. Indizes</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">4. Anfrageausführung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05/optimierung.html">5. Optimierung</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06/large-scale-data-management.html">6. Large Scale Data Management</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/LUH-DBS/GDBS_Script" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/LUH-DBS/GDBS_Script/issues/new?title=Issue%20on%20page%20%2F04/anfrageausfuehrung.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/04/anfrageausfuehrung.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Anfrageausführung</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#physische-operatoren">4.1. Physische Operatoren</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tabellen-scannen">4.1.1. Tabellen Scannen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sortiertes-einlesen">4.1.2. Sortiertes Einlesen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#berechnungsmodell">4.1.3. Berechnungsmodell</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenparameter-statistiken">4.1.4. Kostenparameter / Statistiken</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iteratoren">4.1.5. Iteratoren</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#one-pass-algorithmen">4.2. One-Pass Algorithmen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operatorklassen-fur-one-pass-verfahren">4.2.1. Operatorklassen für One-pass Verfahren</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tupel-basierte-unare-operatoren">4.2.2. Tupel-basierte unäre Operatoren</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#relationen-basierte-unare-operatoren">4.2.3. Relationen-basierte unäre Operatoren</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#duplikateliminierung">4.2.4. Duplikateliminierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gruppierung">4.2.5. Gruppierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#relationen-basierte-binare-operatoren">4.2.6. Relationen-basierte binäre Operatoren</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#vereinigung">4.2.6.1. Vereinigung</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#schnittmenge">4.2.6.2. Schnittmenge</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mengen-differenz">4.2.6.3. Mengen-Differenz</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#multimengen-differenz">4.2.6.4. Multimengen-Differenz</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kreuzprodukt">4.2.6.5. Kreuzprodukt</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#natural-join">4.2.6.6. Natural Join</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nested-loop-join">4.3. Nested Loop Join</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#block-basierter-nlj">4.3.1. Block-basierter NLJ</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zusammenfassung-bisheriger-algorithmen">4.3.2. Zusammenfassung bisheriger Algorithmen</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sort-basierte-two-pass-algorithmen">4.4. Sort-basierte Two-Pass Algorithmen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">4.4.1. Duplikateliminierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gruppierung-und-aggregation">4.4.2. Gruppierung und Aggregation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vereinigung-binar">4.4.3. Vereinigung (binär)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schnittmenge-und-differenz">4.4.4. Schnittmenge und Differenz</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#einfacher-sort-basierter-join-algorithmus">4.4.5. Einfacher, Sort-basierter Join Algorithmus</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zusammenfassung-sortbasierte-two-pass-algorithmen">4.4.6. Zusammenfassung – sortbasierte, two-pass Algorithmen</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hash-basierte-two-pass-algorithmen">4.5. Hash-basierte Two-Pass Algorithmen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#partitionierung-mittels-hashing">4.5.1. Partitionierung mittels Hashing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#duplikateliminierung-delta-r">4.5.2. Duplikateliminierung <span class="math notranslate nohighlight">\(\delta(R)\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gruppierung-und-aggregation-gamma-l-r">4.5.3. Gruppierung und Aggregation <span class="math notranslate nohighlight">\(\gamma_{L}(R)\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mengenoperationen">4.5.4. Mengenoperationen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hashjoin">4.5.5. Hashjoin</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#i-o-einsparungen">4.5.6. I/O Einsparungen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#i-o-einsparungen-hybrid-hashjoin">4.5.7. I/O Einsparungen – Hybrid Hashjoin</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hybrid-hashjoin-analyse">4.5.8. Hybrid Hashjoin – Analyse</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zusammenfassung-hash-basierter-verfahren">4.5.9. Zusammenfassung Hash-basierter Verfahren</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#index-basierte-algorithmen">4.6. Index-basierte Algorithmen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#index-basierte-selektion">4.6.1. Index-basierte Selektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#joining-mit-index">4.6.2. Joining mit Index</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#zusammenfassung">4.7. Zusammenfassung</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="anfrageausfuhrung">
<h1><span class="section-number">4. </span>Anfrageausführung<a class="headerlink" href="#anfrageausfuhrung" title="Permalink to this heading">#</a></h1>
<p>Zoom in die interne Ebene: Die 5-Schichten Architektur</p>
<a class="reference internal image-reference" href="../_images/5-Schichten-Architektur2.png"><img alt="5-Schichten-Architektur" src="../_images/5-Schichten-Architektur2.png" style="width: 500px;" /></a>
<br>
<p>In den vorherigen Kapiteln haben wir die Anfragesprache bereits kennengelernt. Wir wissen jetzt, wie man Anfragen formulieren kann, wie Daten auf der Festplatte gespeichert werden und wie man den Zugriff auf die Daten mit Indizes beschleunigt.</p>
<p>Jetzt ist die Frage: Wie kommt man von der Anfrage bis zur Ausführung?
<br><br>
Zunächst haben wir eine SQL-Anfrage. Diese wird geparsed und daraus entsteht ein Parsebaum der prüft, ob diese Anfrage korrekt ist. Der Parsebaum wird dann in einen logischen Anfrageplan umgewandelt, der durch die Abschätzung der Kardinalitäten zeigt, wie eine logische Ausführung aussehen würde. Man versucht so die Operationen und ihre Reihenfolge auf logischer Ebene zu optimieren. Dann werden physische Pläne entworfen und man schaut, welche konkreten Implementierungen für einen bestimmten Operator Sinn machen würden. Für jeden Operator gibt es verschiedene Implementierungen, den Join Operator kann man beispielsweise als Loop Join oder auch Hash Join implementieren. Im nächsten Schritt werden die Pläne noch einmal begutachtet und die Kosten ein weiteres Mal geschätzt, damit der beste Plan ausgewählt werden kann. Führt man diesen dann aus, gibt es ein Anfrageergebnis zurück. Da man die Kardinalitäten nur abschätzt, hat man nicht die genauen Zahlen. Bei der Ausführung der Anfrage sieht man dann, wie lange diese tatsächlich braucht, ob sie vielleicht länger gebraucht hat, als erwartet, oder ob die Ausgabemenge sogar viel größer ist als geschätzt.
<br><br></p>
<p>Ablauf der Anfragebearbeitung</p>
<a class="reference internal image-reference" href="../_images/Ablauf-Anfragenbearbeitung.png"><img alt="Ablauf-Anfragenbearbeitung" src="../_images/Ablauf-Anfragenbearbeitung.png" style="width: 500px;" /></a>
<br>
Mit diesem Kapitel befinden wir uns in der Anfrageausführung und schauen uns konkret an, wie Operatoren umgesetzt werden.
<p><br> <br> <br>
<a class="reference internal" href="../_images/Überblick-meme1.png"><img alt="Überblick-meme" src="../_images/Überblick-meme1.png" style="width: 500px;" /></a></p>
<section id="physische-operatoren">
<h2><span class="section-number">4.1. </span>Physische Operatoren<a class="headerlink" href="#physische-operatoren" title="Permalink to this heading">#</a></h2>
<p>Anfragepläne bestehen aus Operatoren. Bevor wir Kosten schätzen können müssen wir diese Operatoren kennen. Wir kennen bereits die Operatoren der Relationalen Algebra, welche auf physische Operatoren abgebildet werden.
Was jetzt als neuer Operator dazu kommt, ist die Art und Weise, wie man eine Tabelle scannt.
<br>
Für jeden logischen Operator hat man mindestens einen physischen Operator der diesen implementiert.
Später können noch Varianten von logischen Operatoren hinzukommen. Ein Join lässt sich beispielsweise unterschiedlich ausführen.</p>
<section id="tabellen-scannen">
<h3><span class="section-number">4.1.1. </span>Tabellen Scannen<a class="headerlink" href="#tabellen-scannen" title="Permalink to this heading">#</a></h3>
<p>Eine Tabelle zu scannen ist die einfachste Operation. Dabei wird die gesamte Relation eingelesen, was man unter anderem für Joins und Unions braucht. Den Scan kann man ggf. auch anpassen, indem man diesen mit Selektionsbedingungen kombiniert, um zum Beispiel nur die Blöcke zu suchen, die einen bestimmten Wert enthalten.
<br><br>
Es gibt zwei Scan Varianten, den <em>Table-scan</em> und den <em>Index-scan</em>.
Beim <em>Table-scan</em>, werden alle Blöcke eingelesen, die in einer (bekannten) Region der Festplatte liegen. Dies bietet sich an, wenn man alle Operationen lesen will und die Tupelreihenfolge keine Rolle spielt. <br>
Beim <em>Index-scan</em> gibt es einen Index, der angibt, welche Blöcke zur Relation gehören und wo diese liegen. Hat man eine Selektionsbedingung bietet sich der <em>Index-scan</em> hier am ehesten an, da wir direkt zu den bestimmten Werten springen können. Dieser steht außerdem stellvertretend für u.a. den B-Baum Index und den Hash Index.</p>
</section>
<section id="sortiertes-einlesen">
<h3><span class="section-number">4.1.2. </span>Sortiertes Einlesen<a class="headerlink" href="#sortiertes-einlesen" title="Permalink to this heading">#</a></h3>
<p>Eine weitere besondere Variante des Scans ist der <em>Sort-scan</em> - das sortierte Einlesen. Dies ist nützlich, wenn man in der Anfrage mit Order By sortiert oder wenn man bestimmte Operation, wie zum Beispiel Bereichsanfragen, ausführen will. Dann kann man mit <em>Sort-scan</em>, basierend auf einem gegeben Sortierschüssel, welcher aus einem oder mehreren Attributen und einer Sortierreihenfolge besteht, die Relation sortiert zurückgeben.</p>
<p>Es gibt unterschiedliche Implementierungsvarianten. Man kann zum Beispiel einen B-Baum haben der einen Sortierschlüssel als Suchschlüssel hat oder eine sequentielle Datei, die nach einem Sortierschlüssel sortiert ist. Ist die Relation klein kann diese im Hauptspeicher sortiert werden. Dann nutzt man entweder den <em>Table-scan</em> oder den <em>Index-scan</em> plus eine Sortierung. Ist die Relation hingegen sehr groß, muss man den TPMMS durchführen. Damit ist die Ausgabe nicht auf der Festplatte sondern als Iterator im Ausführungsplan.</p>
</section>
<section id="berechnungsmodell">
<h3><span class="section-number">4.1.3. </span>Berechnungsmodell<a class="headerlink" href="#berechnungsmodell" title="Permalink to this heading">#</a></h3>
<p>Bei der Ermittlung der Kosten eines Operators werden nur die I/O-Kosten berechnet, da diese die CPU-Kosten dominieren. Nehmen wir an, der Input eines Operators wird von der Disk gelesen, während der Output nicht auf die Disk geschrieben werden muss. Handelt es sich bei dem Operator um den letzten im Baum, verarbeitet die Anwendung die Tupel einzeln. Die I/O-Kosten hängen in diesem Fall von der Anfrage ab, nicht vom Plan. Handelt es sich aber um einen inneren Operator, kann man Pipelining durchführen, d.h. ein Tupel wird gelesen, zum nächsten Operator gegeben und immer so weiter. Damit hat man immer dieselben I/O-Kosten verbraucht, da das Tupel wie am Fließband von Operator zu Operator gereicht wird.</p>
</section>
<section id="kostenparameter-statistiken">
<h3><span class="section-number">4.1.4. </span>Kostenparameter / Statistiken<a class="headerlink" href="#kostenparameter-statistiken" title="Permalink to this heading">#</a></h3>
<p>Der verfügbare Hauptspeicher für einen Operator beträgt M Einheiten. Eine Einheit ist eine Blockgröße die wir auf der Festplatte haben. Den Hauptspeicherverbrauch messen wir nur für den Input der Operatoren, nicht für den Output. Wie viel Hauptspeicher man braucht, kann man dynamisch während der Anfragebearbeitung bestimmen. Wir gehen davon aus, dass M eine Schätzung ist und die Kosten, die wir schätzen können, nie genau sind. Der gewählte Plan, den wir als besten Plan ausgeben, ist nicht unbedingt auch der beste Plan. Basierend auf den Schätzungen ist es der Beste, dieser kann aber auch suboptimal sein.</p>
<p><em>B</em> ist die Anzahl der Blöcke, <em>B®</em> ist die Anzahl aller Blöcke der Relation. Wir nehmen sogar an, dass <em>B®</em> die Anzahl der <strong>tatsächlich</strong> belegten Blöcke ist.</p>
<p><em>T</em> ist die Anzahl der Tupel, <em>T®</em> ist die Anzahl der Tupel einer Relation. Mit <em>T/B</em> können wir die ungefähre Anzahl der Tupel pro Block berechnen.</p>
<p><em>V</em> ist die Anzahl unterschiedlicher Werte (DISTINCT values) , d.h. die Kardinalität jeder Spalte. <em>V(R,a)</em> ist die Anzahl unterschiedlicher Werte einer Relation R im Attribut a.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(V(R, [a1,a2,…,an]) = |\delta(\pi_{a1,a2,…,an}(R))|\)</span> –&gt; Betrag der Duplikatentfernung = Anzahl unterschiedlicher Werte</p></li>
</ul>
 <br>
<p><strong>Scan-Kosten Beispiele</strong></p>
<p>Nun gibt es zusätzlich noch zu berücksichtigen, ob eine Relation <strong>geclustered</strong> ist oder nicht. Ist R clustered gespeichert, liegen alle relevanten Tupel nebeneinander. Bei einem <em>Table-scan</em> werden alle Blöcke gelesen, also betragen die Kosten <em>B®</em>. Wenn sortiert werden soll und R in den Hauptspeicher passt, betragen die Kosten für einen <em>Sort-scan B</em>. Passt R nicht, müssen wir TPMMS anwenden und die Kosten betragen dann <em>3B</em>. <br>
Ist R <strong>nicht geclustered</strong>, also die Blöcke nicht nebeneinanderliegend, sondern gemischt mit Tupeln anderer Relationen, betragen die Kosten für einen <em>Table-scan</em> im schlimmsten Fall <em>T®</em>. Soll wieder sortiert werden, und R passt in den Hauptspeicher, liegen die Kosten für einen <em>Sort-scan</em> bei <em>T</em>. Passt R aber nicht und wir müssen wieder TPMMS anwenden, betragen die Kosten <em>T+2B</em>.</p>
<p>Die Kosten für einen <em>Index-scan</em> sind <em>B</em> oder <em>T</em>. Ist der Index selbst einige Blöcke groß, handelt es sich meistens um kleinere Zahlen. Bei einem Baum beispielsweise rechnet man plus die Höhe, denn je nach dem was schon im Hauptspeicher liegt, ob es die Wurzel ist oder mehrere Ebenen, hat man mehr I/O-Operationen.</p>
</section>
<section id="iteratoren">
<h3><span class="section-number">4.1.5. </span>Iteratoren<a class="headerlink" href="#iteratoren" title="Permalink to this heading">#</a></h3>
<p>Viele physische Operatoren werden als Iterator implementiert. Für jede Operation haben wir drei bestimmte Grundfunktionen: Open(), GetNext() und Close(). <br>
Die Open-Funktion initialisiert Datenstrukturen und öffnet einen Iterator für eine Operation. Diese kann zum Beispiel ein Scan sein oder auch ein Join und diese Operation ruft dann die Open-Funktionen für alle anderen Operationen auf, die im Baum darunter liegen. Auf jeder Ebene des Baumes wird Open() aufgerufen. Die Funktion holt aber noch keine Tupel nach oben.</p>
<p>Mit der GetNext-Funktion holt man das nächste Tupel. Wendet man die Funktion auf den obersten Iterator an, ruft dieser wiederrum GetNext() für die Iteratoren darunter auf und geht dabei so tief wie nötig. Ist kein Tupel mehr vorhanden bekommt man ein <em>NotFound</em> zurück.</p>
<p>Close() beendet und schließt den Iterator und ruft Close() auch für die anderen Iteratoren auf.</p>
<p><strong>Pull-basierte Anfrageauswertung</strong></p>
<p>In dem Beispiel lässt sich gut erkennen, wie Open() und GetNext() funktionieren. Wird hier in dem obersten Iterator Open() aufgerufen, wird auch in allen darunterliegenden Iteratoren Open() aufgerufen. R1-R4 symbolisieren die Scan Operationen. Mit GetNext() geht man die Iteratoren durch, bis ganz nach unten und holt dann das Ergebnis nach oben.</p>
<a class="reference internal image-reference" href="../_images/Pull-basierte-Anfragenauswertung.png"><img alt="Pull-basierte-Anfragenauswertung" src="../_images/Pull-basierte-Anfragenauswertung.png" style="width: 500px;" /></a>
<p><strong>Iterator – Beispiel</strong></p>
<p>In diesem Iterator Beispiel sieht man unten die beiden Relationen <em>StarsIn</em> und <em>MovieStar</em>. Aus der Relation <em>MovieStar</em> werden mithilfe, einer Selektion und einer Projektion alle Namen der Filmstars die 1960 geboren wurden herausprojiziert. <em>StarsIn</em> und <em>MovieStar</em> werden dann gejoint und um die Titel der Filme zu bekommen, in denen nur Schauspieler gespielt haben, die 1960 geboren wurden.</p>
<a class="reference internal image-reference" href="../_images/Iterator-Beispiel.png"><img alt="Iterator-Beispiel" src="../_images/Iterator-Beispiel.png" style="width: 500px;" /></a>
<p><br><br></p>
<p><strong>Pipelining vs. Pipeline-Breaker</strong></p>
<p>Wir sehen hier die Relationen <em>R</em>, <em>S</em> und <em>T</em>. Die schwarzen Punkte sind die Tupel, die sich nach oben bewegen. Es gibt die Möglichkeit, Operatoren zu pipelinen. Das bedeutet, dass wir mit GetNext() jedes Tupel direkt aus der untersten Schicht holen können (obere Abb.). Wenn aber irgendwo ein GetNext() in einem Open() enthalten ist, gibt es einen Blocker, in dem zunächst alle Tupel gesammelt werden. Dann spricht man von einem Pipeline-Breaker (untere Abb.).</p>
<img src="pictures/Pipelining-vs-Pipelin-Breaker_2.png" alt="Pipelining-vs-Pipelin-Breaker_2" width="500" style="background-color: white;"/>
<br>
<img src="pictures/Pipelining-vs-Pipelin-Breaker.png" alt="Pipelining-vs-Pipelin-Breaker" width="500" style="background-color: white;"/>
<p><strong>Pipelining versus Blocking</strong></p>
<p>Pipelining ist im allgemeinen sehr vorteilhaft. Es müssen keine Zwischenergebnisse gespeichert werden und Operationen können auf Threads und CPUs verteilt werden. Wenn aber die gesamte Relation gelesen werden muss, braucht man Pipeline-Breaker. Sortiert man beispielsweise, muss man die gesamte Relation gesehen haben, andernfalls kann next() nicht ausgeführt werden. Das ist vor allem auch wichtig, wenn man gruppieren und aggregieren möchte. Ist die Relation sortiert oder gehashed kann next() diese dann aggregieren.</p>
<p>Union und Projektionen mit Duplikateliminierung scheinen auf den ersten Blick wie Pipeline-Breaker zu sein, da man alle Tupel miteinander vergleichen muss. Das ist aber nicht zwingend der Fall, denn die beiden Operatoren können die Tupel die sie bekommen in der GetNext-Funktion vermerken. Beim nächsten Aufruf kann dann geprüft werden, ob dieses Tupel schon einmal gesehen wurde. Eine Sortierung ist hierfür nicht notwendig, da next() die Ergebnisse schon früh weiterreichen kann. Die effizienteste Methode ist dies nicht, da man für das merken der Tupel einen großen Zwischenspeicher braucht.
<strong>Aber:</strong> Einen Zwichenspeicher braucht man nur manchmal, in den anderen Fällen muss man die Operationen blocken (Blocking).</p>
<p><strong>Iterator – Beispiel</strong></p>
<a class="reference internal image-reference" href="../_images/Iterator-Beispiele_2.png"><img alt="Iterator-Beispiele_2" src="../_images/Iterator-Beispiele_2.png" style="width: 500px;" /></a>
<br>
<p><strong>Überblick über das Weitere</strong></p>
<p>Es gibt <strong>drei Klassen</strong> von Algorithmen: <em>Sort-basierte, Hash-basierte und Index-basierte Algorithmen</em>. Diese sind entweder <em>One-Pass Algorithmen, Two-Pass Algorithmen oder Multipass Algorithmen</em> und haben somit <strong>drei Schwierigkeitsgrade</strong> die sich darin unterscheiden, wie oft über die Daten gelesen wird.
<br><br>
Die einfachsten Operatoren erfordern, dass nur einmal über die Daten gelesen wird. Das ist meist bei einem Scan der Fall, deshalb würde man hier einen <em>One-Pass Algorithmus</em> verwenden. Hier passt mindestens ein Argument in den Hauptspeicher, Selektion und Projektion ausgenommen.</p>
<p><em>Two-Pass Algorithmen</em>, wie zum Beispiel TPMMS, finden meist Anwendung, wenn es eine Größenbeschränkung für den Input gibt. Hierbei wir meist erst einmal gelesen, dann wird zwischengespeichert und dieses Zwischenergebnis wird dann noch einmal gelesen.</p>
<p>Hat man zu wenig Speicherplatz für den Two-Pass Algorithmus kann man den <em>Multipass Algorithmus</em> verwenden. Dieser ist eine rekursive Erweiterung des Two-Pass Algorithmus und unbeschränkt in der Inputgröße, dafür aber unter anderem abhängig vom Operator.</p>
</section>
</section>
<section id="one-pass-algorithmen">
<h2><span class="section-number">4.2. </span>One-Pass Algorithmen<a class="headerlink" href="#one-pass-algorithmen" title="Permalink to this heading">#</a></h2>
<section id="operatorklassen-fur-one-pass-verfahren">
<h3><span class="section-number">4.2.1. </span>Operatorklassen für One-pass Verfahren<a class="headerlink" href="#operatorklassen-fur-one-pass-verfahren" title="Permalink to this heading">#</a></h3>
<p>Wir gehen immer davon aus, dass die Operationen und der Input in den Speicher passt. <br> Hat man <em>Tupel-basierte unäre Operatoren</em> braucht man nur einen sehr kleinen Teil des Inputs gleichzeitig im Hauptspeicher. Meist wenn Projektionen, Selektionen oder Multimengen-Vereinigungen durchführt.</p>
<p><em>Relationen-basierte unäre Operatoren</em> benötigen meist die gesamte Relation gleichzeitig im Hauptspeicher. Deshalb darf die Inputgröße die Hauptspeichergröße nicht überschreiten.
Dies ist der Fall bei Gruppierungen, Duplikateliminierungen und Sortierungen.</p>
<p><em>Relationen-basierte binäre Operatoren</em> benötigen mindestens eine gesamte Relation im Hauptspeicher. Außerdem braucht man dann noch ein wenig Speicher für ein Element aus einer anderen Relation. Das gilt für alle Mengenoperationen außer Multimengen-Vereinigungen, aber vor allem für den Join.</p>
</section>
<section id="tupel-basierte-unare-operatoren">
<h3><span class="section-number">4.2.2. </span>Tupel-basierte unäre Operatoren<a class="headerlink" href="#tupel-basierte-unare-operatoren" title="Permalink to this heading">#</a></h3>
<p>Für Selektionen und Projektionen verwendet man Tupel-basierte unäre Operatoren, denn diese sind unabhängig von der Hauptspeichergröße. Die Speicherkosten betragen nur eine Einheit, da man immer nur ein Tupel auf einmal liest. Die I/O-Kosten hängen wie beim <em>Table-scan</em> oder <em>Index-scan</em> davon ab, ob R geclustered ist oder nicht. Ist R geclustered, betragen die Kosten B, ist R nicht geclustered betragen die Kosten T. Falls es einen Suchschlüssel im Index gibt, sind die Kosten noch geringer.</p>
<a class="reference internal image-reference" href="../_images/Tupel-basierte-unäre-Operatoren.png"><img alt="Tupel-basierte-unäre-Operatoren" src="../_images/Tupel-basierte-unäre-Operatoren.png" style="width: 500px;" /></a>
</section>
<section id="relationen-basierte-unare-operatoren">
<h3><span class="section-number">4.2.3. </span>Relationen-basierte unäre Operatoren<a class="headerlink" href="#relationen-basierte-unare-operatoren" title="Permalink to this heading">#</a></h3>
<p>Relationen-basierte unäre Operatoren verwendet man bei Duplikateliminierungen und Gruppierungen. Hier ist zu beachten, dass die ganze Relation in den Hauptspeicher passen muss. Um dies zu bewältigen und um den Hauptspeicher ein wenig zu entlasten, ist es sinnvoll, nur die “Repräsentanten” zu speichern.
Für die Duplikateliminierung bedeutet das, nicht alle Attribute eines Tupels zu speichern, sondern nur die, die die Tupel voneinander unterscheiden.
Bei der Gruppierung würde man nur Gruppierungsattribute und aggregierte Teilergebnisse speichern und nicht das gesamte Tupel. Mit diesem “Trick” können dann auch größere Relationen verarbeitet werden.</p>
</section>
<section id="duplikateliminierung">
<h3><span class="section-number">4.2.4. </span>Duplikateliminierung<a class="headerlink" href="#duplikateliminierung" title="Permalink to this heading">#</a></h3>
<p>Bei der Duplikateliminierung wird Tupel für Tupel eingelesen. Wurde das Tupel zuvor noch nicht gesehen, wird es einfach ausgegeben, andernfalls passiert nichts.
Der Puffer merkt sich, welche Tupel schon einmal gesehen wurden. Da man Tupel sofort finden möchte, sollte man sich eine geeignete Datenstruktur überlegen. Hier bieten sich am besten Hashtabellen oder balancierte Binärbäume an.
Bei der Wahl von M, also wie groß der Speicher sein muss, rechnet man die Anzahl der duplizierten Tupel (alle DISTINCT Werte der Relation) geteilt durch die Anzahl der Tupel pro Block. Das Ergebnis muss dann kleiner sein als M, damit man die Duplikateliminierung mit einem One-Pass Algorithmus durchführen kann.</p>
<ul class="simple">
<li><p>Wahl von M: <span class="math notranslate nohighlight">\(B(\delta(R)) = V(R, [A1, … ,An])\)</span> / Tupel-pro-Block ≤ M</p></li>
</ul>
<img src="pictures/Duplikateliminierung.png" alt="Duplikateliminierung" width="500" style="background-color: white;"/>
<br>
</section>
<section id="gruppierung">
<h3><span class="section-number">4.2.5. </span>Gruppierung<a class="headerlink" href="#gruppierung" title="Permalink to this heading">#</a></h3>
<p>Bei der Gruppierung wird ein Eintrag pro Gruppe im Hauptspeicher, bzw. ein Eintrag pro Gruppierungswert erzeugt. Dazu nimmt man noch kumulierte Werte für aggregierte Attribute, wie zum Beispiel MIN/MAX, COUNT oder SUM. AVG ist etwas schwieriger, da sich der Wert ändern kann. Hierfür muss man sich zusätzlich noch COUNT und SUM merken, damit man dann am Ende AVG berechnen kann.
<br><br>
Der Output ist ein Tupel pro Eintrag und wird erst nach dem letzten Input ausgegeben, denn erst dann kann man sicher sein, dass jede Gruppe vollständig betrachtet wurde.
Da die Einträge selbst größer oder kleiner als das Tupel sein können, sind die Hauptspeicherkosten schwer abzuschätzen. Die Anzahl der Einträge ist aber höchstens so groß wie <em>T</em>. Meistens wird sogar weniger Speicher verwendet, als man Blöcke hat.</p>
</section>
<section id="relationen-basierte-binare-operatoren">
<h3><span class="section-number">4.2.6. </span>Relationen-basierte binäre Operatoren<a class="headerlink" href="#relationen-basierte-binare-operatoren" title="Permalink to this heading">#</a></h3>
<p>Zu den Relationen-basierte binäre Operatoren gehören alle mengenbasierten Operatoren sowie Join und das Kreuzprodukt. Bei den mengenbasierten Operationen müssen wir die Multimengenvereinigung ausschließen. Hier ist anzumerken, das Multimengensemantik immer mit einem B (“Bag”) abgekürzt ist und Mengensemantik mit einem S (“Set”).</p>
<p>Es wird angenommen, dass immer eine Relation in den Hauptspeicher passt. Je nachdem, welche Operation man durchführen möchte, muss hier wieder eine sinnvolle Datenstruktur gewählt werden. Sollte nur eine Relation in den Hauptspeicher passen, nimmt man hier die kleinere. Wir gehen davon aus, dass B(S) kleiner als B® ist und die Kosten somit ungefähr B(S) + 1 betragen. Deshalb würde man hier B(S) wählen.</p>
<section id="vereinigung">
<h4><span class="section-number">4.2.6.1. </span>Vereinigung<a class="headerlink" href="#vereinigung" title="Permalink to this heading">#</a></h4>
<p>Führt man die Vereinigung von R und S in Multimengensemantik durch ( <strong>R <span class="math notranslate nohighlight">\(\cup_{B}\)</span> S</strong> ), ist das Tupel-basiert möglich. Die I/O-Kosten betragen B® + B(S), da beide Relationen gelesen werden müssen, und der Hauptspeicherbedarf beträgt genau 1.</p>
<p>Bei der Vereinigung von R und S in der Mengensemantik ( <strong>R <span class="math notranslate nohighlight">\(\cap_{S}\)</span> S</strong> ) werden erst alle Tupel aus S eingelesen. Über diese Tupel wird dann eine Datenstruktur aufgebaut (Schlüssel ist ein gesamtes Tupel). Diese eingelesenen Tupel werden dann alle ausgegeben und als nächstes wird R eingelesen. Bei jedem Tupel, dass es auch in S gibt, wird nichts gemacht, die anderen werden auch ausgegeben.</p>
</section>
<section id="schnittmenge">
<h4><span class="section-number">4.2.6.2. </span>Schnittmenge<a class="headerlink" href="#schnittmenge" title="Permalink to this heading">#</a></h4>
<p>Nimmt man die Schnittmenge von R und S ( <strong>R <span class="math notranslate nohighlight">\(\cap_{S}\)</span> S</strong> ), ist der Ablauf ähnlich wie bei der Vereinigung in Mengensemantik. Nach dem Einlesen von S gibt man aber noch keine Tupel aus, da man noch nicht weiß, ob diese in der Schnittmenge enthalten sind. Liest man dann R ein, werden die Tupel, die auch in S vorkommen, ausgegeben, für die anderen wird nichts getan. Voraussetzung für die Schnittmenge ist, dass R und S Mengen sind.</p>
<p>Bei der Schnittmenge von R und S in der Multimengensemantik ( <strong>R <span class="math notranslate nohighlight">\(\cap_{B}\)</span> S</strong> ) wird S eingelesen und für jedes Tupel ein COUNT-Wert gespeichert, damit man sehen kann, wie oft ein Tupel gelesen wurde. Dann wird R eingelesen. Kommt ein Tupel aus R in S vor und der COUNT-Wert ist größer als Null, wird dieses Tupel ausgegeben und der COUNT-Wert um eins reduziert. In allen anderen Fällen wird nichts getan.</p>
</section>
<section id="mengen-differenz">
<h4><span class="section-number">4.2.6.3. </span>Mengen-Differenz<a class="headerlink" href="#mengen-differenz" title="Permalink to this heading">#</a></h4>
<p>Die Mengen-Differenz ist nicht kommutativ, deshalb ist es wichtig, dass man die Relation, von der man etwas abziehen möchte, zuerst nimmt. Auch hier ist wieder vorausgesetzt, dass R und S Mengen sind. Für die beiden folgenden Beispiele angenommen, dass S kleiner als R ist.</p>
<p>Im ersten Schritt wird immer die kleinere Relation, hier S, in eine effiziente Datenstruktur eingelesen. Der Schlüssel ist ein gesamtes Tupel.</p>
<p>Nimmt man <strong>R <span class="math notranslate nohighlight">\(-_{S}\)</span> S</strong>, liest man R ein und gibt jedes nicht in S vorkommende Tupel aus. Die anderen Tupel werden ignoriert. <br>
Nimmt man <strong>S <span class="math notranslate nohighlight">\(-_{S}\)</span> R</strong>, liest man R ein und löscht alle auch in S vorkommenden Tupel aus der Datenstruktur. Kommt ein Tupel nicht in S vor, wird nichts getan. Alle übrigen Tupel werden einfach ausgegeben.</p>
</section>
<section id="multimengen-differenz">
<h4><span class="section-number">4.2.6.4. </span>Multimengen-Differenz<a class="headerlink" href="#multimengen-differenz" title="Permalink to this heading">#</a></h4>
<p>Auch die Multimengendifferenz ist nicht kommutativ und auch hier ist es wichtig, die Relation, von der man etwas abziehen möchte, zuerst zu nehmen. <br>
Nimmt man <strong>S <span class="math notranslate nohighlight">\(-_{B}\)</span> R</strong> in der Multimengensemantik, liest man auch hier zuerst S ein und speichert wieder für jedes Tupel einen COUNT-Wert. Dann wird wieder R eingelesen und geschaut, ob es in der Relation Tupel gibt die auch in S vorkommen. Falls ja, wird der COUNT-Wert verringert, falls nein, wird nichts getan. Die Tupel werden dem COUNT-Wert entsprechend oft ausgegeben.</p>
<p>Bei <strong>R <span class="math notranslate nohighlight">\(-_{B}\)</span> S</strong> wird für jedes Tupel in S ein COUNT-Wert c gespeichert, welcher c Gründe liefert, ein Tupel aus R nicht auszugeben. Wird dann R eingelesen und ein Tupel ist bereits vorhanden und COUNT ist größer als Null, wird COUNT verringert. Ist COUNT gleich Null oder das Tupel noch nicht vorhanden, wird es ausgegeben.</p>
</section>
<section id="kreuzprodukt">
<h4><span class="section-number">4.2.6.5. </span>Kreuzprodukt<a class="headerlink" href="#kreuzprodukt" title="Permalink to this heading">#</a></h4>
<p>Bei dem Kreuzprodukt von R und S (<strong>R x S</strong>) wird S wieder zuerst in den Hauptspeicher eingelesen, hierbei ist die Datenstruktur egal. Wird dann R eingelesen, konkatenieren wir mit jedem Tupel aus S und geben das Ergebnis aus. Die Rechenzeit pro Tupel ist sehr lang und die Ausgabe dementsprechend groß.</p>
</section>
<section id="natural-join">
<h4><span class="section-number">4.2.6.6. </span>Natural Join<a class="headerlink" href="#natural-join" title="Permalink to this heading">#</a></h4>
<p>Beim Natural Join <strong>R(X,Y) ⋈ S(Y,Z)</strong> wird zuerst S in den Hauptspeicher eingelesen. Y ist hier unser Suchschlüssel - das Join Attribut. Dann wird R eingelesen und man sucht für jedes Tupel der Relation ein passendes Tupel aus S und gibt es aus. Die I/O-Kosten betragen B(S) + B®. Es wird angenommen, dass B(S) &lt;= M-1 bzw. &lt;= M ist.</p>
<p>Equi-join und Theta-join funktionieren analog.</p>
</section>
</section>
</section>
<section id="nested-loop-join">
<h2><span class="section-number">4.3. </span>Nested Loop Join<a class="headerlink" href="#nested-loop-join" title="Permalink to this heading">#</a></h2>
<p>Zuvor haben wir uns mit Algorithmen und Operatoren beschäftigt, bei denen es ausgereicht hat, eine Relation nur einmal einzulesen, da diese als Ganzes in den Hauptspeicher passte. Nun schauen wir uns Algorithmen an, bei denen nicht mehr davon ausgegangen werden kann, dass der Hauptspeicher ausreichend groß ist.</p>
<p>Der Nested-Loop-Join-Algorithmus ist ein operationsabhängiges Verfahren und ein 1.5-Pass Algorithmus. Die Idee ist, dass eine Relation nur einmal eingelesen wird und die andere Relation mehrfach. Dabei kann die Größe der beiden Relationen beliebig sein.</p>
<p>Man könnte hier eine Tupel-basierte, naive Variante des Algorithmus durchführen. Dafür holt man sich jeweils ein Tupel aus der Relation S und ein Tupel aus der Relation R und prüft, ob man diese verjoinen kann. Falls ja, wird das Ergebnis ausgegeben.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>FOR EACH TUPLE s IN S DO
    FOR EACH TUPLE r IN R DO
    IF (r.Y = s.Y) THEN OUTPUT (r ⋈ s)
</pre></div>
</div>
<p>Die I/O-Kosten sind T(S) + T(S) · T®, denn man muss jedes Tupel aus S herausfinden und dann für jedes dieser Tupel R-mal alle Tupel aus R lesen. Das lässt sich optimieren, indem man zum Beispiel einen Index für das Joinattribut in R hat oder die Tupel auf Blöcke verteilt.</p>
<section id="block-basierter-nlj">
<h3><span class="section-number">4.3.1. </span>Block-basierter NLJ<a class="headerlink" href="#block-basierter-nlj" title="Permalink to this heading">#</a></h3>
<p>Beim Block-basierten Nested Loop Join werden die Tupel nach Blöcken organisiert, was besondern sinnvoll für die innere Schleife ist. Wir versuchen den Hauptspeicher so gut es geht zu nutzen, indem wir ein R-Tupel nicht nur mit einem, sondern mit vielen S-Tupeln verjoinen. Idealerweise ist die äußere Schleife für die kleinere Relation (hier S), damit weniger Vergleiche gemacht werden müssen. Dennoch ist dies schwieriger als im One-Pass, da B(S) größer als M ist. Aus dem Grund brauchen wir auch hier eine effiziente Datenstruktur für S im Hauptspeicher.</p>
<p>Im folgenden Codebeispiel sehen wir, wie so ein Block-basierter Nested Loop Join aussieht. Wir holen uns einen chunk von Blöcken aus S und lesen die Blöcke in den Hauptspeicher. Dann organisieren wir die Tupel in effiziente Datenstrukturen, sodass wir die Join Attribute besser als Schlüssel darstellen können. In der nächsten Schleife holen wir dann jeweils einen Block aus R und lesen für jeden Block die Tupel aus. Es werden drei Schleifen benötigt. Die ersten beiden sind für das blockweise Vorgehen zuständig und die Dritte wird gebraucht, weil im Block selber die Tupel im Hauptspeicher noch einmal gelesen werden müssen.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FOR</span> <span class="n">EACH</span> <span class="n">chunk</span> <span class="n">of</span> <span class="n">M</span><span class="o">-</span><span class="mi">1</span> <span class="n">blocks</span> <span class="n">of</span> <span class="n">S</span> <span class="n">DO</span> <span class="n">BEGIN</span>
    <span class="n">read</span> <span class="n">blocks</span> <span class="n">into</span> <span class="n">main</span> <span class="n">memory</span><span class="p">;</span>
    <span class="n">organize</span> <span class="n">tuples</span> <span class="n">into</span> <span class="n">efficient</span> <span class="n">data</span> <span class="n">structure</span><span class="p">;</span>
    <span class="n">FOR</span> <span class="n">EACH</span> <span class="n">block</span> <span class="n">b</span> <span class="n">of</span> <span class="n">R</span> <span class="n">DO</span> <span class="n">BEGIN</span>
        <span class="n">read</span> <span class="n">b</span> <span class="n">into</span> <span class="n">main</span> <span class="n">memory</span><span class="p">;</span>
        <span class="n">FOR</span> <span class="n">EACH</span> <span class="nb">tuple</span> <span class="n">t</span> <span class="n">of</span> <span class="n">b</span> <span class="n">DO</span> <span class="n">BEGIN</span>
            <span class="n">find</span> <span class="n">tuples</span> <span class="n">of</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">main</span> <span class="n">memory</span> <span class="n">that</span> <span class="n">join</span><span class="p">;</span>
            <span class="n">output</span> <span class="n">those</span> <span class="n">joined</span> <span class="n">tuples</span><span class="p">;</span>
        <span class="n">END</span><span class="p">;</span>
    <span class="n">END</span><span class="p">;</span>
<span class="n">END</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Block-basierter NLJ – Kosten</strong></p>
<p>Sagen wir, wir haben eine Relation R mit 1000 Blöcken (<strong>B® = 1000</strong>), eine Relation S mit 500 Blöcken (<strong>B(S) = 500</strong>) und 101 Einheiten Platz im Hauptspeicher (<strong>M = 101</strong>). Damit können wir im Hauptspeicher jeweils 100 Blöcke abbilden und jeweils einen Block für R merken, vorausgesetzt es werden keine weiteren Einheiten benötigt. Nun muss die äußere Schleife <strong>fünf Mal</strong> durchlaufen werden (<strong>5 · 100 I/O-Operationen = 500</strong>). Dazu kommen jeweils <strong>1000 I/O-Operationen</strong> für R, womit wir auf insgesamt <strong>5.500 I/O-Operationen</strong> kommen.</p>
<p>Wäre R jetzt in der äußeren Schleife, würde diese Relation zuerst gelesen werden und die Schleife müsste <strong>10 Mal</strong> durchlaufen werden (<strong>10 · 100 I/O-Operationen = 1000</strong>). Dazu würden wieder pro Schleifendurchlauf jeweils <strong>500 I/O-Operationen</strong> für S hinzukommen und ein Ergebnis von <strong>6000 I/O-Operationen</strong> liefern. Wie man sieht, ist es also sinnvoller wenn die kleinere Relation außen ist.</p>
<p>In einem weiteren Beispiel haben wir <strong>B(S) = 100</strong> und <strong>B® = 1.000.000</strong>. Ist die Relation R außen, muss die Schleife <strong>10.000 Mal</strong> laufen und bei jedem Durchlauf kommen <strong>100 I/O-Operationen</strong> für S hinzu, sodass man am Ende <strong>2.000.000 I/O-Operationen</strong> hat. Ist S in diesem Szenario außen, muss die Schleife nur einmal durchlaufen werden und man hat am Ende <strong>1.000.100 I/O-Operationen</strong>. Also auch hier wieder deutlich, dass es sinnvoller ist, die kleinere Relation außen zu haben.</p>
<p>Im folgenden einmal eine allgemeinere Berechnung. Mit der äußeren Schleife werden so viele Blöcke gelesen, wie in den Hauptspeicher passen. Also wird hierfür die Anzahl der Blöcke von S durch den Platz im Hauptspeicher geteilt. Das wird multipliziert mit M-1 Blöcken von S, addiert mit der Anzahl der Blöcke von R, für die innere Schleife. Das Ergebnis ist nur eine Abschätzung.
Die Formel sieht wie folgt aus:</p>
<p><span class="math notranslate nohighlight">\(\frac{B(S)}{M-1}(M-1+B(R)) = \frac{B(S)(M-1)}{M-1} - \frac{B(S)}{M-1} + \frac{B(S)B(R)}{M-1} \approx\frac {B(S)B(R)}{M}\)</span></p>
</section>
<section id="zusammenfassung-bisheriger-algorithmen">
<h3><span class="section-number">4.3.2. </span>Zusammenfassung bisheriger Algorithmen<a class="headerlink" href="#zusammenfassung-bisheriger-algorithmen" title="Permalink to this heading">#</a></h3>
<p>Hier einmal eine Übersicht darüber, wie viel Hauptspeicher die verschiedenen Operationen in den verschiedenen Varianten benötigen und wie viel I/O dabei verbraucht wird.</p>
<a class="reference internal image-reference" href="../_images/Zusammenfassung-Algorithmen.png"><img alt="Zusammenfassung-Algorithmen" src="../_images/Zusammenfassung-Algorithmen.png" style="width: 500px;" /></a>
</section>
</section>
<section id="sort-basierte-two-pass-algorithmen">
<h2><span class="section-number">4.4. </span>Sort-basierte Two-Pass Algorithmen<a class="headerlink" href="#sort-basierte-two-pass-algorithmen" title="Permalink to this heading">#</a></h2>
<p><strong>1-, 2-, Mehr-Phasen</strong></p>
<ul class="simple">
<li><p>Bisher: One-Pass Algorithmen; eine Relation passt in Hauptspeicher</p></li>
<li><p>Nun: Two-Pass Algorithmen; keine Relation passt in Hauptspeicher</p></li>
<li><p>Zwei Phasen</p>
<ul>
<li><p>Einlesen der Daten</p></li>
<li><p>Verarbeitung der Daten (hier: Sortierung von Teillisten)</p></li>
<li><p>Schreiben der Daten</p></li>
<li><p>Wiedereinlesen der Daten (hier: Merging der Teillisten)</p>
<ul>
<li><p>Hier unterscheiden sich die Algorithmen</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Mehr-Phasen?</p>
<ul>
<li><p>Zwei Phasen reichen meist</p></li>
<li><p>Verallgemeinerung zu Mehr-Phasen einfach</p></li>
</ul>
</li>
</ul>
<section id="id1">
<h3><span class="section-number">4.4.1. </span>Duplikateliminierung<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Idee: Ähnlich wie TPMMS</p></li>
<li><p>Phase 1 wie bisher</p>
<ul>
<li><p>Sortierschlüssel ist gesamtes Tupel</p></li>
</ul>
</li>
<li><p>Phase 2: Ein Block pro sortierter Teilliste</p>
<ul>
<li><p>Betrachte jeweils erstes Tupel</p></li>
<li><p>Suche kleinstes Tupel</p></li>
<li><p>Gib dieses Tupel aus; verwerfe alle anderen identischen Tupel</p></li>
</ul>
</li>
<li><p>Beispiel</p>
<ul>
<li><p>M = 3 + 1; 2 Tupel pro Block</p></li>
<li><p>17 Tupel: 2, 5, 2, 1, 2, 2, 4, 5, 4, 3, 4, 2, 1, 5, 2, 1, 3</p></li>
<li><p>Phase 1: 3 sortierte Teillisten</p></li>
<li><p>Phase 2: s.o.</p></li>
</ul>
</li>
<li><p>Verbesserung schon in Phase 1?</p>
<ul>
<li><p>Duplikateliminierung in Teillisten -&gt; Kleinere Teillisten</p></li>
</ul>
</li>
</ul>
<p><strong>Duplikateliminierung Kosten</strong></p>
<ul class="simple">
<li><p>Wie TPMMS</p></li>
</ul>
<ol class="arabic simple">
<li><p>B® für Einlesen in Phase 1</p></li>
<li><p>B® für Schreiben der Teillisten</p></li>
<li><p>B® für Lesen der Teillisten</p>
<ul class="simple">
<li><p>Zusammen: 3·B®</p></li>
</ul>
</li>
</ol>
<ul class="simple">
<li><p>One-pass Algorithmus: 1·B®</p></li>
<li><p>Aber hier größerer Input möglich</p>
<ul>
<li><p>One-pass: B ≤ M</p></li>
<li><p>Two-pass: B ≤ M²</p></li>
</ul>
</li>
</ul>
</section>
<section id="gruppierung-und-aggregation">
<h3><span class="section-number">4.4.2. </span>Gruppierung und Aggregation<a class="headerlink" href="#gruppierung-und-aggregation" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Phase 1</p></li>
</ul>
<ol class="arabic simple">
<li><p>Lese R ein (jeweils M Blöcke)</p></li>
<li><p>Sortiere M Blöcke nach Gruppierungsattribut(en)</p></li>
<li><p>Schreibe sortierte Teillisten</p></li>
</ol>
<ul class="simple">
<li><p>Phase 2</p></li>
</ul>
<ol class="arabic simple">
<li><p>Lade jeweils einen Block jeder Teilliste</p></li>
<li><p>Suche kleinste Schlüssel (neue Gruppe)</p></li>
<li><p>Aggregiere alle Tupel mit diesem Schlüssel</p>
<ul class="simple">
<li><p>Gegebenenfalls Blöcke nachladen</p></li>
</ul>
</li>
<li><p>Gebe ein Tupel mit aggregierten Werten (und gegebenenfalls Gruppierungsattribut) aus.</p></li>
<li><p>Suche nächst kleineren Schlüssel</p></li>
</ol>
<ul class="simple">
<li><p>I/O-Kosten: 3B® Maximale Größe: B® ≤ M²</p></li>
<li><p>Verbesserung Phase 1: Aggregation schon auf Teillisten</p>
<ul>
<li><p>„Pre-Aggregation“: Besonders wichtig für verteilte DBMS</p></li>
</ul>
</li>
</ul>
</section>
<section id="vereinigung-binar">
<h3><span class="section-number">4.4.3. </span>Vereinigung (binär)<a class="headerlink" href="#vereinigung-binar" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Lese R ein und schreibe sortierte Teillisten</p>
<ul class="simple">
<li><p>Sortierschlüssel ist gesamtes Tupel</p></li>
</ul>
</li>
<li><p>Lese S ein und schreibe sortierte Teillisten</p>
<ul class="simple">
<li><p>Sortierschlüssel ist gesamtes Tupel</p></li>
</ul>
</li>
<li><p>Lese jeweils einen Block aus beiden Mengen sortierter Teillisten</p></li>
<li><p>Suche kleinste Tupel aus allen Blöcken</p>
<ul class="simple">
<li><p>-&gt; Ausgabe</p></li>
<li><p>Entfernung aus allen anderen Teillisten</p>
<ul>
<li><p>Zur Not: Blöcke nachladen</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Suche nächstes kleinstes Tupel</p></li>
</ol>
<ul class="simple">
<li><p>Funktioniert für Mengen und Multimengen</p>
<ul>
<li><p>Bei Multimengen ist one-pass Algorithmus besser</p></li>
</ul>
</li>
<li><p>I/O-Kosten: 3(B® + B(S))</p></li>
<li><p>Maximale Größe: B® + B(S) ≤ M²</p></li>
</ul>
</section>
<section id="schnittmenge-und-differenz">
<h3><span class="section-number">4.4.4. </span>Schnittmenge und Differenz<a class="headerlink" href="#schnittmenge-und-differenz" title="Permalink to this heading">#</a></h3>
<ol class="arabic simple">
<li><p>Sortierung und Laden der Teillisten wie bei Vereinigung</p></li>
<li><p>Suche kleinstes Tupel t</p></li>
<li><p>Zählen</p>
<ul class="simple">
<li><p>count(R, t) = Anzahl der Vorkommen von t in R</p></li>
<li><p>count(S, t) analog</p></li>
<li><p>Gegebenenfalls nachladen</p></li>
</ul>
</li>
<li><p>Ausgabe je nach Operator</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\cap_{S}\)</span>: Ausgabe von t falls count(R, t) &gt; 0 und count(S, t)&gt;0</p></li>
<li><p><span class="math notranslate nohighlight">\(\cap_{B}\)</span>gebenenfalls nicht ausgeben (wenn ein count = 0)</p></li>
<li><p><span class="math notranslate nohighlight">\(R-_{S}S\)</span>: Ausgabe von t falls count(R, t) &gt; 0 und count(S, t) = 0</p></li>
<li><p><span class="math notranslate nohighlight">\(R-_{B}S\)</span>: Ausgabe von t max[0, count(R, t) -count(S, t)] mal</p></li>
</ul>
</li>
<li><p>Suche nächstes kleinstes Tupel t …</p></li>
</ol>
<ul class="simple">
<li><p>I/O-Kosten: 3(B® + B(S))</p></li>
<li><p>Maximale Größe: B® + B(S) ≤ M²</p></li>
</ul>
</section>
<section id="einfacher-sort-basierter-join-algorithmus">
<h3><span class="section-number">4.4.5. </span>Einfacher, Sort-basierter Join Algorithmus<a class="headerlink" href="#einfacher-sort-basierter-join-algorithmus" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Neues Problem bei Join: Alle Tupel mit gleichem Joinattributwert müssen gleichzeitig im Hauptspeicher sein.</p></li>
<li><p>Lösungsidee: Reserviere so viel Speicher wie möglich für aktuelle Jointupel</p>
<ul>
<li><p>Reduziere Speicherbedarf anderer Algorithmusteile</p></li>
</ul>
</li>
<li><p>R(X, Y) ⋈ S(Y, Z)</p></li>
<li><p>Phase 1: Sortiere R und S jeweils gemäß Y mit TPMMS</p>
<ul>
<li><p>Inkl. letzter Phase (Schreiben des sortierten Ergebnisses)</p></li>
</ul>
</li>
<li><p>Phase 2: Merge R und S</p></li>
</ul>
<ol class="arabic simple">
<li><p>Jeweils ein Block</p></li>
<li><p>Suche insgesamt kleinstes Y in beiden Blocks</p></li>
<li><p>Falls nicht in anderem Block vorhanden: Entferne alle Tupel mit diesem Y</p></li>
<li><p>Falls vorhanden: Identifiziere alle Tupel mit diesem Y</p>
<ul class="simple">
<li><p>– Gegebenenfalls nachladen</p></li>
</ul>
</li>
<li><p>Gebe alle Kombinationen aus</p></li>
</ol>
<p><strong>Kosten</strong></p>
<ul class="simple">
<li><p>R: 1000 Blocks; S: 500 Blocks; M = 101</p></li>
<li><p>TPMMS: 4·B® + 4·B(S) = 4·1500 = 6000 I/O</p></li>
<li><p>Merging: Nochmals R und S lesen: 1500 I/O</p>
<ul>
<li><p>Nur 2 Blocks werden benötigt</p></li>
<li><p>Aber: Alle Tupel mit einem bestimmten Y-Wert müssen in 98 Blöcke passen</p></li>
</ul>
</li>
<li><p>I/O: 5(B® + B(S)) = 7500 I/O</p></li>
<li><p>Hauptspeicher: B®≤M² und B(S)≤M²</p></li>
<li><p>Vergleich zu nested loops: 5500 I/O</p>
<ul>
<li><p>Aber nested loops ist quadratisch: B®B(S)/M</p></li>
<li><p>Sort-based join ist linear</p></li>
<li><p>Gleich noch Verbesserung auf 3(B® + B(S))</p></li>
</ul>
</li>
</ul>
<p><strong>Erweiterung</strong></p>
<ul class="simple">
<li><p>Falls alle Tupel (beider Relationen) mit einem bestimmten Y-Wert nicht in Hauptspeicher passen</p>
<ul>
<li><p>Falls alle solche Tupel einer Relation in M−1 Blöcke passen</p>
<ul>
<li><p>One-pass join für diesen Y-Wert</p></li>
</ul>
</li>
<li><p>Falls nicht: Nested loop join</p></li>
</ul>
</li>
<li><p>Fallunterscheidung kann überflüssiges I/O vermeiden.</p></li>
<li><p>Diskussion</p>
<ul>
<li><p>Y ist oft in einer Relation ein Schlüssel =&gt; leicht</p></li>
</ul>
</li>
</ul>
<p><strong>Verbesserung des Sort-basierter Join Algorithmus</strong></p>
<ul class="simple">
<li><p>Idee: Kombiniere 2te Phase des TPMMS mit dem Joinen</p>
<ul>
<li><p>=&gt; („sort-join“, „merge-join“) „sort-merge-join“</p></li>
</ul>
</li>
</ul>
<ol class="arabic simple">
<li><p>Erzeuge sortierte Teillisten der Größe M jeweils für R und S mit Y als Sortierschlüssel</p></li>
<li><p>Lade erste Blöcke aller Teillisten (beider Relationen)</p></li>
<li><p>Suche kleinste Y-Werte und erzeuge Jointupel</p></li>
</ol>
<ul class="simple">
<li><p>Annahmen</p>
<ul>
<li><p>Anzahl aller Teillisten (aus R und S) ≤ M</p></li>
<li><p>Tupel mit gemeinsamen Y-Werten passen zusammen in verbleibenden Hauptspeicher</p></li>
</ul>
</li>
<li><p>R: 1000 Blocks; S: 500 Blocks; M = 101</p>
<ul>
<li><p>Phase 1: 10 Teillisten für R, 5 Teillisten für S</p></li>
<li><p>Phase 2: 15 Blöcke gleichzeitig im Hauptspeicher</p>
<ul>
<li><p>=&gt; 86 freie Blöcke für aktuelle Join-Tupel</p></li>
</ul>
</li>
<li><p>Zusammen 3(B® + B(S)) = 4500 I/O</p></li>
</ul>
</li>
<li><p>Oft sind viele Speicherblöcke übrig, da B®+B(S) &lt;&lt; M²</p></li>
</ul>
</section>
<section id="zusammenfassung-sortbasierte-two-pass-algorithmen">
<h3><span class="section-number">4.4.6. </span>Zusammenfassung – sortbasierte, two-pass Algorithmen<a class="headerlink" href="#zusammenfassung-sortbasierte-two-pass-algorithmen" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Zusammenfassung-sort-basierte-Algorithmen_2.png"><img alt="Zusammenfassung-sort-basierte-Algorithmen_2" src="../_images/Zusammenfassung-sort-basierte-Algorithmen_2.png" style="width: 500px;" /></a>
</section>
</section>
<section id="hash-basierte-two-pass-algorithmen">
<h2><span class="section-number">4.5. </span>Hash-basierte Two-Pass Algorithmen<a class="headerlink" href="#hash-basierte-two-pass-algorithmen" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Input passt nicht in Hauptspeicher (wie immer).</p></li>
<li><p>Hashe alle Inputargumente.</p>
<ul>
<li><p>Tupel, die gemeinsam betrachtet werden müssen, erhalten gleichen Hashwert.</p></li>
<li><p>Landen also in einem Bucket</p></li>
</ul>
</li>
<li><p>Unäre Operatoren: Bearbeite anschließend einen Bucket nach dem anderen</p></li>
<li><p>Binäre Operatoren: Bearbeite anschließend Paare von Buckets</p></li>
<li><p>Oft: Mehr als ein Block pro Bucket</p></li>
<li><p>Allgemein: Reduktion des Speicherbedarfs um Faktor M im Vergleich zu Größe der Relationen</p>
<ul>
<li><p>Verwende ≤M Buckets</p></li>
<li><p>Jeder einzelne Bucket muss in Hauptspeicher passen.</p></li>
</ul>
</li>
</ul>
<section id="partitionierung-mittels-hashing">
<h3><span class="section-number">4.5.1. </span>Partitionierung mittels Hashing<a class="headerlink" href="#partitionierung-mittels-hashing" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Grundalgorithmus</p></li>
<li><p>Gegeben M Speicherblöcke, verteile R auf M−1 Buckets</p>
<ul>
<li><p>Möglichst gleicher Größe</p></li>
<li><p>Ein Bucket pro Speicherblock</p></li>
</ul>
</li>
<li><p>Letzter Speicherblock für Einlesen der Tupel aus R</p></li>
<li><p>Idee</p>
<ul>
<li><p>Für jedes Tupel aus R berechne h(t) und bewege Tupel in entsprechenden Bucket.</p></li>
<li><p>Falls Block voll: Schreibe als Overflowblock auf Disk</p></li>
<li><p>Am Ende: Schreibe auch alle Buckets auf Disk</p></li>
</ul>
</li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">initialize</span> <span class="n">M</span><span class="o">-</span><span class="mi">1</span> <span class="n">buckets</span> <span class="n">using</span> <span class="n">M</span><span class="o">-</span><span class="mi">1</span> <span class="n">empty</span> <span class="n">buffers</span><span class="p">;</span>
<span class="n">FOR</span> <span class="n">each</span> <span class="n">block</span> <span class="n">b</span> <span class="n">of</span> <span class="n">R</span> <span class="n">DO</span> <span class="n">BEGIN</span>
    <span class="n">read</span> <span class="n">block</span> <span class="n">b</span> <span class="n">into</span> <span class="n">M</span><span class="o">-</span><span class="n">th</span> <span class="n">buffer</span>
    <span class="n">FOR</span> <span class="n">each</span> <span class="nb">tuple</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">b</span> <span class="n">DO</span> <span class="n">BEGIN</span>
        <span class="n">IF</span> <span class="n">buffer</span> <span class="k">for</span> <span class="n">bucket</span> <span class="n">h</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">has</span> <span class="n">no</span> <span class="n">room</span> <span class="k">for</span> <span class="n">t</span> <span class="n">THEN</span>
            <span class="n">BEGIN</span>
                <span class="n">copy</span> <span class="n">the</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">disk</span><span class="p">;</span> <span class="o">/*</span> <span class="n">spill</span> <span class="o">*/</span>
                <span class="n">initialize</span> <span class="n">a</span> <span class="n">new</span> <span class="n">empty</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">that</span> <span class="n">buffer</span><span class="p">;</span>
            <span class="n">END</span><span class="p">;</span>
        <span class="n">copy</span> <span class="n">t</span> <span class="n">to</span> <span class="n">buffer</span> <span class="k">for</span> <span class="n">bucket</span> <span class="n">h</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="n">END</span><span class="p">;</span>
<span class="n">END</span><span class="p">;</span>
<span class="n">FOR</span> <span class="n">each</span> <span class="n">bucket</span> <span class="n">DO</span>
    <span class="n">IF</span> <span class="n">the</span> <span class="n">buffer</span> <span class="k">for</span> <span class="n">this</span> <span class="n">bucket</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span> <span class="n">THEN</span>
        <span class="n">write</span> <span class="n">the</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">disk</span><span class="p">;</span>
        
</pre></div>
</div>
</section>
<section id="duplikateliminierung-delta-r">
<h3><span class="section-number">4.5.2. </span>Duplikateliminierung <span class="math notranslate nohighlight">\(\delta(R)\)</span><a class="headerlink" href="#duplikateliminierung-delta-r" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Algorithmus wie eben:</p>
<ul>
<li><p>Ganzes Tupel als Hash-Input (ist das nötig?)</p></li>
</ul>
</li>
<li><p>Duplikate landen im gleichen Bucket.</p></li>
<li><p>Betrachte jeden Bucket einzeln.</p>
<ul>
<li><p>Duplikateliminierung innerhalb des Buckets</p></li>
<li><p>Danach Bucket ausgeben</p></li>
</ul>
</li>
<li><p>Annahme: Alle Blöcke eines Buckets passen in Hauptspeicher</p>
<ul>
<li><p>=&gt; One-pass Algorithmus funktioniert pro Bucket</p></li>
<li><p>Bei Gleichverteilung durch h: Bucket hat B®/(M−1) Blöcke</p></li>
<li><p>=&gt; R darf bis zu M(M−1) viele Blöcke umfassen</p></li>
<li><p>Vermutlich noch besser (wie zuvor): Es müssen nur distinct Tupel in Hauptspeicher passen</p></li>
</ul>
</li>
<li><p>I/O-Kosten: 3·B®</p></li>
</ul>
</section>
<section id="gruppierung-und-aggregation-gamma-l-r">
<h3><span class="section-number">4.5.3. </span>Gruppierung und Aggregation <span class="math notranslate nohighlight">\(\gamma_{L}(R)\)</span><a class="headerlink" href="#gruppierung-und-aggregation-gamma-l-r" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Grundalgorithmus wie zuvor</p></li>
<li><p>Aber: Hashfunktion hängt nur von Gruppierungsattributen ab.</p>
<ul>
<li><p>Problem oft: Nur wenig verschiedene Werte (z.B. Bundesland)</p></li>
<li><p>=&gt; nur wenige (und damit große) Buckets</p></li>
</ul>
</li>
<li><p>Dann: One-pass Algorithmus für Gruppierung auf jedem Bucket</p></li>
<li><p>Hauptspeicherbedarf: B® ≤ M²</p>
<ul>
<li><p>Vermutlich viel geringer: Nur ein Tupel pro Gruppe/Bucket im Hauptspeicher</p></li>
</ul>
</li>
<li><p>I/O-Kosten: 3·B®</p></li>
</ul>
</section>
<section id="mengenoperationen">
<h3><span class="section-number">4.5.4. </span>Mengenoperationen<a class="headerlink" href="#mengenoperationen" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Bei binären Operationen: Gleiche Hashfunktion für beide Inputs!</p></li>
<li><p>Mengenvereinigung:</p>
<ul>
<li><p>Hashe R und S jeweils auf M−1 Buckets</p></li>
<li><p>Bilde Mengenvereinigung passender Bucketpaare</p></li>
</ul>
</li>
<li><p>Wieder: Jeweils One-pass Algorithmus anwenden</p></li>
<li><p>Multimengenvereinigung: Voriger Algorithmus</p></li>
<li><p>Speicherbedarf: min(B®, B(S)) ≤ (M−1)²</p>
<ul>
<li><p>Warum?</p></li>
<li><p>Da bei One-pass Varianten kleinere Relation in Hauptspeicher passen muss</p></li>
</ul>
</li>
<li><p>I/O-Kosten: 3·(B® + B(S))</p></li>
</ul>
</section>
<section id="hashjoin">
<h3><span class="section-number">4.5.5. </span>Hashjoin<a class="headerlink" href="#hashjoin" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Algorithmus wie zuvor</p></li>
<li><p>Aber: Hashschlüssel sind Joinattribute</p>
<ul>
<li><p>Tupel mit gleichen Joinattributwerten landen im korrespondierenden Bucket.</p></li>
</ul>
</li>
<li><p>Danach One-pass Join Variante für jedes Bucket-Paar</p></li>
<li><p>Beispiel von zuvor: B® = 1000, B(S) = 500, M = 101</p></li>
<li><p>Hashing</p>
<ul>
<li><p>Ca. 10 R-Blocks pro Bucket</p></li>
<li><p>Ca. 5 S-Blocks pro Bucket</p></li>
</ul>
</li>
<li><p>Min(10, 5) = 5 =&gt; One-pass Algorithmus klappt (5 &lt; 101)</p>
<ul>
<li><p>Hole ersten S-Bucket in Hauptspeicher;</p></li>
<li><p>Joine Blöcke des passenden R-Buckets hinzu</p></li>
<li><p>Hole nächsten S-Bucket in Hauptspeicher … usw …</p></li>
</ul>
</li>
<li><p>I/O-Kosten:</p>
<ul>
<li><p>1500 für das Hashing + 1500 um Buckets zu schreiben</p></li>
<li><p>1500 um Buckets zu lesen</p></li>
<li><p>Zusammen: 3(B® + B(S)) = 4500 (wie sort-basierte Methode)</p></li>
</ul>
</li>
<li><p>Aber es geht noch besser.</p></li>
</ul>
</section>
<section id="i-o-einsparungen">
<h3><span class="section-number">4.5.6. </span>I/O Einsparungen<a class="headerlink" href="#i-o-einsparungen" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Grundidee: Nutze nicht-verwendeten Speicher</p>
<ul>
<li><p>Idee 1: Verwende mehr als 1 Speicherblock pro Bucket</p>
<ul>
<li><p>Effizienteres Schreiben (aber gleiche I/O-Kosten)</p></li>
</ul>
</li>
<li><p>Idee 2: Hybrid Hashjoin</p>
<ul>
<li><p>Beim Hashen von S: Behalte m Buckets komplett im Speicher</p>
<ul>
<li><p>Auch nach Ende des Hashens</p></li>
<li><p>Jeweils mit geeigneter Datenstruktur</p></li>
</ul>
</li>
<li><p>Schon in der Hash-Phase von R: Join-Tupel in den m Buckets produzieren</p>
<ul>
<li><p>Für alle anderen Buckets wie bisher: Join in zweiter Phase</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="i-o-einsparungen-hybrid-hashjoin">
<h3><span class="section-number">4.5.7. </span>I/O Einsparungen – Hybrid Hashjoin<a class="headerlink" href="#i-o-einsparungen-hybrid-hashjoin" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Beim Hashen von S: Behalte m Buckets komplett im Speicher.</p></li>
<li><p>Falls k Buckets insgesamt für S nötig sind: Verwende für die übrigen k – m Buckets jeweils nur einen Block im Hauptspeicher beim Hashen.</p></li>
<li><p>Es muss gelten: ( m · B(S)/k ) + 1 · (k – m) ≤ M</p>
<ul>
<li><p>Wähle also m entsprechend</p></li>
</ul>
</li>
<li><p>Schreibe die k – m Rest-Blöcke auf Disk.</p></li>
<li><p>Beim Hashen von R sind nun im Hauptspeicher:</p>
<ul>
<li><p>m vollständige Buckets für S</p></li>
<li><p>je ein Block für die k–m Buckets von R, deren korrespondierende S-Buckets auf Disk sind</p></li>
</ul>
</li>
<li><p>Falls Tupel t aus R in einen der m Buckets gehasht wird:</p>
<ul>
<li><p>Joinpartner suchen</p></li>
<li><p>Gegebenenfalls direkte Ausgabe</p></li>
</ul>
</li>
<li><p>Falls t in einen der k–m Buckets gehasht wird</p>
<ul>
<li><p>Verfahre wie zuvor: Auf Disk schreiben</p></li>
</ul>
</li>
<li><p>Phase 2 dann nur noch auf den k – m Buckets</p></li>
</ul>
</section>
<section id="hybrid-hashjoin-analyse">
<h3><span class="section-number">4.5.8. </span>Hybrid Hashjoin – Analyse<a class="headerlink" href="#hybrid-hashjoin-analyse" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Einsparungen</p>
<ul>
<li><p>Spare 2 I/Os für jeden Block, der im Hauptspeicher gehalten werden kann (nämlich m/k aller Buckets)</p></li>
<li><p>Einsparung also 2(m/k) (B® + B(S))</p></li>
</ul>
</li>
<li><p>=&gt; Maximiere (m/k), gegeben ( m · B(S)/k ) + k – m ≤ M</p>
<ul>
<li><p>Lösung: Wähle m = 1 und minimiere k.</p>
<ul>
<li><p>Intuition: Alle Puffer bis auf k – m werden verwendet, um Tupel im Hauptspeicher zu halten; davon bitte möglichst viele.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Minimierung von k (gesamte Anzahl der Buckets): Wähle Bucketgröße so, dass ein Bucket gerade eben in Hauptspeicher passt.</p>
<ul>
<li><p>Bucketgröße M</p></li>
<li><p>=&gt; k = B(S) / M</p>
<ul>
<li><p>=&gt; nur ein Bucket passt in Hauptspeicher (=&gt; m = 1)</p></li>
</ul>
</li>
<li><p>Bucketgröße eigentlich etwas kleiner, damit die übrigen (wenigen) Buckets durch mindestens einen Block repräsentiert werden können</p></li>
</ul>
</li>
<li><p>=&gt; Einsparungen 2(m/k) (B® + B(S)) = 2 (1/ (B(S)/M) ) · (B® + B(S)) = (2M / B(S)) · (B® + B(S))</p></li>
<li><p>=&gt; I/O-Kosten: (3 – (2M/B(S))) · (B® + B(S))</p></li>
</ul>
<p>=&gt; Wähle wenige große Buckets statt viele kleine</p>
<p><strong>Hybrid Hashjoin – Beispiel</strong></p>
<ul class="simple">
<li><p>B® = 1000, B(S) = 500, M = 101</p></li>
<li><p>Wähle z.B. k = B(S) / M = 500 / 101 ≈ 5</p>
<ul>
<li><p>=&gt; Ein Bucket hat ca. 100 Blocks</p></li>
<li><p>=&gt; 104 Hauptspeicher nötig (&gt; 101)</p>
<ul>
<li><p>+1 für Lesen der Relation</p></li>
</ul>
</li>
<li><p>=&gt; Besser k = 6</p></li>
</ul>
</li>
<li><p>Je 1 Puffer für erste 5 Buckets +1 für Lesen der Relation und 95 Puffer für letzten Bucket</p>
<ul>
<li><p>Erwartete Größe: 500/6 ≈ 83</p></li>
</ul>
</li>
<li><p>Phase 1</p>
<ul>
<li><p>I/O-Kosten für S: 500x lesen und 417x schreiben</p></li>
<li><p>I/O-Kosten für R: 1000x lesen und 833x schreiben (5 der 6 Buckets)</p></li>
</ul>
</li>
<li><p>Phase 2</p>
<ul>
<li><p>Alle geschriebenen Blöcke wieder lesen: 417 + 833 = 1250</p></li>
</ul>
</li>
<li><p>Zusammen: 500 + 1000 + 2·(417 + 833) = 4000 I/Os</p>
<ul>
<li><p>&lt; 4500 bei einfachen Hash-Join bzw. Sort merge Join!</p></li>
</ul>
</li>
<li><p>Warum nur von S (und nicht von R) abhängig?</p></li>
</ul>
</section>
<section id="zusammenfassung-hash-basierter-verfahren">
<h3><span class="section-number">4.5.9. </span>Zusammenfassung Hash-basierter Verfahren<a class="headerlink" href="#zusammenfassung-hash-basierter-verfahren" title="Permalink to this heading">#</a></h3>
<a class="reference internal image-reference" href="../_images/Zusammenfassung-Hashbasierte-Verfahren.png"><img alt="Zusammenfassung-Hashbasierte-Verfahren" src="../_images/Zusammenfassung-Hashbasierte-Verfahren.png" style="width: 500px;" /></a>
<p><strong>Wdh.: Sort-basierte, two-pass Algorithmen</strong></p>
<a class="reference internal image-reference" href="../_images/Zusammenfassung-sort-basierte-Algorithmen_2.png"><img alt="Zusammenfassung-sort-basierte-Algorithmen_2" src="../_images/Zusammenfassung-sort-basierte-Algorithmen_2.png" style="width: 500px;" /></a>
<p><strong>Vergleich Hash-basierte und Sort-basierte Algorithmen</strong></p>
<ul class="simple">
<li><p>Speicherbedarf und I/O-Kosten ähnlich</p></li>
<li><p>Speicherbedarf Hash-basierter Verfahren hängt nur vom kleineren der beiden Inputs statt Summe der beiden Inputs ab.</p></li>
<li><p>Sortier-basierte Verfahren produzieren oft einen sortierten Output</p>
<ul>
<li><p>Vorteile später im Plan</p></li>
</ul>
</li>
<li><p>Sortierbasierte Verfahren können sortierte Teilliste hintereinander auf Disk schreiben</p>
<ul>
<li><p>Spart bei einer I/O-Operation Seektime</p></li>
<li><p>Bei großem M: Auch mehrere Blöcke einer Liste auf einmal lesen</p></li>
</ul>
</li>
<li><p>Gleiches auch bei Hash-basierten Verfahren möglich, falls Anzahl Buckets kleiner als M</p></li>
</ul>
</section>
</section>
<section id="index-basierte-algorithmen">
<h2><span class="section-number">4.6. </span>Index-basierte Algorithmen<a class="headerlink" href="#index-basierte-algorithmen" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Indizes ermöglichen manchmal andere Algorithmen.</p></li>
<li><p>Insbesondere Selektion</p></li>
<li><p>Aber auch: Joins und andere binäre Operatoren</p></li>
<li><p>Clustered Relation</p>
<ul>
<li><p>Tupel auf so wenig wie möglich Blöcken auf Disk</p></li>
</ul>
</li>
<li><p>Clustering Index</p>
<ul>
<li><p>Tupel mit gleichem Schlüsselwert sind auf so wenig wie möglich Blöcken</p>
<ul>
<li><p>Eventuell +1 Block wegen Layout</p></li>
</ul>
</li>
<li><p>Oft: Relation ist bereits clustered und clustering index ist auf dem Primärschlüssel</p></li>
</ul>
</li>
<li><p>Eine clustered Relation kann auch non-Cluster-Indizes haben.</p></li>
</ul>
<section id="index-basierte-selektion">
<h3><span class="section-number">4.6.1. </span>Index-basierte Selektion<a class="headerlink" href="#index-basierte-selektion" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Basisalgorithmus: Lese gesamte Relation ein und prüfe Bedingung</p>
<ul>
<li><p>Ohne Index ist dies die beste Methode</p></li>
<li><p>I/O-Kosten: B® bzw. T® falls R nicht clustered</p></li>
</ul>
</li>
<li><p>Besser: Selektionsbedingung a=v und a ist Suchschlüssel eines Cluster-Indexes</p>
<ul>
<li><p>I/O-Kosten: <span class="math notranslate nohighlight">\(\lceil B(R)/V(R,a)\rceil\)</span></p>
<ul>
<li><p>Reminder: V(R,L) = Anzahl distinct Werte von pL®</p></li>
</ul>
</li>
<li><p>Eventuell mehr</p>
<ul>
<li><p>I/O-Kosten für Index</p></li>
<li><p>Tupel nicht perfekt auf Blöcke verteilt: 1 Block extra</p></li>
<li><p>Blöcke nicht absolut vollgepackt</p></li>
<li><p>Fremde Tupel auf Blöcken</p></li>
<li><p>Aufrunden: a ist Schlüssel =&gt; V(R,a) = T® &gt;&gt; B®</p></li>
<li><p>Dennoch mindestens 1 Block</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Selektionsbedingung a=v und a ist Suchschlüssel eines nicht-Cluster-Indexes</p></li>
<li><p>=&gt; Jedes Tupel auf anderen Block (vermutlich)</p></li>
<li><p>I/O-Kosten: <span class="math notranslate nohighlight">\(\lceil T(R) / V(R,a)\rceil\)</span></p>
<ul>
<li><p>Wieder zusätzliche I/O-Kosten: Indizes</p></li>
<li><p>Etwas besser, falls zufällig mehr als ein Tupel auf dem Block</p></li>
</ul>
</li>
</ul>
<p><strong>Index-basierte Selektion – Beispiel</strong></p>
<ul class="simple">
<li><p>Beispiel: B® = 1000, T® = 20000 (=&gt; 20 Tupel pro Block)</p>
<ul>
<li><p>Anfrage: sa=0®; Index auf a</p></li>
<li><p>R ist clustered; Index wird nicht verwendet:</p>
<ul>
<li><p>1000 I/Os</p></li>
</ul>
</li>
<li><p>R nicht clustered; Index wird nicht verwendet:</p>
<ul>
<li><p>20000 I/Os</p></li>
</ul>
</li>
<li><p>V(R,a)=100; Index ist clustering:</p>
<ul>
<li><p>1000/100 = 10 I/Os</p></li>
</ul>
</li>
<li><p>V(R,a) = 10; Index ist nicht clustering:</p>
<ul>
<li><p>20000/10 = 2000 I/Os</p></li>
<li><p>Falls R clustered: Lieber ganz R einlesen (1000 I/O)</p></li>
</ul>
</li>
<li><p>V(R,a) = 20000 (d.h. a ist Schlüssel):</p>
<ul>
<li><p>1 I/O</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="joining-mit-index">
<h3><span class="section-number">4.6.2. </span>Joining mit Index<a class="headerlink" href="#joining-mit-index" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Natural Join: R(X,Y) ⋈ S(Y,Z)</p></li>
<li><p>Algorithmus</p>
<ul>
<li><p>S habe Index auf Y.</p></li>
<li><p>Lese jeden Block in R.</p></li>
<li><p>Für jedes Tupel: Extrahiere Y-Wert und verwende Index um entsprechendes S-Tupel zu finden</p></li>
</ul>
</li>
<li><p>Kosten</p>
<ul>
<li><p>Falls R clustered: B®</p></li>
<li><p>Für jedes der T® Tupel muss man durchschnittlichT(S)/V(S,Y) Tupel lesen.</p>
<ul>
<li><p>Falls Index nicht clustering ist: T® · T(S)/V(S,Y)</p></li>
<li><p>Falls Index clustering: T® · B(S)/V(S,Y) bzw. genauer: T® · max[ 1 , B(S) / V(S,Y)]</p></li>
<li><p>Dominiert Kosten B® bzw. T®</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Joining mit Index – Beispiel</strong></p>
<ul class="simple">
<li><p>B® = 1000, B(S) = 500, T® = 10000, T(S) = 5000</p>
<ul>
<li><p>10 Tupel pro Block</p></li>
</ul>
</li>
<li><p>V(S,Y) = 100 (also 100 distinct Y-Werte in S)</p></li>
<li><p>R sei clustered; Index auf S[Y] sei clustering</p></li>
<li><p>I/O-Kosten:</p>
<ul>
<li><p>1000 zum Lesen von R</p></li>
<li><p>10000 · 500/100 = 50000 I/Os zum Vergleich mit S</p></li>
</ul>
</li>
<li><p>Diskussion</p>
<ul>
<li><p>Klappt besser falls R sehr klein =&gt; Viele Blöcke von S werden nie angefasst</p></li>
<li><p>Bei Hash- und Sort-basierten Methoden werden hingegen immer ganz R und ganz S betrachtet</p></li>
</ul>
</li>
</ul>
<p><strong>Joining mit sortiertem Index</strong></p>
<ul class="simple">
<li><p>Sortierter, dichtbesetzter Index, z.B. B-Baum</p></li>
<li><p>Idee 1: Sort-Merge-Join, aber nur eine Relation muss vorher sortiert werden.</p></li>
<li><p>Idee 2: Falls beide Relationen sortierten Index auf Y haben: Nur noch Merge-Phase</p>
<ul>
<li><p>„Zig-Zag-Join“</p></li>
<li><p>Tupel aus R ohne Joinpartner in S werden nie gelesen (und umgekehrt)</p></li>
</ul>
</li>
</ul>
<a class="reference internal image-reference" href="../_images/Joining-mit-sortiertem-Index.png"><img alt="Joining-mit-sortiertem-Index" src="../_images/Joining-mit-sortiertem-Index.png" style="width: 500px;" /></a>
<a class="reference internal image-reference" href="../_images/Joining-mit-sortiertem-Index-meme.png"><img alt="Joining-mit-sortiertem-Index-meme" src="../_images/Joining-mit-sortiertem-Index-meme.png" style="width: 500px;" /></a>
<p><strong>Joining mit Indizes – Beispiel</strong></p>
<ul class="simple">
<li><p>B® = 1000, B(S) = 500, T® = 10000, T(S) = 5000, M = 100</p></li>
<li><p>Idee 1: Seien R und S clustered; S habe sortierten Index auf Y; R habe keinen Index</p>
<ul>
<li><p>10 sortierte Teillisten für R: 2000 I/Os</p></li>
<li><p>Nun 11 Puffer: Einen für jede Teilliste, einen für Blöcke aus S</p>
<ul>
<li><p>Ganz R und ganz S werden gelesen: 1500 I/Os</p></li>
</ul>
</li>
<li><p>Zusammen 3500 I/O</p>
<ul>
<li><p>Wieder weniger als bisher! Aber sortierter Index wird vorausgesetzt…</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Idee 2: Nun habe R auch einen Index</p>
<ul>
<li><p>Sortierung der Relationen ist unnötig: Zig-Zag-Join</p></li>
<li><p>Schlimmstenfalls nur ganz R und ganz S lesen: 1500 I/O</p></li>
<li><p>Bei wenigen Joinpartnern: Viel weniger I/Os</p></li>
</ul>
</li>
</ul>
</section>
</section>
<section id="zusammenfassung">
<h2><span class="section-number">4.7. </span>Zusammenfassung<a class="headerlink" href="#zusammenfassung" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p>Physische Operatoren</p></li>
<li><p>One-Pass Algorithmen</p></li>
<li><p>Nested Loop Join</p></li>
<li><p>Sort-basierte Two-Pass Algorithmen</p></li>
<li><p>Hash-basierte Two-Pass Algorithmen</p></li>
<li><p>Index-basierte Algorithmen</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "LUH-DBS/GDBS_Script",
            ref: "main/",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./04"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="../03/indizes.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">3. </span>Indizes</p>
      </div>
    </a>
    <a class="right-next"
       href="../05/optimierung.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">5. </span>Optimierung</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#physische-operatoren">4.1. Physische Operatoren</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tabellen-scannen">4.1.1. Tabellen Scannen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#sortiertes-einlesen">4.1.2. Sortiertes Einlesen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#berechnungsmodell">4.1.3. Berechnungsmodell</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kostenparameter-statistiken">4.1.4. Kostenparameter / Statistiken</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#iteratoren">4.1.5. Iteratoren</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#one-pass-algorithmen">4.2. One-Pass Algorithmen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operatorklassen-fur-one-pass-verfahren">4.2.1. Operatorklassen für One-pass Verfahren</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tupel-basierte-unare-operatoren">4.2.2. Tupel-basierte unäre Operatoren</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#relationen-basierte-unare-operatoren">4.2.3. Relationen-basierte unäre Operatoren</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#duplikateliminierung">4.2.4. Duplikateliminierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gruppierung">4.2.5. Gruppierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#relationen-basierte-binare-operatoren">4.2.6. Relationen-basierte binäre Operatoren</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#vereinigung">4.2.6.1. Vereinigung</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#schnittmenge">4.2.6.2. Schnittmenge</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#mengen-differenz">4.2.6.3. Mengen-Differenz</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#multimengen-differenz">4.2.6.4. Multimengen-Differenz</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kreuzprodukt">4.2.6.5. Kreuzprodukt</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#natural-join">4.2.6.6. Natural Join</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nested-loop-join">4.3. Nested Loop Join</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#block-basierter-nlj">4.3.1. Block-basierter NLJ</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zusammenfassung-bisheriger-algorithmen">4.3.2. Zusammenfassung bisheriger Algorithmen</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sort-basierte-two-pass-algorithmen">4.4. Sort-basierte Two-Pass Algorithmen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">4.4.1. Duplikateliminierung</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gruppierung-und-aggregation">4.4.2. Gruppierung und Aggregation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#vereinigung-binar">4.4.3. Vereinigung (binär)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#schnittmenge-und-differenz">4.4.4. Schnittmenge und Differenz</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#einfacher-sort-basierter-join-algorithmus">4.4.5. Einfacher, Sort-basierter Join Algorithmus</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zusammenfassung-sortbasierte-two-pass-algorithmen">4.4.6. Zusammenfassung – sortbasierte, two-pass Algorithmen</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hash-basierte-two-pass-algorithmen">4.5. Hash-basierte Two-Pass Algorithmen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#partitionierung-mittels-hashing">4.5.1. Partitionierung mittels Hashing</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#duplikateliminierung-delta-r">4.5.2. Duplikateliminierung <span class="math notranslate nohighlight">\(\delta(R)\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#gruppierung-und-aggregation-gamma-l-r">4.5.3. Gruppierung und Aggregation <span class="math notranslate nohighlight">\(\gamma_{L}(R)\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mengenoperationen">4.5.4. Mengenoperationen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hashjoin">4.5.5. Hashjoin</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#i-o-einsparungen">4.5.6. I/O Einsparungen</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#i-o-einsparungen-hybrid-hashjoin">4.5.7. I/O Einsparungen – Hybrid Hashjoin</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hybrid-hashjoin-analyse">4.5.8. Hybrid Hashjoin – Analyse</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#zusammenfassung-hash-basierter-verfahren">4.5.9. Zusammenfassung Hash-basierter Verfahren</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#index-basierte-algorithmen">4.6. Index-basierte Algorithmen</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#index-basierte-selektion">4.6.1. Index-basierte Selektion</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#joining-mit-index">4.6.2. Joining mit Index</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#zusammenfassung">4.7. Zusammenfassung</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Prof. Dr. Ziawasch Abedjan
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>