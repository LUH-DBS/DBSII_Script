
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>2. Repräsentation &#8212; Online-Skript Datenbanksysteme II</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3. Indizes" href="../03/indizes.html" />
    <link rel="prev" title="1. Speicherung" href="../01/speicherung.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/DBIS_Kurzlogo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Online-Skript Datenbanksysteme II</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Datenbanksysteme II
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../01/speicherung.html">
   1. Speicherung
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   2. Repräsentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../03/indizes.html">
   3. Indizes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04/anfrageausfuehrung.html">
   4. Anfrageausführung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../05/optimierung.html">
   5. Optimierung
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../06/large-scale-data-management.html">
   6. Large Scale Data Management
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/LUH-DBS/GDBS_Script/main/?urlpath=tree/02/repraesentation.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
      <li>
        
<button onclick="initThebeSBT()"
  class="headerbtn headerbtn-launch-thebe"
  data-toggle="tooltip"
data-placement="left"
title="Launch Thebe"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="headerbtn__text-container">Live Code</span>
</button>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/LUH-DBS/GDBS_Script"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/LUH-DBS/GDBS_Script/issues/new?title=Issue%20on%20page%20%2F02/repraesentation.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/02/repraesentation.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#aufbau">
   2.1. Aufbau
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#felder-etc">
   2.2. Felder etc.
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#datentypen">
   2.3. Datentypen
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#datum-bit-boolean">
     2.3.1. Datum / Bit / Boolean
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#datensatze">
   2.4. Datensätze
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#datensatze-fester-lange">
     2.4.1. Datensätze fester Länge
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#versatz-zur-effizienz">
     2.4.2. Versatz zur Effizienz
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#speicherung-der-metadaten">
   2.5. Speicherung der Metadaten
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#aufteilung-in-blocke">
     2.5.1. Aufteilung in Blöcke
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#adressierung">
   2.6. Adressierung
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adressraum-des-servers">
     2.6.1. Adressraum des Servers
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#logische-adressen">
     2.6.2. Logische Adressen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hybride-adressierung">
     2.6.3. Hybride Adressierung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#columnar-storage">
     2.6.4. Columnar Storage
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#variable-langen">
   2.7. Variable Längen
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finden-von-feldern-variabler-lange">
     2.7.1. Finden von Feldern variabler Länge
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#datensatze-variabler-lange">
     2.7.2. Datensätze variabler Länge
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anwendungsfalls-sparsedatabeispiel-linkedopen-data">
     2.7.3. Anwendungsfalls SparseDataBeispiel: LinkedOpen Data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#microsoft-sql-server-sparse-columns">
     2.7.4. Microsoft SQL Server: SPARSE columns
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#zu-grosze-datensatze">
     2.7.5. Zu große Datensätze
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#datensatzanderungen">
   2.8. Datensatzänderungen
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Repräsentation</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#aufbau">
   2.1. Aufbau
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#felder-etc">
   2.2. Felder etc.
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#datentypen">
   2.3. Datentypen
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#datum-bit-boolean">
     2.3.1. Datum / Bit / Boolean
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#datensatze">
   2.4. Datensätze
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#datensatze-fester-lange">
     2.4.1. Datensätze fester Länge
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#versatz-zur-effizienz">
     2.4.2. Versatz zur Effizienz
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#speicherung-der-metadaten">
   2.5. Speicherung der Metadaten
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#aufteilung-in-blocke">
     2.5.1. Aufteilung in Blöcke
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#adressierung">
   2.6. Adressierung
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adressraum-des-servers">
     2.6.1. Adressraum des Servers
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#logische-adressen">
     2.6.2. Logische Adressen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hybride-adressierung">
     2.6.3. Hybride Adressierung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#columnar-storage">
     2.6.4. Columnar Storage
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#variable-langen">
   2.7. Variable Längen
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finden-von-feldern-variabler-lange">
     2.7.1. Finden von Feldern variabler Länge
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#datensatze-variabler-lange">
     2.7.2. Datensätze variabler Länge
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#anwendungsfalls-sparsedatabeispiel-linkedopen-data">
     2.7.3. Anwendungsfalls SparseDataBeispiel: LinkedOpen Data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#microsoft-sql-server-sparse-columns">
     2.7.4. Microsoft SQL Server: SPARSE columns
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#zu-grosze-datensatze">
     2.7.5. Zu große Datensätze
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#datensatzanderungen">
   2.8. Datensatzänderungen
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="reprasentation">
<h1><span class="section-number">2. </span>Repräsentation<a class="headerlink" href="#reprasentation" title="Permalink to this headline">#</a></h1>
<p>Bis hierhin haben wir nur auf einer sehr abstrakten Ebene besprochen, was für Daten wo liegen und wie diese Datenblöcke gelesen werden können. Womit wir uns noch nicht befasst haben, ist wo bestimmte Tupel und Blöcke liegen. Nach unserer intuitiven Vorstellung hoffen wir, dass alle Tupel einer Relation hintereinander im Speicher zu finden sind, das ist aber oftmals nicht der Fall. Nun muss ein Weg gefunden werden diese Tupel und Blöcke zu lesen, ohne bei jeder Anfrage die gesamte Festplatte lesen zu müssen.</p>
<p><strong>Architektur</strong></p>
<a class="reference internal image-reference" href="../_images/5-Schichten-Architektur1.png"><img alt="5-Schichten-Architektur" src="../_images/5-Schichten-Architektur1.png" style="width: 500px;" /></a>
<p>In diesem Kapitel befinden wir uns in der Systempufferschnittstelle. Hier geht es hauptsächlich um Seiten-/ und Blockverwaltung, Puffermanagment, sowie Cashing. Für uns ist die relevante Fragestellung, ob unsere gesuchten Tupel im Hauptspeicher sind oder nicht.</p>
<section id="aufbau">
<h2><span class="section-number">2.1. </span>Aufbau<a class="headerlink" href="#aufbau" title="Permalink to this headline">#</a></h2>
<p>Es gibt folgende Dateneinheiten:</p>
<ul class="simple">
<li><p><strong>Attributwerte</strong> sind Bytelisten oder auch “Felder” fester oder variabler Länge</p></li>
<li><p><strong>Tupel</strong> sind Feldlisten fester oder variabler Länge, auch genannt „Datensätze“</p></li>
<li><p><strong>Physische Blöcke</strong> speichern Datensatzmengen/-listen</p></li>
<li><p><strong>Relationen</strong> sind Mengen von Blöcken und bilden eine „Datei“, dazu gehören auch Indexstrukturen, wenn z.B ein <code class="docutils literal notranslate"><span class="pre">PRIMARY</span> <span class="pre">KEY</span></code> vorhanden ist</p></li>
</ul>
</section>
<section id="felder-etc">
<h2><span class="section-number">2.2. </span>Felder etc.<a class="headerlink" href="#felder-etc" title="Permalink to this headline">#</a></h2>
<p>Die kleinste Dateneinheit sind Attributwerte, diese werden durch „Felder“ (fields) repräsentiert. Die Fragestellungen die in diesem Themenabschnitt thematisiert werden sind:</p>
<ul class="simple">
<li><p>Wie werden Datentypen als Felder repräsentiert?</p></li>
<li><p>Wie werden Tupel als Datensätze repräsentiert?</p></li>
<li><p>Wie werden Mengen von Datensätzen oder Tupeln in Blöcken repräsentiert?</p></li>
<li><p>Wie werden Relationen als Mengen von Blöcken repräsentiert?</p></li>
<li><p>Was passiert bei variablen Feld- oder Tupellängen?</p></li>
<li><p>Was passiert wenn ich einen Block nicht einheitlich in Tupel einteilen kann?</p></li>
<li><p>Was passiert wenn sich die Größe eines Datensatzes ändert, insbesondere vergrößert?</p></li>
</ul>
<a class="reference internal image-reference" href="../_images/Datenelemente-meme.png"><img alt="Datenelemente-meme" src="../_images/Datenelemente-meme.png" style="width: 500px;" /></a>
</section>
<section id="datentypen">
<h2><span class="section-number">2.3. </span>Datentypen<a class="headerlink" href="#datentypen" title="Permalink to this headline">#</a></h2>
<p>Alle Daten werden letzendlich als Bitsequenzen dargestellt bzw. werden alle Daten irgendwann als Bytesequenzen dargestellt. Aus GDBS sollten die folgenden Datentypen bekannt sein:</p>
<ul class="simple">
<li><p><strong>Integer</strong> belegen im Speicher 2 oder 4 Byte</p></li>
<li><p><strong>Float</strong> belegen im Speicher 4 oder 8 Byte</p></li>
<li><p><strong>Strings fester Länge(CHAR(n))</strong>  sind Felder die feste n Bytes zur Verfügung haben. Die fehlenden Byte-Werte werden mit Nullwerten (<span class="math notranslate nohighlight">\(\perp\)</span>) ge-padded. Beispiel:‚Katze‘ in CHAR(8) wäre also K a t z e <span class="math notranslate nohighlight">\(\perp\)</span><span class="math notranslate nohighlight">\(\perp\)</span><span class="math notranslate nohighlight">\(\perp\)</span></p></li>
<li><p><strong>Strings variabler Länge(VARCHAR(n))</strong> werden mit n+1 Byte reserviert. Die Länge kann maximal 255 Byte sein, daher gibt es oft VARCHAR(255). Hier gibt es einmal die Variante, dass das erste Byte die Länge speichert, die weiteren die Attributwerte speichern und die fehlenden Bytes ignoriert werden. Beispiel: 5 K a t z e. Eine andere Variante ist, dass die ersten Bytes die Attributwerte speichern und hintendran ein null-Wert gespeichert wird. Beispiel: K a t z e <span class="math notranslate nohighlight">\(\perp\)</span>.</p></li>
</ul>
<a class="reference internal image-reference" href="../_images/Strings-meme.png"><img alt="Strings-meme" src="../_images/Strings-meme.png" style="width: 500px;" /></a>
<section id="datum-bit-boolean">
<h3><span class="section-number">2.3.1. </span>Datum / Bit / Boolean<a class="headerlink" href="#datum-bit-boolean" title="Permalink to this headline">#</a></h3>
<p><strong>DATE, TIME</strong> werden i.d.R. als String fester Länge repräsentiert. Ein Problem ist jedoch, dass die Zeit mit Bruchteilen von Sekunden gespeichert werden kann (theoretisch beliebig genau). Eine Lösung ist die Speicherung als String fester Länge mit maximaler Genauigkeit. Eine weiter Lösung ist die Speicherung als String variabler Länge.</p>
<p><strong>BIT(n)</strong> ermöglichen das Arbeiten mit sehr detaillierten Bits, das ist praktisch wenn z.B Hashwerte gespeichert werden sollen. Es gelten 8 Bits pro Byte, falls n nicht durch 8 teilbar ist werden die letzten Bits ignoriert. Beispiel: BIT(12): 010111110011 wird zu 01011111, 00110000.</p>
<p><strong>BOOLEAN</strong> setzt sich aus 8 Bits zusammen: Entweder 00000001 und 00000000 oder 11111111 und 00000000.</p>
</section>
</section>
<section id="datensatze">
<h2><span class="section-number">2.4. </span>Datensätze<a class="headerlink" href="#datensatze" title="Permalink to this headline">#</a></h2>
<p>Mithilfe den thematisierten Datentypen, lassen sich nun Datensätze zusammenstellen.</p>
<section id="datensatze-fester-lange">
<h3><span class="section-number">2.4.1. </span>Datensätze fester Länge<a class="headerlink" href="#datensatze-fester-lange" title="Permalink to this headline">#</a></h3>
<p>Jeder Datensatz hat ein Schema bestehend aus Namen und Datentypen der Felder, sowie Offset im Datensatz (Anmerkung: JEDER Datensatz!–Realisiert i.d.R. als Pointer auf das Schema). Betrachten wir das untere Schema für eine Relation Schauspieler, auf relationaler Ebene gibt es vier Attribute, die als Zeichenketten gespeichert werden. Eine sehr einfache Variante um die Größen der Tupel zu berechnen ist immer das Maximum zu wählen.
<br><br>
Wir nehmen an alle haben eine feste Länge: 30 Byte + 256 Byte + 1 Byte + 10 Byte = 297 Byte. Somit ist jeder Datensatz gleich groß. Es ist möglich, dass ein Datensatz nicht komplett belegt ist, dann wird dieser Speicher trotzdem besetzt.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">Schauspieler</span> <span class="p">(</span>
    <span class="n">Name</span> <span class="n">CHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
    <span class="n">Adresse</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
    <span class="n">Geschlecht</span> <span class="n">CHAR</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">Geburtstag</span> <span class="n">DATE</span> <span class="p">);</span>
</pre></div>
</div>
</section>
<section id="versatz-zur-effizienz">
<h3><span class="section-number">2.4.2. </span>Versatz zur Effizienz<a class="headerlink" href="#versatz-zur-effizienz" title="Permalink to this headline">#</a></h3>
<p>In der Realität gibt es je nach System noch zusätzliche Anforderungen, wie z.B das Felder am besten bei Hauptspeicheradressen beginnen, die ein Vielfaches von 4 (bzw. 8) sind. Manchmal ist das sogar Pflicht. Dementsprechend müssen die Felder versetzt werden. Für die Festplatte ist das eigentlich egal, aber der eingelesene Datensatz landet auf einem Speicherplatz mit entsprechender Adresse: Vielfaches von 4 oder Vielfaches von 2n. Entsprechend versetzt sind die anderen Felder auch. Im unteren Beispielbild sehen wir zuerst das Feld ohne Versatz und dann mit einem Versatz von zwei.</p>
<a class="reference internal image-reference" href="../_images/Versatz-zur-Effizienz.png"><img alt="Versatz-zur-Effizienz" src="../_images/Versatz-zur-Effizienz.png" style="width: 500px;" /></a>
</section>
</section>
<section id="speicherung-der-metadaten">
<h2><span class="section-number">2.5. </span>Speicherung der Metadaten<a class="headerlink" href="#speicherung-der-metadaten" title="Permalink to this headline">#</a></h2>
<p>Die Metadaten eines Datensatzes, sind z.B. das Schema bzw. der Pointer auf ein Schema, die Länge des Datensatzes oder der Timestamp der letzten Änderung bzw. des letzten Lesens. Diese werden als Header vor dem Datensatz gespeichert. In dem Bild unten reichen 12 Bytes an Speicher für die Metadaten.</p>
<a class="reference internal image-reference" href="../_images/Speicherung_Metadaten.png"><img alt="Speicherung_Metadaten" src="../_images/Speicherung_Metadaten.png" style="width: 500px;" /></a>
<section id="aufteilung-in-blocke">
<h3><span class="section-number">2.5.1. </span>Aufteilung in Blöcke<a class="headerlink" href="#aufteilung-in-blocke" title="Permalink to this headline">#</a></h3>
<p>Um die Datensätze in Blöcke aufzuteilen kann ein Blockheader benutzt werden, dieser besteht aus:</p>
<ul class="simple">
<li><p>Links auf andere Blocks (z.B. Index)</p></li>
<li><p>Rolle dieses Blocks (im Index)</p></li>
<li><p>Relation der Tupel</p></li>
<li><p>Verzeichnis der offsets der Datensätze</p></li>
<li><p>Block ID (gleich)</p></li>
<li><p>Timestamp der letzten Änderung / des letzten Lesens</p></li>
</ul>
<p>Im einfachsten Fall sind alle Datensätze aus der gleichen Relation und haben alle eine feste Länge.
<br><br>
<strong>Beispiel:</strong> Ein Datensatz besteht aus 316 Byte und ein Block aus 4096 Byte, wobei 12 Bytes für je einen Header benötigt werden. Das Ergebnis sind 12 Datensätze und 292 verlorene Bytes.</p>
<p>Datensätze pro Block = <span class="math notranslate nohighlight">\(\lfloor \frac {Datenblockgröße - Header}{Datensatzgröße}\rfloor \)</span> = <span class="math notranslate nohighlight">\(\lfloor \frac {4096 - 12}{316}\rfloor \)</span> = 12 Datensätze</p>
<p>Verlorene Bytes = Datenblockgröße - (Datensätze pro Block ∙ Datensatzgröße + Header) = 4096 Bytes - (12 ∙ 316 Bytes + 12 Bytes) = 292 Bytes</p>
<p>Dies gilt aber nur für Datensätze mit fester Länge, die nicht über mehrere Blöcke verteilt sind.</p>
<a class="reference internal image-reference" href="../_images/Aufteilung_in_Blöcke.png"><img alt="Aufteilung_in_Blöcke" src="../_images/Aufteilung_in_Blöcke.png" style="width: 500px;" /></a>
</section>
</section>
<section id="adressierung">
<h2><span class="section-number">2.6. </span>Adressierung<a class="headerlink" href="#adressierung" title="Permalink to this headline">#</a></h2>
<p>Die Adressierung findet zuerst im Hauptspeicher statt, hier wird die Adresse zuerst angefragt, welche auf die Adresse auf der Festplatte abgebildet wird. Bei einem Block im Hauptspeicher befindet sich die Block-Adresse im virtuellen Adressraum, diese Adresse zeigt auf das erste Byte des Blocks. Wenn ein konkreter Datensatz gesucht wird gibt es zusätzlich noch eine Datensatz-Adresse, die zeigt auf das erste Byte des Datensatzes.
Der Block auf der Festplatte ist unser Speicherort. Der genaue Speicherort im ganzen System wird bestimmt durch die DBMS–Disk ID, Zylinder# (falls HDD vorhanden), Spur#, Sektor, usw… Unser gefundene Datensatz ist dann der Block und der Offset des ersten Bytes.</p>
<section id="adressraum-des-servers">
<h3><span class="section-number">2.6.1. </span>Adressraum des Servers<a class="headerlink" href="#adressraum-des-servers" title="Permalink to this headline">#</a></h3>
<p>Es gibt zwei Möglichkeiten um den Adressraum für die Spezifizierung des Blocks zu benutzen:</p>
<ul class="simple">
<li><p>Variante 1: Es werden nur <strong>physische Adressen</strong> im Hauptspeicher angegeben, bestehend aus folgenden Informationen:</p>
<ul>
<li><p>Rechner ID</p></li>
<li><p>Disk ID 8-16 Byte</p></li>
<li><p>Zylinder# 8-16 Byte</p></li>
<li><p>Spur# (bei mehr als einer Oberfläche)</p></li>
<li><p>Sektor#</p></li>
<li><p>(Offset innerhalb des Blocks)</p></li>
</ul>
</li>
<li><p>Variante 2: Es werden nur <strong>logische Adressen</strong> im Hauptspeicher angegeben, welche mit einer Mapping Table in eine physische Adresse übersetzt werden. Eine logische Adresse besteht aus einem beliebigen Byte String. Diese Abstraktion ermöglicht es auch auf Adressen zu verweisen, die nicht der physischen Architektur aus Variante 1 entsprechen.</p></li>
</ul>
</section>
<section id="logische-adressen">
<h3><span class="section-number">2.6.2. </span>Logische Adressen<a class="headerlink" href="#logische-adressen" title="Permalink to this headline">#</a></h3>
<p>Durch die Indirektion der logischen Adressen, ist die Umorganisation von Datenänderungen flexibler, da sie nur auf der Mappingtable stattfindet. Eine logische Adresse bleibt zudem gleich, unabhängig davon ob es sich um eine HDD oder SSD handelt. Eine Hybride Adressierung ist auch möglich, indem es eine physische Adresse für einen Block und eine logische Adresse für einen Datensatz in dem Block, z.B. ein Schlüsselwert, gibt.</p>
<a class="reference internal image-reference" href="../_images/Logische-Adressen.png"><img alt="Logische-Adressen" src="../_images/Logische-Adressen.png" style="width: 500px;" /></a>
</section>
<section id="hybride-adressierung">
<h3><span class="section-number">2.6.3. </span>Hybride Adressierung<a class="headerlink" href="#hybride-adressierung" title="Permalink to this headline">#</a></h3>
<p>Die Idee bei der hybriden Adressierung ist, dass wir zunächst durch physische Adressen zu einem Block gelangen. Der Block selbst speichert die Offsettable. Das Problem welches hierbei auftreten kann, ist dass Datensätze entfernt und hinzugefügt werden und es zu Fragmentierung kommt. Um dagegen zu wirken, werden Blöcke bei Datensätzen variabler Länge von hinten aufgefüllt. Da die Anzahl der Datensätze nicht fest ist, kann die Größe des Headers offen gelassen werden. Vorteile der Flexibilität (auch ohne Mapping Table) sind, dass innerhalb eines Blocks umorganisiert werden kann. Und ein Datensatz sogar Blöcke wechseln kann, folglich wird die neue Adresse in der Offsettable gespeichert.</p>
<a class="reference internal image-reference" href="../_images/Hybride-Adressierung.png"><img alt="Hybride-Adressierung" src="../_images/Hybride-Adressierung.png" style="width: 500px;" /></a>
</section>
<section id="columnar-storage">
<h3><span class="section-number">2.6.4. </span>Columnar Storage<a class="headerlink" href="#columnar-storage" title="Permalink to this headline">#</a></h3>
<p>Bei Columnar Storages ist die Idee, dass die Datensätze Spalten speichern statt Tupel, diese überspannen i.d.R mehrere Blöcke. Die Reihenfolge der Attributwerterte erlaubt die Tupelrekonstruktion, alternativ können Tupel-Id’s mitgespeichert werden.
<br><br>
Beispiel: Es sind 2 Datensätze (4,7,9) und (a,b,c) gegeben. In Columnar Storages würden die Attributwerte hintereinander gespeichert werden, also zuerst 4 dann a usw.
<br><br>
Ein Anwendungsfall ist OLAP (Online analyticalprocessing). Hierbei benötigen die meisten Anfragen alle oder viele Werte einer Spalte und die Tupelrekonstruktion ist aufwändig. Was die Komprimierung angeht, ist ein Vorteil die geringeren Disk- und I/O-Kosten. Ein Nachteil ist, dass Columnar Storages nur gut auf großen Datenmengen funktionieren, aber effizienter Tupelzugriff erlaubt nur blockweise Komprimierung. Letztlich ist die Indizierung auch schwieriger.</p>
</section>
</section>
<section id="variable-langen">
<h2><span class="section-number">2.7. </span>Variable Längen<a class="headerlink" href="#variable-langen" title="Permalink to this headline">#</a></h2>
<p>Daten können auch variabler Länge sein. Z.B gibt es Felder variabler Länge, wie VARCHAR(255), wo die Adresse selten vollkommen ausgeschöpft wird. Es kann auch Datensätze variabler Länge geben, wo bei einem sehr großen Schema nur wenige Attribute belegt sind und Datensätzen um Felder ergänzt werden. Ebenso kann es zu riesigen Feldern kommen, verursacht durch z.B GIFs, MPEG–Passen ,die nicht mehr auf einen Block passen.</p>
<section id="finden-von-feldern-variabler-lange">
<h3><span class="section-number">2.7.1. </span>Finden von Feldern variabler Länge<a class="headerlink" href="#finden-von-feldern-variabler-lange" title="Permalink to this headline">#</a></h3>
<p>Datensätze müssen Informationen speichern, damit jedes Feld im Datensatz aufzufinden ist, wie z.B ein Header. Um das Löschen und Hinzufügen von Tupeln zu vereinfachen, ist die Idee Felder fester Länge an den Anfang des Datensatzes abzulegen und folgend alle Tupel variabler Längen. Dadurch müssen die Tupel fester Länge nicht umorganierst werden, wenn Tupel variabler Länge verändert werden. Eine weitere Idee ist, dass der Header die Länge des Datensatzes speichert, somit weiß man wann der aktuelle Datensatz aufhört und ein anderer beginnt. Zusätzlich können Pointer (offsets) zu den Anfängen aller Felder variabler Länge gespeichert werden.
<br><br>
In der Abbildung unten, ist so ein Beispielblock dargestellt. Zuerst kommt der Header, welcher die Länge des Datensatzes speichert, danach ein Pointer der zu dem Attribut Adresse zeigt, welches eine variable Länge hat. Falls Adresse NULL ist, dann wird ein Null-Pointer gespeichert.</p>
<a class="reference internal image-reference" href="../_images/Finden-von-Fehlern.png"><img alt="Finden-von-Fehlern" src="../_images/Finden-von-Fehlern.png" style="width: 500px;" /></a>
</section>
<section id="datensatze-variabler-lange">
<h3><span class="section-number">2.7.2. </span>Datensätze variabler Länge<a class="headerlink" href="#datensatze-variabler-lange" title="Permalink to this headline">#</a></h3>
<p>Es kann sein, dass unbekannt ist welche und wie viele Felder der Datensatz haben wird. Z.B bei der Informationsintegration, wo es noch unbekannt ist welche Felder von Quellen hinzukommen. Die Idee ist sich die Felder zu merken, welche vorhanden sind oder nicht. Das sind sogenannte Taggedfields(getaggte Felder), es werden die Informationen Feldname (Attributname), Feldtyp, Feldlänge und Feldwert gespeichert. Das Speichern dieses Overheads ist ebenfalls nützlich bei dünn besetzten Datensätze, wo es tausende Attribute gibt, aber nur wenige haben Werte.</p>
<a class="reference internal image-reference" href="../_images/Datensätze-variabler-Länge.png"><img alt="Datensätze-variabler-Länge" src="../_images/Datensätze-variabler-Länge.png" style="width: 500px;" /></a>
</section>
<section id="anwendungsfalls-sparsedatabeispiel-linkedopen-data">
<h3><span class="section-number">2.7.3. </span>Anwendungsfalls SparseDataBeispiel: LinkedOpen Data<a class="headerlink" href="#anwendungsfalls-sparsedatabeispiel-linkedopen-data" title="Permalink to this headline">#</a></h3>
<a class="reference internal image-reference" href="../_images/Linked-open-data.png"><img alt="Linked-open-data" src="../_images/Linked-open-data.png" style="width: 500px;" /></a>
<p>LinkedOpenData ist ein Phänomen, wo Daten offen und verfügbar dargestellt werden, s.d. Informationen semantisch aussagefähig sind. Insbesondere geht es darum Entitäten aus der realen Welt, Informationen und Webseiten so miteinander zu verlinken, s.d. semantische Informationen herleitbar sind. Es kann dazukommen, dass eine Entität über 2000 Attribute hat, weshalb getaggte Felder hier zum Einsatz kommen.</p>
</section>
<section id="microsoft-sql-server-sparse-columns">
<h3><span class="section-number">2.7.4. </span>Microsoft SQL Server: SPARSE columns<a class="headerlink" href="#microsoft-sql-server-sparse-columns" title="Permalink to this headline">#</a></h3>
<p>Ein Beispiel aus der realen Welt sind SPARSE columns auf Microsoft SQL Servern. Diese können wie im Code-Beispiel unten zu sehen ist, mit dem Keyword <code class="docutils literal notranslate"><span class="pre">SPARSE</span></code> deklariert werden. So wird dem System vermittelt, dass diese Spalten nicht immer gefüllt sind und es werden getaggte Felder für diese Spalten hinzugefügt. Hierfür gibt es eine Tabelle die angibt, bei wie viel Prozent an Null-Werten, sich das Speichern dieses Overheads kostentechnisch lohnen würde, für den jeweiligen Datentyp.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">DocumentStore</span><span class="p">(</span>
    <span class="n">DocIDintPRIMARY</span> <span class="n">KEY</span><span class="p">,</span>
    <span class="n">Title</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="n">NOT</span> <span class="n">NULL</span><span class="p">,</span>
    <span class="n">ProdSpecvarchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="n">SPARSE</span> <span class="n">NULL</span><span class="p">,</span>
    <span class="n">ProdLocsmallintSPARSE</span> <span class="n">NULL</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/SPARSE-columns.png"><img alt="SPARSE-columns" src="../_images/SPARSE-columns.png" style="width: 500px;" /></a>
</section>
<section id="zu-grosze-datensatze">
<h3><span class="section-number">2.7.5. </span>Zu große Datensätze<a class="headerlink" href="#zu-grosze-datensatze" title="Permalink to this headline">#</a></h3>
<p>Es kann Datensatzgrößen geben, die viel Platz verschwenden z.B. 51% eines Blocks ist nur belegt und die restlichen 49% werden verschwendet. Ebenso kann es übergroße Felder mit Mega-oder Gigabytegrößen geben. Beim Speichern solch großer Datensätze entstehen Datensatzfragmente, da ein Datensatz über mehr als einen Datensatz verteilt wird. Hierfür werden zusätzliche Informationen im Header gespeichert:</p>
<ul class="simple">
<li><p>Bit sagt ob Fragment oder nicht</p></li>
<li><p>Bits sagen ob erstes oder letztes Fragment</p></li>
<li><p>Zeiger zum nächsten und/oder vorigen Fragment–Doppelt verkettet Liste</p></li>
</ul>
<p>Beispiel für große Datensätze sind BLOBs = Binary Large Objects und CLOB = Character Large Objects. Diese beinhalten:</p>
<ul class="simple">
<li><p>Bilder/Grafiken: JPEG, GIF</p></li>
<li><p>Audio: mp3, …</p></li>
<li><p>Filme: MPEG, …
<br><br></p></li>
</ul>
<p>Wenn nun BLOBs oder CLOBs gelesen werden sollen, dann wird nicht mehr der ganze Datensatz aufeinmal gelesen, stattdessen wird ein Datenfragment gefunden und gelesen und je nach der Anfrage werden die restlichen Datenfragment folgend auch ermittelt und gelesen. Ein spannendes Thema ist die Navigation innerhalb des BLOBs (z.B. Sprung zur 45ten Minute bei einem Film auf einem Streamingdienst), da dies spezielle Indexstrukturen fordert.</p>
</section>
</section>
<section id="datensatzanderungen">
<h2><span class="section-number">2.8. </span>Datensatzänderungen<a class="headerlink" href="#datensatzanderungen" title="Permalink to this headline">#</a></h2>
<p><strong>Einfügen mit Platz</strong>
<br><br>
Wenn wir einen neuen Datensatz in unseren Speicher einfügen wollen und keine Ordnung verlangt wird, dann suchen wir nach einem freien Platz auf einem Block (oder suchen einen freien Block) und fügen diesen Datensatz dort ein. Falls eine Ordnung (z.B. nach Primärschlüssel) verlangt ist, wird nach dem entsprechenden Block gesucht. Falls dort Platz frei ist, werden die Datensätze auf dem Block bewegt, so dass der neue Datensatz an der entsprechenden Stelle eingefügt werden kann.</p>
<a class="reference internal image-reference" href="../_images/Einfügen-mit-Platz.png"><img alt="Einfügen-mit-Platz" src="../_images/Einfügen-mit-Platz.png" style="width: 500px;" /></a>
<p><strong>Einfügen ohne Platz</strong>
<br><br>
Wenn in dem eigentlichen Block kein Platz mehr ist, um einen weiteren Datensatz einzufügen gibt es zwei Varianten:</p>
<ul class="simple">
<li><p>Variante 1: Es wird ein Block in der Nähe gesucht, meist ist das der vorherige oder nächste Block. Dann wird der erste oder letze Datensatz zu dem jeweils neuen Block bewegt und eine Weiterleitungsadresse wird im alten Block hinterlegt(„Nachsendeauftrag“). Gegebenenfalls müssen die Datensätze in beiden Blöcken noch hin und her bewegt werden. Zuletzt wir der neue Datensatz an der richtigen Stelle im neu gesuchten Block eingefügt.
<br><br></p></li>
<li><p>Variante 2:  Es wird ein designierter Overflow Block erzeugt, dessen Adresse im Header des ursprünglichen Blocks gespeichert wird. Der neue Datensatz wird dann in den neu erzeugten Overflow Block eingefügt. Ein Overflow Block kann selbst wiederum einen Overflow Block haben.</p></li>
</ul>
<p><strong>Löschen</strong></p>
<p>Der zu löschende Datensatz wird gelöscht. Danach werden die Datensätze im Block verschoben, um den enstandenen freien Platz zu konsolidieren. Eine andere Möglichkeit ist, dass im Header eine Liste mit freien Plätzen verwaltet wird oder eine verkette Liste der freien Plätze. Je nach dem ob es zu dem Block noch Overflow Blöcke gibt, müssen diese reorganisiert werden. An der gelöschten Stelle befindet sich häufig ein sogenannter Grabstein(tombstones). Auch nachdem Löschen kann es noch einen Pointer auf den zu löschenden Datensatz geben. Es gibt drei Varianten einen Grabstein zu hinterlassen:</p>
<ul class="simple">
<li><p>Null-Pointer im Header</p></li>
<li><p>Null-Pointer in der Mappingtable</p></li>
<li><p>Grabstein am Anfang der Datensätze</p></li>
</ul>
<br>
Diese Grabsteine müssen (im Allgemeinen) ewig erhalten bleiben, bis die Datenbank re-organisiert wird.<a class="reference internal image-reference" href="../_images/Löschen-meme.png"><img alt="Löschen-meme" src="../_images/Löschen-meme.png" style="width: 500px;" /></a>
<br>
<p><strong>Update</strong></p>
<p>Bei fester Länge gibt es kein Problem beim Aktualisieren eines Datensatzes. Der alte Wert wird entfernt und der neue eingefügt. Bei variabler Länge treten dieselben Probleme auf wie beim Einfügen. Falls der neue Wert zu groß ist wird z.B ein Overflow Block erzeugt usw.</p>
<!-- <img src="pictures/update.png" alt="update" width="500" style="background-color: white;"/> --></section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "LUH-DBS/GDBS_Script",
            ref: "main/",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./02"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../01/speicherung.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">1. </span>Speicherung</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../03/indizes.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">3. </span>Indizes</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Prof. Dr. Ziawasch Abedjan<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>